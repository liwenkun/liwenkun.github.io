[{"title":"ViewPager 的使用","url":"/2016/04/16/2016-04-16-android-viewpager-usage/","content":"ViewPager什么是 ViewPager？图告诉你一切：\n\n\n\n\n\n\n\n\n\n\n\n如图，白色矩形区域就是我们的 ViewPager，正如我们所熟悉的，ViewPager 通常会配合 tab 使用，什么是 tab？就是“网易新闻，网易体育，网易财经，网易女人”（page title) 这四个标题所在的那个区域，每个 page title 代表着一个 tab 。这个区域再上面一点就是 ToolBar 了。 tab 的实现方法有很多种，但现在最受欢迎并且最美观的就是谷歌MD提供的 TabLayout 了。现在我们主要讲下 TabLayout + ViewPager 的实现和使用吧。\n\n\nViewPager 的使用布局文件：\n&lt;android.support.design.widget.TabLayout        android:id=&quot;@+id/tabs&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        app:tabIndicatorColor=&quot;#ffffff&quot;         app:tabSelectedTextColor=&quot;#ffffff&quot;        app:tabTextColor=&quot;#aaffffff&quot;        app:tabBackground=&quot;@drawable/tab_ripple&quot;/&gt;&lt;android.support.v4.view.ViewPager      android:id=&quot;@+id/viewpager&quot;      android:layout_width=&quot;match_parent&quot;      android:layout_height=&quot;match_parent&quot;/&gt;\n\n这就是 TabLayout + ViewPager 的布局文件 TabLayout 在上，ViewPager 在下。\njava代码：\nViewPager pager = null;TabLayout tabs = null;ArrayList&lt;View&gt; viewContainer = new ArrayList&lt;&gt;();ArrayList&lt;String&gt; titleContainer = new ArrayList&lt;&gt;(); @Overrideprotected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    initView();&#125;public void initView() &#123;   //其他布局初始化代码省略    pager = (ViewPager) findViewById(R.id.viewpager);    tabs = (TabLayout) findViewById(R.id.tabs);&#125;\n\n在代码中找到这两个控件之后，我们就要给他们添加数据了。总不能两个控件都是空内容吧。对于 TabLayout 来说，我们要给它添加的数据当然就是page title了；而对于 ViewPager 来说， ViewPager 是一个 ViewGroup 类，我们需要给他添加的数据就是添加四个子 View，这四个子View对应的就是我们的四个页面。怎么添加呢？继续看。\n对于 TabLayout，我们可以将数据源放在一个 ArrayList 中：\nArrayList&lt;String&gt; titleContainer = new ArrayList&lt;&gt;();titleContainer.add(&quot;网易新闻&quot;);titleContainer.add(&quot;网易体育&quot;);titleContainer.add(&quot;网易财经&quot;);titleContainer.add(&quot;网易女人&quot;);\n\n对于 ViewPager，我们同样将数据源放入一个 ArrayList 中：\nArrayList&lt;View&gt; viewContainer = new ArrayList&lt;&gt;();TextView view1,view2,view3,view4;(view1 = new TextView(this)).setText(&quot;页面一&quot;);(view2 = new TextView(this)).setText(&quot;页面二&quot;);(view3 = new TextView(this)).setText(&quot;页面三&quot;);(view4 = new TextView(this)).setText(&quot;页面四&quot;);viewContainer.add(view1);viewCOntainer.add(view2);viewContainer.add(view3);viewContainer.add(view4);\n\n这里我们给这个 ViewPager 添加的四个子 View 是四个 TextView;\n好了数据源都准备好了，那么我们应该怎样将数据送到相应的控件中呢？对于 TabLayout，方法有两种，我们先讲一种比较容易理解的：\nfor(String title : titleContainer) &#123;   tabs.add(tabs.newTab().setText(title));  //setText()的返回值是new出来的tab&#125;\n\n然后我们得将 viewContainer 中的那四个 view 添加进 ViewPager 中，当然，不是我们手动的 addView 去添加，而是像那些包含 itemView 的 AdapterView 那样去设置 Adapter。适配器模式有很多好处，首先能够将视图展示和数据绑定分离，其次能够很好的管理子 View，如动态的添加移除，还可以设置动画，并且能够实现视图回收和重用，如果手动添加这些是很难做到的。\n安卓提供了一个 PagerAdapter 来给 ViewPager 设置适配器，我们的子 View 就是通过这个适配器添加进 ViewPager 的：\n新建一个 PagerAdapter 通常要重写和实现的方法有：\n//获取页面的数量public int getCount();//判断某个子view是否和object关联，不理解这个方法没关系，官方推荐直接返回 view == object //就可以了 public boolean isViewFromObject(View view, Object object); //添加一个页面并返回关联这个页面的object,对应上面的我们只需这样做： //return viewContainer.get(position),即把子View返回 public Object instantiateItem(ViewGroup container, int position); //销毁一个页面 public void destroyItem(ViewGroup container, int position, Object object); //获取当前页面的page title，这个方法可以不重写，因为我们之前手动添加tab并且设置了 //page titlepublic CharSequence getPageTitle(int position）;\n\n一个典型的 PagerAdapter 可以这样写：\npager.setAdapter( new PagerAdapter() &#123;            @Override            public int getCount() &#123;                return  viewContainer.size();            &#125;            @Override            public boolean isViewFromObject(View view, Object object) &#123;                return  view == object;            &#125;            @Override            public Object instantiateItem(ViewGroup container, int position) &#123;                View view;                container.addView(view = viewContainer.get(position));                return view;            &#125;            @Override            public void destroyItem(ViewGroup container, int position,  Object            object) &#123;                                                         container.removeView(viewContainer.get(position));            &#125;            //可以不重写            @Override            public CharSequence getPageTitle(int position) &#123;                return titleContainer.get(position);            &#125;       &#125;);\n\n如果我们想要监听 ViewPager 页面滑动的事件，我们可以添加监听器：\npager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123;       @Override        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123;             Log.d(&quot;onPageSrolled：&quot;, &quot;我监听页面滚动事件&quot;);        &#125;        @Override        public void onPageSelected(int position) &#123;              Log.d(&quot;onPageSelected: &quot;, &quot;我监听页面选择事件&quot;);        &#125;        @Override        public void onPageScrollStateChanged(int state) &#123;             Log.d(&quot;onPageSrollStateChanged: &quot;, &quot;我监听页面滚动状态改变的事件&quot;);        &#125;    &#125;);\n\n现在你肯定会问怎么将 ViewPager 和 TabLayout 关联起来呢？代码中两者之间没有任何关联，但我们通常看到的是指示条会跟着 ViewPager 页面的切换滚动到相应的 page title 下，而且当前页面对应的 page title 会更“亮”。对，这也就是我当时碰到的一个坑， 少写了这一步：\npager.addOnPageChangeListener(new   TabLayout.TabLayoutOnPagerChangeListener(tabs));\n\n有了这一步，tabs 就能够监听 ViewPager 切换的事件了，从而能够做出相应改变。\n前面讲了，给 TabLayout 设置 page title 的方法有两种，其中一种是手动添加 ，那么现在就讲另一种方法：\n这种方法是把 TabLayout 设置 page title 的的任务交给 PagerAdapter 来做，最后将 TabLayout 和 ViewPager 绑定，这样 TabLayout 就和 PagerAdapter 产生某种关联，从而 TabLayout 能够获取标题信息。具体的做法是这样的：\n首先重写 PagerAdapter 中的 getPageTitle() 方法，因为我们没有手动添加 page title，而是交给 PagerAdapter 来处理，所以我们必须重写这个方法来获取 page title：\n@Overridepublic CharSequence getPageTitle(int position) &#123;    return titleContainer.get(position);&#125;\n\n之后，我们就要将 TabLayout 和 ViewPager 绑定：\ntabs.setupWithViewPager(pager);\n\n\n这样也能达到我们预期的效果了，而且我们连这一步：\npager.addOnPageChangeListener(new   TabLayout.TabLayoutOnPagerChangeListener(tabs));\n\n也不用写了，但是有一点要记住这个方法一定要是在 ViewPager  设置 PagerAdapter 之后调用，否则程序运行时会崩溃。\n可能出现的问题如果你的手机是安卓5.0以上，你的页面可能会出现下图这种情况：\n\n在 ToolBar 和 TabLayout 之间出现了一条阴影，这是因为 Toolbar 在安卓5.0以上默认 elevation 是不为零的，而 TabLayout 的高度为零，所以在 TabLayout 上造成了阴影，解决办法是将 TabLayout 放进 AppBarLayout 这个容器里，如下：\n&lt;android.support.design.widget.AppBarLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:theme=&quot;@style/AppTheme.AppBarOverlay&quot;&gt;        &lt;android.support.v7.widget.Toolbar            android:id=&quot;@+id/toolbar&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;?attr/actionBarSize&quot;            android:background=&quot;?attr/colorPrimary&quot;            app:popupTheme=&quot;@style/AppTheme.PopupOverlay&quot; /&gt;        &lt;android.support.design.widget.TabLayout            android:id=&quot;@+id/tabs&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;            app:tabIndicatorColor=&quot;#ffffff&quot;            app:tabSelectedTextColor=&quot;#ffffff&quot;            app:tabTextColor=&quot;#aaffffff&quot;            app:tabBackground=&quot;@drawable/tab_ripple&quot;/&gt;&lt;/android.support.design.widget.AppBarLayout&gt;\n\n这样就不会出现那条难看的阴影了。\n","tags":["Android","View"]},{"title":"安卓事件传递机制的理解","url":"/2016/04/28/2016-04-28-android-event-dispatch/","content":"安卓事件传递机制的理解事件产生的源头以及预处理当我们的手指点击（滑动）屏幕时，我们的手指就可能触发了一系列的事件，这些事件队列的排列顺序可以这样表示：{ ACTION_DOWN, ACTION_MOVE, ACTION_MOVE, ACTION_MOVE, … , ACTION_UP }，这样表示最开始我们触发的事件是ACTION_DOWN，然后是一至多个ACTION_MOVE事件（其实点击时也会触发ACTION_MOVE事件，因为屏幕很灵敏），当手指离开屏幕的瞬间，触发了一个 ACTION_UP 事件。\n事件既然产生了，那怎么传递呢？\n\n\n先别急，事件产生了，但还没获取呢。首先，消息获取模块会将事件通过pipe管道传递到客户端，然后 InputQueue 中的 next() 函数内部调用 nativePollOnce() 函数，该函数仅仅是一个 DISPATCH_POINTER 的异步消息，消息处理函数是 deliverPointerEvent() 函数。执行完该函数后，调用 finishInputEvent() 向消息获取模块发送一个回执，以使其进行下一个消息派送，真正完成绘制的代码是 native C++ 写的。\n在 deliverPointerEvent() 中，会进行一些转换，包括物理像素到逻辑像素的转换和屏幕坐标到视图坐标的转换，这都是为消息的派发做好准备。\n事件的传递执行了转换后，我们的事件即event便开始了漫长的旅途。\n如果用一句话来概括event的漫长路途的话便是：\ndeliverPointerEvent() 通过执行 mView.dispatchTouchEvent() 将消息派发给根视图（这个根视图具体是谁我们等下在后面会提到），之后mView便会将事件派发到整个 View 树。\n太抽象笼统了是吧？那我们便来细细分析，你可以泡上一杯茶或咖啡，跟随 event 看看他在漫长旅途中发生的了那些有趣的事。\n事件在进入View树之前的传递前面说了 event 的第一站便是 mView.dispatchTouchEvent()，该函数是在ViewRoot（注意 ViewRoot 不是 View 类，而是继承 Handle 类，用于对整个视图数的控制）中调用的，mView 有两种类型，对于应用窗口来说，mView 是一个 PhoneWindow 的 DecorView 类型，对于非应用窗口而言，mView 是一般的 ViewGroup 类型。\n在 DecorView 中，会判断是否存在 Callback 对象，这个 Callback 对象是谁呢？哈哈，竟然是 Activity，其实不奇怪，我们看源码就可以知道 Activity 实现了 Window.Callback 这个回调接口。如果不存在 Callback 对象的话，那么就直接调用 DecorView 父类 ViewGroup 中的 dispatchTouchEvent() 方法。\n我们首先看如果存在 Callback 对象即 Activity 时，event是在 Activity 中经历了什么。\n在 Activity 中，event 被传入了它的 dispatchTouchEvent() 方法：如果 event 的消息类型是 ACTION_DOWN，那么就调用 onUserInteraction()，这个方法是个空方法，什么也不干，只是让应用程序一个处理消息的机会，应用如果想在消息传递的最初始阶段想做些什么的话，就可以在这个函数中实现；然后这个方法中又会调用 Activity 关联的 Window 类对象的 superDispatchTouchEvent() 方法；如果 Window 类没有消耗该消息，那么 Activity 就会调用自己的 onTouchEvent() 方法，该方法也默认什么都不做，留给应用程序实现。\nWindow 类中在event身上又发生了什么呢，我们往下看：\nWindow 类的 superDispatchEvent() 方法中，会调用 mDecor 的 superDispatchTouchEvent() 方法，这个方法又会调用 super.dispatchTouchEvent()，即调用自己父类的 dispatchTouchEvent() 方法。看到这里我们猛然回头发现这是到了 DecorView 中如果不存在 Callback 对象时要走的另一条支路。\n为什么要这样做呢？很明显，这是让 event 在视图树中旅行之前给 Activity 一个处理它的机会。很明显，这一阶段虽然 event 已经进入 View 树的根视图中了，但是主要还是在 Activity 中被处理，所以还是把这阶段归结为在 Activity 中的传递\n之后开始才是 event 真正在视图树中的旅途了，它进入了视图树这个庞大的王国之中，各种有趣的事即将发生。\n事件在View树中的传递我们知道 DecorView 是一个 ViewGroup，所以我们从 ViewGroup 分析。\nevent 进入 ViewGroup 后，ViewGroup 便通过 dispatchTouchEvent() 方法将它派送，它先会被派送到 onInterceptTouchEvent() 中（决定是否将其拦截），这个方法的意思是拦截，在 ViewGroup 中，它的默认实现是：\npublic void onInterceptTouchEvent(MotionEvent event) &#123;   retrun false;&#125;\n\n这是不拦截意思。\n关于这个方法官方文档有段很长的话（本来想翻译的，但是想想怕翻译得不好坏了原本的意思），大家还是自己翻译看看\n/**  * Implement this method to intercept all touch screen motion events.  This  * allows you to watch events as they are dispatched to your children, and  * take ownership of the current gesture at any point.  *  * &lt;p&gt;Using this function takes some care, as it has a fairly complicated  * interaction with &#123;@link View#onTouchEvent(MotionEvent)  * View.onTouchEvent(MotionEvent)&#125;, and using it requires implementing  * that method as well as this one in the correct way.  Events will be  * received in the following order:  *  * &lt;ol&gt;  * &lt;li&gt; You will receive the down event here.  * &lt;li&gt; The down event will be handled either by a child of this view  * group, or given to your own onTouchEvent() method to handle; this means  * you should implement onTouchEvent() to return true, so you will  * continue to see the rest of the gesture (instead of looking for  * a parent view to handle it).  Also, by returning true from  * onTouchEvent(), you will not receive any following  * events in onInterceptTouchEvent() and all touch processing must  * happen in onTouchEvent() like normal.  * &lt;li&gt; For as long as you return false from this function, each following  * event (up to and including the final up) will be delivered first here  * and then to the target&#x27;s onTouchEvent().  * &lt;li&gt; If you return true from here, you will not receive any  * following events: the target view will receive the same event but  * with the action &#123;@link MotionEvent#ACTION_CANCEL&#125;, and all further  * events will be delivered to your onTouchEvent() method and no longer  * appear here.  * &lt;/ol&gt;  *  * @param ev The motion event being dispatched down the hierarchy.  * @return Return true to steal motion events from the children and have  * them dispatched to this ViewGroup through onTouchEvent().  * The current target will receive an ACTION_CANCEL event, and no further  * messages will be delivered here.  */  \n\n而 ViewGroup 中的 dispatchTouchEvent() 的源码是这样的\npublic boolean dispatchTouchEvent(MotionEvent ev) &#123;      final int action = ev.getAction();      final float xf = ev.getX();      final float yf = ev.getY();      final float scrolledXFloat = xf + mScrollX;      final float scrolledYFloat = yf + mScrollY;      final Rect frame = mTempRect;      boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;      if (action == MotionEvent.ACTION_DOWN) &#123;          if (mMotionTarget != null) &#123;              mMotionTarget = null;          &#125;          if (disallowIntercept || !onInterceptTouchEvent(ev)) &#123;              ev.setAction(MotionEvent.ACTION_DOWN);              final int scrolledXInt = (int) scrolledXFloat;              final int scrolledYInt = (int) scrolledYFloat;              final View[] children = mChildren;              final int count = mChildrenCount;              for (int i = count - 1; i &gt;= 0; i--) &#123;                  final View child = children[i];                  if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE                          || child.getAnimation() != null) &#123;                      child.getHitRect(frame);                      if (frame.contains(scrolledXInt, scrolledYInt)) &#123;                          final float xc = scrolledXFloat - child.mLeft;                          final float yc = scrolledYFloat - child.mTop;                          ev.setLocation(xc, yc);                          child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;                          if (child.dispatchTouchEvent(ev))  &#123;                              mMotionTarget = child;                              return true;                          &#125;                      &#125;                  &#125;              &#125;          &#125;      &#125;      boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) ||              (action == MotionEvent.ACTION_CANCEL);      if (isUpOrCancel) &#123;          mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;      &#125;      final View target = mMotionTarget;      if (target == null) &#123;          ev.setLocation(xf, yf);          if ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) &#123;              ev.setAction(MotionEvent.ACTION_CANCEL);              mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;          &#125;          return super.dispatchTouchEvent(ev);      &#125;      if (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) &#123;          final float xc = scrolledXFloat - (float) target.mLeft;          final float yc = scrolledYFloat - (float) target.mTop;          mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;          ev.setAction(MotionEvent.ACTION_CANCEL);          ev.setLocation(xc, yc);          if (!target.dispatchTouchEvent(ev)) &#123;          &#125;          mMotionTarget = null;          return true;      &#125;      if (isUpOrCancel) &#123;          mMotionTarget = null;      &#125;      final float xc = scrolledXFloat - (float) target.mLeft;      final float yc = scrolledYFloat - (float) target.mTop;      ev.setLocation(xc, yc);      if ((target.mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) &#123;          ev.setAction(MotionEvent.ACTION_CANCEL);          target.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;          mMotionTarget = null;      &#125;      return target.dispatchTouchEvent(ev);  &#125;  \n\n结合官方文档和源码我解释一下：\n1. 如果 disallowIntercept 为 false （默认是 false，子视图通过 requestDisallowInterceptTouchEvent(true) 可不允许父视图拦截消息），并且 onInterceptTouchEvent() 返回 true，那么 ViewGroup 就会拦截事件，事件不会给子视图处理，而是交由自己父类的 dispatchTouchEvent() 来处理，即 View 的 diapatchTouchEvent() 来处理，这也就相当与ViewGroup将事件交给了自己来处理。View 的 dispatchTouchEvent() 长什么样呢？我们看看源码：\npublic boolean dispatchTouchEvent(MotionEvent event) &#123;      if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;              mOnTouchListener.onTouch(this, event)) &#123;          return true;      &#125;      return onTouchEvent(event);  &#125;\n\n安卓5.0之后该方法的实现略带复杂，但是基本思想还是一样的，我们不妨就拿这个简单的来分析。在这个方法中会判断这个 View 的 OnTouchListener 回调接口是否存在，View 是不是 ENABLE 状态，是的话就会继续执行到第三个条件，第三个条件其实执行了 OnTouchListener 的 onTouch() 方法，这个方法是我们调用 view.setOnTouchListener() 时实现的。如果这个方法返回了 true， 那么 dispatchEvent() 方法也返回 true，dispatchEvent() 方法执行完毕；如果回调接口不存在，或者这个 View 是 DISABLE 状态，或者 onTouch() 返回 false（即 onTouch() 未消耗该 event）时， 便会执行 onTouchEvent() 方法。如果 onTouchEvent() 返回 false （即这个方法也未消耗 event)时，dispatchTouchEvent() 返回 false，从而表明 View 未消耗这个事件；反之 onTouchEvent() 返回 true 即消耗了这个事件时，dispatchTouchEvent() 也返回 true，表明 View 消耗了该事件。\n从上面的分析，我们可以看出，一个 event 在 View 中，首先会被 dispatchTouchEvent() 派发给 onTouch() 处理（前提是注册了 onTouch() 事件），如果 onTouch() 返回 true（消耗了该 event），event 在 View 中的旅程就结束了，dispatchTouchEvent()返回 true；如果没消耗就会继续派发给  onTouchEvent() 来处理，dispatchTouchEvent() 会将 onTouchEvent() 的返回值作为自己的返回值。\n接下来我们自然想知道，event 在 onTouchEvent() 方法中会发生什么呢，我们看看源码：\npublic boolean onTouchEvent(MotionEvent event) &#123;      final int viewFlags = mViewFlags;      if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;          // A disabled view that is clickable still consumes the touch          // events, it just doesn&#x27;t respond to them.          return (((viewFlags &amp; CLICKABLE) == CLICKABLE ||                  (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));      &#125;      if (mTouchDelegate != null) &#123;          if (mTouchDelegate.onTouchEvent(event)) &#123;              return true;          &#125;      &#125;      if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||              (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;          switch (event.getAction()) &#123;              case MotionEvent.ACTION_UP:                  boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0;                  if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) &#123;                      // take focus if we don&#x27;t have it already and we should in                      // touch mode.                      boolean focusTaken = false;                      if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;                          focusTaken = requestFocus();                      &#125;                      if (!mHasPerformedLongPress) &#123;                          // This is a tap, so remove the longpress check                          removeLongPressCallback();                          // Only perform take click actions if we were in the pressed state                          if (!focusTaken) &#123;                              // Use a Runnable and post this rather than calling                              // performClick directly. This lets other visual                              // state of the view update before click actions start.                              if (mPerformClick == null) &#123;                                  mPerformClick = new PerformClick();                              &#125;                              if (!post(mPerformClick)) &#123;                                  performClick();                              &#125;                          &#125;                      &#125;                      if (mUnsetPressedState == null) &#123;                          mUnsetPressedState = new UnsetPressedState();                      &#125;                      if (prepressed) &#123;                          mPrivateFlags |= PRESSED;                          refreshDrawableState();                          postDelayed(mUnsetPressedState,                                  ViewConfiguration.getPressedStateDuration());                      &#125; else if (!post(mUnsetPressedState)) &#123;                          // If the post failed, unpress right now                          mUnsetPressedState.run();                      &#125;                      removeTapCallback();                  &#125;                  break;              case MotionEvent.ACTION_DOWN:                  if (mPendingCheckForTap == null) &#123;                      mPendingCheckForTap = new CheckForTap();                  &#125;                  mPrivateFlags |= PREPRESSED;                  mHasPerformedLongPress = false;                  postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());                  break;              case MotionEvent.ACTION_CANCEL:                  mPrivateFlags &amp;= ~PRESSED;                  refreshDrawableState();                  removeTapCallback();                  break;              case MotionEvent.ACTION_MOVE:                  final int x = (int) event.getX();                  final int y = (int) event.getY();                  // Be lenient about moving outside of buttons                  int slop = mTouchSlop;                  if ((x &lt; 0 - slop) || (x &gt;= getWidth() + slop) ||                          (y &lt; 0 - slop) || (y &gt;= getHeight() + slop)) &#123;                      // Outside button                      removeTapCallback();                      if ((mPrivateFlags &amp; PRESSED) != 0) &#123;                          // Remove any future long press/tap checks                          removeLongPressCallback();                          // Need to switch from pressed to not pressed                          mPrivateFlags &amp;= ~PRESSED;                          refreshDrawableState();                      &#125;                  &#125;                  break;          &#125;          return true;      &#125;      return false;  &#125;  \n\n在 onTouchEvent() 方法中我们看到，如果这个 View 是可点击的，那么对于 ACTOIN_UP 事件，我们就发送一个异步消息来处理点击事件，如果异步消息没有发送成功，那么就会立即执行点击事件，在源码中也就是 performClick() 方法，performClick() 方法是怎样的呢，如果你看了源码就知道则个方法里执行的是我们 View 注册点击事件，即 OnClickListener的onClick() 方法。当然 ACTOIN_UP 有还有可能会触发长按事件 onLongClick()，这里就不详细介绍了。\n2. 如果 disallowIntercept 为 false 并且 ViewGroup 没有拦截 event（即返回 false ），或者 disallowIntercept 为 true，那么事件就会传给 ViewGroup 中被点击的那个子视图（这里包括前面所讲的子&#x2F;父视图都包括 View 和 ViewGroup），这样就回到了事件在 View 或者 ViewGroup 的传递过程了，我们就可以按照前面的分析用递归思想理解后续的过程。\n需要注意的是，在 ViewGroup 的 dispatchTouchEvent() 方法中，我们能够知道，如果当事件  ACTION_DOWN 没有找到目标子视图（可能原因是没有点击到任何子视图或者虽然有子视图被点击但是该子视图没有消耗该事件，即子视图的 dispatchTouchEvent() 方法返回 false）时，ViewGroup 会将事件交给自己处理，并且之后的 ACTION_MOVE 和 ACTION_UP 事件都不会交给任何子视图处理，也是全交给自己处理，也即前面讲的交给 super.dispatchTouchEvent() 来处理。\n说明1. 一个视图是否消耗该事件，表现在 dispatchTouchEvent() 的返回值上，如返回 true 表示消耗 false 表示未消耗；而一个消息处理方法（指的是 ouTouch() 和 onEventTouch()，不包括  onInterceptTouchEvent())是否消耗该事件表现在该方法的返回值上，例如 onTouch() 方法返回 true 表示消耗 false 表示未消耗。\n2. 如果某个视图的某个消息处理方法消耗该事件，会使得该视图的 dispatchTouchEvent() 方法返回 true，即该视图消耗了该事件；如果某个视图的所有消息处理方法都返回 false，那么这个视图的 dispatchTouchEvent() 方法返回 false，即该视图没有消耗该事件。\n到了这里安卓事件的传递就应该结束了，但我在这之中省略了对 ViewGroup 是如何找到被点击的子视图的的分析，这个我会在之后分享。以上便是我对安卓 View 的事件传递机制的理解，有什么疏漏或者错误的地方欢迎大家指出。\n参考文章：http://blog.csdn.net/guolin_blog&#x2F;article&#x2F;details&#x2F;9097463、http://blog.csdn.net/guolin_blog&#x2F;article&#x2F;details&#x2F;9153761\n参考书籍：《Android 内核剖析》柯元旦 著\n","tags":["Android","View"]},{"title":"浅析 hashcode() 和 equals()","url":"/2016/05/03/2016-05-03-java-hashcode-and-equals/","content":"浅析 hashcode() 和 equals()在 Java 中，equals() 的默认实现的是判断两个引用变量是否指向同一内存空间，即这两个引用变量是否是对同一实例的引用。而 hashcode() 默认实现与 native 方法相关，我的猜测是和这两个引用所指对象的内存地址有关，事实上的确是这样。为什么我的猜测会是正确的呢？我们来分析原因。\n\n\nJava 文档对子类重写这两个方法的要求是：\n\n要么两个方法都重写，要么都不重写；\n如果两个对象的通过 equals 方法比较返回 true，那么这两个方法的 hashcode 必须相等；  \n如果这两个对象的 hashcode 相等，这两个对象不一定 equals 比较后返回 true。\n\n看看 String 的 hashcode() 方法和 equals() 方法：\n\nhashcode() :\n\n@Override public int hashCode() &#123;        int hash = hashCode;        if (hash == 0) &#123;            if (count == 0) &#123;                return 0;            &#125;            for (int i = 0; i &lt; count; ++i) &#123;                hash = 31 * hash + charAt(i);            &#125;            hashCode = hash;        &#125;        return hash;&#125;\n\n\nequals()：\n\n@Override public boolean equals(Object other) &#123;        if (other == this) &#123;          return true;        &#125;        if (other instanceof String) &#123;            String s = (String)other;            int count = this.count;            if (s.count != count) &#123;                return false;            &#125;                        if (hashCode() != s.hashCode()) &#123;                return false;            &#125;            for (int i = 0; i &lt; count; ++i) &#123;                if (charAt(i) != s.charAt(i)) &#123;                    return false;                &#125;            &#125;            return true;        &#125; else &#123;            return false;        &#125;&#125;\n\n对于 String， 我们可以看到：\n\nequals() 方法的 “关键变量”（比较的依据）是字符串中的每个字符。但是为了程序效率，这个方法一开始并不会逐个比较两个字符串的字符，而是先比较它们长度是否相等，再看它们的 hashcode() 是否相等（按照规范，如果两个对象相等，它们的 hashcode() 一定相等），最后才出 “杀手锏”，逐个地比较它们的字符。\nhashcode() 方法返回的是对每个字符的 ascii 码进行加权求和。\n\n从文档的规范和 String 中两个方法的实现我们可以暂时可以推导出这样的结论：hashcode() 方法的返回值一定是通过对 equals() 中的关键变量进行某种函数变换得到的（简单点说就是和关键变量有关），只有这样才能保证 equals() 返回 ture &#x3D;&gt; 关键变量相等 &#x3D;&gt; hashcode() 返回值相等。\n对于我们自定义的类，如果要重写这两个方法，应该首先重写 equals()。因为根据第二点要求，hashcode() 方法的实现应该是建立在 equals() 方法之上的：在重写 equals() 方法之后，我们再去保证对于 euqals() 比较返回 true 的两个对象，如何让它们的 hashcode() 返回值相等。\n例如，定义一个 People 类：\npublic class People &#123;    private int age;    private String name;    private String hometown;    ......&#125;\n如果有这样的定义：对于 People 的两个对象 a 和 b，如果它们的 name 相等我们就认为这两个对象相等。那么 People 的 equals() 方法就应该是这样实现的：\npublic boolean equals(Object other) &#123;    if (！other instanceof People)        return false;    if(hashcode() != other.hashcode())        return false;        return name == null ? other.name == null : name.equals(other.name);&#125;\n\nequals() 的 “关键变量” 是 name，所以 hashcode() 的返回值必须是通过对 name 的某种函数变换得到的。\npublic int hashcode() &#123;     // 在 String 中，hashcode() 返回值就是通过对字符串的函数变换得到的，     // 因此这里直接返回 name 的 hashcode 也能保证 People 的 hashcode() 返回值是     // 通过对 name 的函数变换得到的     return name.hashcode(); &#125;\n\n按照上面的实现，我们可以保证，如果 a.equals(b) == true，一定有 a.hashcode() == b.hashcode()。\n如果我们按照下面这样实现 hashcode() 会怎样呢？\npublic int hashcode() &#123;   return hometown.hashcode();&#125; \n\n在上面的实现中，hashcode() 的返回值并不和 “关键变量” 有关，我们看看这会导致什么问题：假如有两个人 name 相等，hometown 不相等，那么它们通过 equals() 比较会返回 true，但是由于 hometown 的不相等会直接导致它们 hometown.hashcode() 的返回值不相等，进而导致它们自己的 hashcode() 返回值不相等，这显然违背了 java 的规范。\n现在考虑判断两个人相等另一种定义：如果两个 People 对象的 name 和 hometown 都相同，那么它们相等。\n那么对于 equals() 方法来说，中规中矩的实现是这样的：\npublic boolean equals(Object other) &#123;    if (! other instanceof People)        return false;            return (name == null ?                other.name == null : name.equals(other.name))        &amp;&amp; (hometown == null ?               other.hometown == null : hometown.equals(other.hometown));&#125;\n而对于 hashcode() 方法来说，就可以这样实现（不是最好的做法，但是符合 java 规范）：\npublic int hashcode() &#123;     return name.hashcode() + hometown.hashcode();&#125;\n下面的实现也是可以的（同样不建议这样做）：\npublic int hashcode()  &#123;   // 返回值只与其中的一个关键变量有关，   // 虽然这样容易导致 hashcode 的聚集，但是理论上也符合 java 的规范   return name.hashcode() ;&#125;\n或者（推荐的做法）:\npublic int hashcode() &#123;    int k = 17; // 任意的起始值    k = k * 31 + name.hashcode();    k = k * 31 + hometown.hashcode();    return k;&#125;\n\n但是这样就绝对是错误的（与无关变量 age 有关）：\npublic int hashcode() &#123;     return homtown.hashcode() + age;&#125;\n\n对于上面这种实现，虽然保证了和关键变量 hometown 有关，但是却引入 age 这个非关键变量（无关变量），我们看看这样做有什么问题：有两个 People 对象，它们的 name 和 hometown 相同，但 age 不相等，那么它们通过 equals() 比较会返回 true， 但它们 hashcode() 的返回值却不相等，因为 age 的不相等导致 hometown.hashcode() + age 不相等，进而导致了这两个对象 hashcode() 的返回值不相等。\n因此对于开头的结论，我们还需要进行完善：hashcode() 方法的返回值一定是通过对 equals() 中的关键变量进行某种函数变换得到的（简单点说就是和关键变量有关），并且不能和非关键变量（无关变量，即 equals() 方法中用不到的变量）有关。\n现在回到开头的问题：为什么 hashcode() 方法的默认实现与地址相关？因为在 equals() 的默认实现中，关键变量是两个引用变量所指向的内存地址，因此 hashcode() 方法返回值必须和对象的内存地址有关。\n感谢阅读由于只是说明 hashcode() 和 equals() 的内在联系，因此文章中有的例子并是 hashcode() 和 equals() 的最佳实现（但还是满足 java 规范，对于最佳实现可以参考 《Effective Java》 这本书）。另外如果有什么不对的话，还望大家不吝赐教。\n参考书籍：《Effective Java》\n","tags":["Java"]},{"title":"RxJava 原理探究","url":"/2016/09/03/2016-09-04-rxjava/","content":"RxJava 原理探究关于 RxJava 的文章网上有很多，这里只是个人的学习总结，阅读前需要对 RxJava 有一定的了解，并不能作为学习资料，如果想要入门这里有更好的选择：给 Android 开发者的 RxJava 详解（虽然版本有点久，很多 API 都已过时，但原理差不多，不影响理解）。\n\n\n如果只是想了解 API 的使用，可以看看 ReactiveX&#x2F;RxJava文档中文版。\n什么是 RxJava\nRxJava is a Java VM implementation of ReactiveX (Reactive Extensions): a library for composing asynchronous and event-based programs by using observable sequences.\n\n翻译一下就是：RxJava 是响应式扩展库在 Java 虚拟机上的实现，它使用观察者模式为异步和基于事件程序的编写提供便利。\n为什么是 RxJava关于 RxJava 的优点网上总结了很多，总的说来就是使得代码整洁、逻辑清晰。它能将本来一段逻辑复杂、外观参差错落的代码，变成一条逻辑清晰的长链，使得可阅读性和可维护性大大提高。\n以下例子改编自《给 Android 开发者的 RxJava 详解》：\n\n界面上有一个自定义的视图 imageCollectorView ，它的作用是显示多张图片，并能使用 addImage(Bitmap) 方法来任意增加显示的图片。现在需要程序将一个给出的目录数组 File[] folders 中每个目录下的 png 图片都加载出来并显示在 imageCollectorView 中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在 UI 线程执行。常用的实现方式有多种，我这里贴出其中一种：\n\nnew Thread() &#123;    @Override    public void run() &#123;        super.run();        for (File folder : folders) &#123;            File[] files = folder.listFiles();            for (File file : files) &#123;                if (file.getName().endsWith(&quot;.png&quot;)) &#123;                    final Bitmap bitmap = getBitmapFromFile(file);                    getActivity().runOnUiThread(new Runnable() &#123;                        @Override                        public void run() &#123;                            imageCollectorView.addImage(bitmap);                        &#125;                    &#125;);                &#125;            &#125;        &#125;    &#125;&#125;.start();\n\n而如果使用 RxJava ，实现方式是这样的：\n\nObservable.from(folders)    .flatMap(new Function&lt;File, Observable&lt;File&gt;&gt;() &#123;        @Override        public Observable&lt;File&gt; apply(File file) &#123;            return Observable.from(file.listFiles());        &#125;    &#125;)    .filter(new Function&lt;File, Boolean&gt;() &#123;        @Override        public Boolean apply(File file) &#123;            return file.getName().endsWith(&quot;.png&quot;);        &#125;    &#125;)    .map(new Function&lt;File, Bitmap&gt;() &#123;        @Override        public Bitmap apply(File file) &#123;            return getBitmapFromFile(file);        &#125;    &#125;)    .subscribeOn(Schedulers.io())    .observeOn(AndroidSchedulers.mainThread())    .subscribe(new Consumer&lt;Bitmap&gt;() &#123;        @Override        public void accept(Bitmap bitmap) &#123;            imageCollectorView.addImage(bitmap);        &#125;    &#125;);\n简单解释下这段代码：观察者发出数据源，然后对数据源进行三次数据类型变换，之后指定被观察者和观察者所在线程，最后对观察者进行订阅。\n如果对 java 8 引入的 Stream 熟悉的话，就会发现这与对 Stream 的操作很像，从flatMap() 到 observeOn() 的操作相当于对流的 Intermediate 操作，而最后的 subscribe() 相当是对流的 Terminal 操作。而且前面的操作也都是惰性化(lazy)的，最后的订阅才会触发前面一系列的变换操作（其实 subscribeOn() 和 observeOn() 这两个方法也是基于变换的）。怎么理解呢，就相当于 RxJava 库将这些操作先 “缓存” 起来了，直到最后的订阅观察者才将那些操作执行，怎么 “缓存” 是库做的事，逻辑上我们可以把那些操作看作是从上到下按顺序执行的。\n可见，RxJava 虽然增加了程序代码，但是可阅读性和可扩展性大大增强。\n了解过 RxJava 的人都会觉得 RxJava 很神奇，几行代码便完成了数据流的转换和线程的切换。那么它的内部原理是怎样的呢，通过阅读源码和网上的资料，我对 RxJava 的实现原理有了大概的了解，接下来就和大家分享一下。\n对 RxJava 实现原理的粗浅理解约定由于 RxJava 同时应用了观察者模式（别名：发布-订阅模式）和生产者-消费者模式，所以其 API 的名称有点混乱。为了避免读者理解困难，这里约定如下：\n\nObservable 及其子类称为 被观察者；\nComsumer（消费者） 和 Observer（观察者） 及其子类统称为 观察者（两者在 RxJava 含义相似）；\n由于 RxJava 订阅的动作（subscribe）定义在 Observale 中，给我们的感觉是 被观察者 订阅 观察者，因此为了叙述方便和避免含义混乱，被观察者 订阅 观察者 和 观察者 订阅 观被察者 是同样的意思；\n本文基于 RxJava 2.0.7 版。\n\n变换变换是 RxJava 的亮点和理解上的难点，变换的作用是将一种数据类型转换成另一种数据类型。当被观察者发出的原始数据类型并不是观察者想要的数据类型时，我们就可以用变换来实现源数据类型和目的数据类型的转换。RxJava 中有很多种变换，如 map 变换、flatMap 变换、filter 变换等。其中 map 变换比较基础也较易理解，因此我们先从 map 变换讲起。\nmap 变换 map 变换能够将一种类型的数据源转换成另一种类型的数据源，比如要将 int 类型的图片资源 id 转换成 Bitmap 类型的对象并将其设置给一个  ImageView ，我们可以这样做：\nObservble.just(R.id.img_example) // 1         .map(new Function&lt;Integer, Bitmap&gt;() &#123; // 2              @Override              public Bitmap apply(Integer resourceId) &#123;                 return BitmapFactory.decodeResource(resourceId);              &#125;          &#125;)          .subscribe(new Consumer&lt;String&gt;() &#123; // 4            @Override            public void accept(@NonNull Bitmap b) throws Exception &#123;                imageView.setImageBitmap(b);            &#125;        &#125;);\n\n上面的例子里将上游的 int 数据类型转换成了 Bitmap 类型的数据，供下游的观察者接收。这个过程涉及了一次 map 变换，我们将透过这个例子分析 map 变换的原理。\n首先从变换方法 public Bitmap apply(Integer resourceId) 看起，这个方法的参数类型是 Integer，返回值类型是 Bitmap ，因此我们很容易猜想到它就是实现变换的核心方法。这个方法被包装后就传入了 map() 中，map() 的源码是这样的：\npublic final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) &#123;     ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);     return RxJavaPlugins.onAssembly(new ObservableMap&lt;T, R&gt;(this, mapper)); // 3&#125;\n方法中第一行验证 mapper 是否为空；第二行中的 RxJavaPlugin.onAssenbly() 是一个钩子方法，据说是用来调试 RxJava 库用的，你可以把它理解为什么都没做，因此 map() 方法可以简化为：return new ObservableMap&lt;T, R&gt;(this, mapper);，它返回的是一个 Observable 子类 ObservableMap 的一个实例。现在我重点看看 ObservableMap 这个类：\npublic final class ObservableMap&lt;T, U&gt; extends AbstractObservableWithUpstream&lt;T, U&gt; &#123;    //用来做数据变换的函数式对象，就是 map() 的参数，且称其为变换器    final Function&lt;? super T, ? extends U&gt; function;    //source 是实际 Observalbe 对象，也就是 map 变换之前的那个 Observable    public ObservableMap(ObservableSource&lt;T&gt; source, Function&lt;? super T, ? extends U&gt; function) &#123;        super(source);        this.function = function;    &#125;    //调用 Observable 的 subscribe() 方法发起订阅时，subscribe() 最终会调用此方法    @Override    public void subscribeActual(Observer&lt;? super U&gt; t) &#123;  // 5        //新建一个 MapObserver 观察者，用来订阅实际 Observable 对象 source        source.subscribe(new MapObserver&lt;T, U&gt;(t, function)); // 6    &#125;    //此类的构造方法传入的参数是变换器 mapper 和真实观察者 actual    static final class MapObserver&lt;T, U&gt; extends BasicFuseableObserver&lt;T, U&gt; &#123;        final Function&lt;? super T, ? extends U&gt; mapper;        MapObserver(Observer&lt;? super U&gt; actual, Function&lt;? super T, ? extends U&gt; mapper) &#123;            super(actual);            this.mapper = mapper;        &#125;        @Override        public void onNext(T t) &#123; // 7            ......            U v;            try &#123;                //通过转换器把从原 Observable 对象发出的数据转化成真实观察者要求的数据                v = ObjectHelper.requireNonNull(mapper.apply(t), &quot;The mapper function returned a null value.&quot;);            &#125; catch (Throwable ex) &#123;                //如果出错，最终会调用 actual 的 onError() 方法                fail(ex); // 8.1                return;            &#125;            //将转换后的数据传给真实观察者            actual.onNext(v); // 8.2        &#125;        ......&#125;\n因为代码不多，我全部贴上来，便于大家理解。在上面的过程中，有这几类角色：1）实际被观察者；2）新创建的被观察者；3）实际观察者；4）新创建的观察者；5）转换器 mapper。它们的关系比较复杂，我们按照代码的执行顺序来将思路理一遍：\n\nObservable 通过 just() 这个静态工厂方法创建了一个 Observable 对象，此对象即“实际被观察者”；\nmap() 方法接受一个转换器对象，在内部新建了一个被观察者后将其返回，也就是 “新创建的被观察者”；\n用 map 变换后返回的那个 “新创建的被观察者” 订阅 “实际观察者”，最终 “新创建的被观察者” 的 subscribeActual() 方法被调用，此方法触发的操作有：\n创建一个观察者，也就是 “新创建的观察者”，向 “实际的被观察者” 订阅；\n实际的被观察者发出数据，通过调用 “新创建的观察者” 的 onNext() 方法向其传递数据；\n在新创建的被观察者的内部先用 “转换器” 的 apply() 方法将数据类型进行转换，然后调用 “实际观察者” 的 onNext() 方法将转换后的数据传给 “实际观察者”\n\n整个过程有点复杂，所以我在上述代码片段中用序号来表示各个过程的调用顺序，同时用一张图来表示 map 变换过程中以上几个角色的交互过程：\n\n说明：\n\nA 表示实际被观察者，B 表示新创建的观察者，C 表示新创建的被观察者，D 表示实际的观察者，E 代表转换器；\n虚线框中的 B 和 C 是 map 变换导致的新创建的角色，它们没有发生订阅关系，但是 C 一旦被订阅就会导致 B 的创建和对实际观察者的订阅；\nB 和 D 都是观察者，它们进行了直接的接触：B 将信息转换后交给 D;\n\n如果大家理解了一次 map 变换的原理，连续两次 map 变换的的原理就不难理解了，在这里就不赘述了，贴一张和上面类似的交互图，请大家自行理解：\n\nflatMap 变换此处先占坑，日后来填\n","tags":["Java","开源库"]},{"title":"安卓进程通信机制之 AIDL","url":"/2016/10/28/2016-10-28-android-IPC-AIDL/","content":"安卓进程通信机制之 AIDL什么是 AIDLAIDL 全称 Android Interface Definition Language，即 安卓接口描述语言。听起来很深奥，其实它的本质就是生成进程间通信接口的辅助工具。它的存在形式是一种 .aidl 文件，开发者需要做的就是在该文件中定义进程间通信的接口，编译的时候 IDE 就会根据我们的 .aidl 接口文件生成可供项目使用的 .java 文件，这和我们说的“语法糖”有些类似。\nAIDL 的语法就是 java 的语法，就是导包上有点细微差别。java 中如果两个类在相同的包中，是不需要进行导包操作的，但是在 AIDL 中，则必须进行导包声明。\n\n\nAIDL 详解构想一个场景：我们有一个图书管理系统，这个系统的通过 CS 模式来实现。具体的管理功能由服务端进程来实现，客户端只需要调用相应的接口就可以。\n那么首先定义这个管理系统的 ADIL 接口。\n我们在 /src 新建 aidl 包，包中有 Book.java 、Book.aidl、IBookManager.aidl 这三个文件。\n\nBook.java\n\npackage com.example.aidl bookpublic class Book implements Parcelable&#123;    String name;    int bookId;    public Book(String name, int bookId) &#123;        this.name = name;        this.bookId = bookId;    &#125;        private Book(Parcel source) &#123;        this.name = source.readString();        this.bookId = source.readInt();    &#125;        @Override    public int describeContents() &#123;        return 0;    &#125;    @Override    public void writeToParcel(Parcel dest, int flags) &#123;        dest.writeString(name);        dest.writeInt(bookId);    &#125;        public static Creator&lt;Book&gt;  CREATOR = new Creator&lt;Book&gt;() &#123;        @Override        public Book createFromParcel(Parcel source) &#123;            return new Book(source);        &#125;        @Override        public Book[] newArray(int size) &#123;            return new Book[size];        &#125;    &#125;;&#125;\n\n\nBook.aidl\n\npackage com.example.aidl;Parcelable Book;\n\n\nIBookManager.aidl\n\npackage com.example.aidl;import com.example.aidl.Book;inteface IBookManager &#123;   List&lt;Book&gt; getBookList();   void addBook(in Book book);&#125;\n\n下面对这三个文件分别进行说明：\n\nBook.java 是我们定义的实体类，它实现了 Parcelable 接口，这样 Book 类才能在进程间传输。\nBook.aidl 是这个实体类在 AIDL 中的声明。\nIBookManager 是服务端和客户端通信的接口。（注意，在 AIDL 接口中除基本类型外，参数前须加方向，in 表示输入型参数，out 表示输出型参数，inout 表示输入输出型参数）\n\n编译器编译后，android studio 为我们的项目自动生成了一个 .java 文件，这个文件包含三个类，这三个类分别是 IBookManager, Stub 和 Proxy，这三个类都是静态类型，我们完全可以把他们分开来，三个类定义如下：\n\nIBookManager\n\npublic interface IBookManager extends android.os.IInterface &#123;    public void addBook(net.bingyan.library.Book book) throws android.os.RemoteException;    public java.util.List&lt;net.bingyan.library.Book&gt; getBookList() throws android.os.RemoteException;&#125;\n\n\nStub\n\npublic static abstract class Stub extends android.os.Binder implements net.bingyan.library.IBookManager &#123;        private static final java.lang.String DESCRIPTOR = &quot;net.bingyan.library.IBookManager&quot;;        static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);        static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);        /**         * Construct the stub at attach it to the interface.         */        public Stub() &#123;            this.attachInterface(this, DESCRIPTOR);        &#125;        /**         * Cast an IBinder object into an net.bingyan.library.IBookManager interface,         * generating a proxy if needed.         */        public static net.bingyan.library.IBookManager asInterface(android.os.IBinder obj) &#123;            if ((obj == null)) &#123;                return null;            &#125;            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);            if (((iin != null) &amp;&amp; (iin instanceof net.bingyan.library.IBookManager))) &#123;                return ((net.bingyan.library.IBookManager) iin);            &#125;            return new net.bingyan.library.IBookManager.Stub.Proxy(obj);        &#125;        @Override        public android.os.IBinder asBinder() &#123;            return this;        &#125;        @Override        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123;            switch (code) &#123;                case INTERFACE_TRANSACTION: &#123;                    reply.writeString(DESCRIPTOR);                    return true;                &#125;                case TRANSACTION_addBook: &#123;                    data.enforceInterface(DESCRIPTOR);                    net.bingyan.library.Book _arg0;                    if ((0 != data.readInt())) &#123;                        _arg0 = net.bingyan.library.Book.CREATOR.createFromParcel(data);                    &#125; else &#123;                        _arg0 = null;                    &#125;                    this.addBook(_arg0);                    reply.writeNoException();                    return true;                &#125;                case TRANSACTION_getBookList: &#123;                    data.enforceInterface(DESCRIPTOR);                    java.util.List&lt;net.bingyan.library.Book&gt; _result = this.getBookList();                    reply.writeNoException();                    reply.writeTypedList(_result);                    return true;                &#125;            &#125;            return super.onTransact(code, data, reply, flags);        &#125;&#125;\n\n\nProxy\n\nprivate static class Proxy implements net.bingyan.library.IBookManager &#123;            private android.os.IBinder mRemote;            Proxy(android.os.IBinder remote) &#123;                mRemote = remote;            &#125;            @Override            public android.os.IBinder asBinder() &#123;                return mRemote;            &#125;            public java.lang.String getInterfaceDescriptor() &#123;                return DESCRIPTOR;            &#125;            /**             * Demonstrates some basic types that you can use as parameters             * and return values in AIDL.             */            @Override            public void addBook(net.bingyan.library.Book book) throws android.os.RemoteException &#123;                android.os.Parcel _data = android.os.Parcel.obtain();                android.os.Parcel _reply = android.os.Parcel.obtain();                try &#123;                    _data.writeInterfaceToken(DESCRIPTOR);                    if ((book != null)) &#123;                        _data.writeInt(1);                        book.writeToParcel(_data, 0);                    &#125; else &#123;                        _data.writeInt(0);                    &#125;                    mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);                    _reply.readException();                &#125; finally &#123;                    _reply.recycle();                    _data.recycle();                &#125;            &#125;            @Override            public java.util.List&lt;net.bingyan.library.Book&gt; getBookList() throws android.os.RemoteException &#123;                android.os.Parcel _data = android.os.Parcel.obtain();                android.os.Parcel _reply = android.os.Parcel.obtain();                java.util.List&lt;net.bingyan.library.Book&gt; _result;                try &#123;                    _data.writeInterfaceToken(DESCRIPTOR);                    mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0);                    _reply.readException();                    _result = _reply.createTypedArrayList(net.bingyan.library.Book.CREATOR);                &#125; finally &#123;                    _reply.recycle();                    _data.recycle();                &#125;                return _result;            &#125;       &#125;\n\n对生成的这三个类的说明如下：\n\nIBookManager 这个类是我们定义的接口，android studio 给它添加了一个父类，让它继承自 android.os.interface 这个接口，这个接口只有一个方法 IBinder asBinder()，这样 IBookManager 中就有三个待实现的方法了，它是服务端进程和客户端进程通信的窗口。\nStub 是个抽象类，这个类继承自 android.os.Binder，并且实现了 IBookManager 这个接口。在 Stub 中，已经实现了 asBinder() 这个接口方法，还有两个是我们定义的 AIDL 接口方法留给继承它的子类去实现。它用在服务端，因此服务端需要实现这两个方法。\nProxy 顾名思义是一个代理类，它在客户端使用，是服务端在客户端的一个代理，它也实现了 IBookManager 接口，并且实现了 IBookManager 中的所有方法。\n\n现在我们对这三个类逐个分析：\n\nIBookManager 这个类没什么好说的，它只是简单继承了 IInterface 这个接口，这个接口的作用就是将 IBookManager 转换成 IBinder。\n\nProxy 这个类上面已经提到过了，它就是进程间通信机制的一个封装类，通过构造方法我们也容易看出来，其内部实现机制就是 Binder。它的构造方法接受一个 IBinder 类型的参数，参数名为 remote，显然，它代表着服务端。我们看看这个类中的方法 addBook() 和 getBookList()：\n\n\n@Overridepublic void addBook(net.bingyan.library.Book book) throws android.os.RemoteException &#123;      android.os.Parcel _data = android.os.Parcel.obtain();      android.os.Parcel _reply = android.os.Parcel.obtain();      try &#123;            _data.writeInterfaceToken(DESCRIPTOR)            if ((book != null)) &#123;                _data.writeInt(1);                book.writeToParcel(_data, 0);            &#125; else &#123;                _data.writeInt(0);            &#125;            mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);            _reply.readException();       &#125; finally &#123;            _reply.recycle();            _data.recycle();       &#125;&#125;\n@Overridepublic java.util.List&lt;net.bingyan.library.Book&gt; getBookList() throws android.os.RemoteException &#123;       android.os.Parcel _data = android.os.Parcel.obtain();       android.os.Parcel _reply = android.os.Parcel.obtain();       java.util.List&lt;net.bingyan.library.Book&gt; _result;       try &#123;             _data.writeInterfaceToken(DESCRIPTOR);             mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0);             _reply.readException();             _result = _reply.createTypedArrayList(net.bingyan.library.Book.CREATOR);       &#125; finally &#123;            _reply.recycle();            _data.recycle();       &#125;       return _result;&#125;\n\n它们是编译器自动实现的，这两个方法有很多类似之处，可以先在这里透露下：这两个方法就是客户端进程调用服务端进程的窗口。在这两个方法的开始，它们都定义了两个 Parcel（中文译名：包裹）对象。Parcel 这个类我们看上去很眼熟，是的，Book 类中的 writeToParcel() 和 CREATOR 中的 createFromParcel() 的参数就是 Parcel 类型的，关于这个类文档中解释如下：\n\nContainer for a message (data and object references) that can  be sent through an IBinder.  A Parcel can contain both flattened data  that will be unflattened on the other side of the IPC (using the various  methods here for writing specific types, or the general  {@link Parcelable} interface), and references to live {@link IBinder}  objects that will result in the other side receiving a proxy IBinder  connected with the original IBinder in the Parcel.\n\n翻译一下：Parcel 是一个可以通过 IBinder 进行消息传递的一个容器。一个 Parcel 可以包含可序列化的数据，这些数据会在 IPC 的另一端被反序列化；它也可以包含指向 IBinder 对象的引用，这会使得另一端接收到一个 IBinder 类型的代理对象，这个代理对象连接着 Parcel 中的原始 IBinder 对象。\n下面用图来直观的说明：\n如图，我们可以很直观的看到服务端以 Parcel 作为数据包裹依靠 Binder 和客户端进行通信。数据包裹就是序列化之后的对象。\n如上所述，这两个方法都定义了两个 Parcel 对象，分别叫做 _data 和 _reply，从客户端的角度来看，_data 就是客户端发送给服务端的数据包裹，_reply 服务端发送给客户端的数据包裹。\n之后便开始用这两个对象来和服务端进行通信了。我们观察到，两个方法中都有这么个方法调用 mRemote.transact()。它有四个参数，第一个参数的意义我们后面再讲，第二个参数 _data 负责向服务端发送数据包裹比如接口方法的参数，第三个参数 _reply 负责从服务端接收数据包裹比如接口方法的返回值。这行代码只有一句简单的方法调用，但是却是 AIDL 通信的最核心部分，它其实进行了一次远程方法调用（客户端通过本地代理 Proxy 暴露的接口方法调用服务端 Stub 同名方法），所以能想到它是一个耗时操作。\n在我们的例子中：\n\nvoid addBook(Book book) 需要借助 _data 向服务端发送参数 Book:book，发送的方式就是把 Book 通过其实现的 writeToParcel(Parcel out) 方法打包至 _data 中，正如你能想到的，_data 其实就是参数 out，还记得 Book 中的这个方法的实现吗？ 我们是将 Book 的字段一个个打包至 Parcel 中的。\n\nList&lt;Book&gt; getBookList() 需要借助 _reply 从服务端接收返回值 List&lt;Book&gt;:books，方法中的做法是将 Book 中的 CREATOR 这个静态字段作为参数传入 _reply 的 createTypedArrayList() 方法中，还记得 Book 中的 CREATOR 吗？当时你是不是好奇这个静态字段应该怎么用呢？现在一切明了了，我们需要靠这个对象（便于理解我们可以叫它”反序列化器“）对来自服务端的数据反序列化为对象或者对象数组。很明显 CREATOR 借助 _reply 反序列化生成了 List&lt;Book&gt;:books。\n\n\n当然这两个方法中的 _data 和 _reply 不仅传递了对象，还传递了一些校验信息，这个我们可以不去深究，但应注意的是，Parcel 打包顺序和解包顺序要严格对应。例如，第一个打包的是 int:i，那么第一解包的也应该是这个整型值。也即打包时第一次调用的如果是 Parcel.writeInt(int)，解包时第一次调用的应该是 Parcel.readInt()。\n到此，客户端的 Proxy 讲解完了，下面我们看看服务端的 Stub。\n\nStub 中实现了 IBookManager 的其中一个方法 asBinder()，它的实现很简单，就是把 Stub 自身返回。因为 Stub 本身就继承自 Binder，而 Binder 继承自 IBinder，所以没有任何问题。你会问：还有两个方法没实现呢？这两个方法就是我们定义的接口方法，它们留给服务端进程去实现，也就是说，到时候我们在服务端进程中需要定义一个 Stub 的实现者。下面对 Stub 中的两个重要方法进行分析：\n\nIBookManager asInterface(IBinder obj)\n\n\n\npublic static net.bingyan.library.IBookManager asInterface(android.os.IBinder obj) &#123;            if ((obj == null)) &#123;                return null;            &#125;            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);            if (((iin != null) &amp;&amp; (iin instanceof net.bingyan.library.IBookManager))) &#123;                return ((net.bingyan.library.IBookManager) iin);            &#125;            return new net.bingyan.library.IBookManager.Stub.Proxy(obj);        &#125;\n这个方法是用来给客户端调用的，作用是将 Binder 转换成 IBookManager 这个接口。通过 Binder 进行通信时，服务端会传给客户端一个 Binder 对象（如果是同一进程就是 Stub，不是同一进程就是 BinderProxy)。客户端问：你给我这个对象有什么用？服务端答曰：贫道我这有个方法 asInterface()，你将 Binder 放入其中便可得到你想要的东西了。那么这个方法到底做了什么，竟有如此神效？我们来分析下。\n方法中有个判断：如果我们的服务端进程和客户端进程是同一进程，那么就直接将 Binder（此时是 Stub）通过类型转换转成 IBookManager；如果不是同一进程，那么就通过代理类 Proxy 将 Binder(其实这个时候是一个 BinderProxy，它是服务端 Binder，也就是 Stub 在客户端的代理) 转换成 IBookManager。为什么这么做，我们知道如果服务端进程和客户端进程不是同一进程，那么它们的内存就不能共享，就不能通过一般的方式进行通信。但是我们如果自己去实现进程间通信方式，对于普通开发者来说成本太大，因此编译器帮我们生成了一个封装了了进程间通信的工具，也就是这个 Proxy，这个类对底层的进程通信机制进行了封装只暴露出通信接口 IBookManager。总之，不管是同一进程还是不同进程，通过这个方法 Binder 对象最终都转化成了 IBookManager 这个通信接口。客户端只需调用这个接口中定义的两个方法便可实现和服务端的通信而不需要了解其中的细节(是进程内通信还是进程间通信)。具体的使用场景我们会在后面的实例中进行讲解。\n\nonTransact(int code, Parcel data, Parcel reply, int flags)\n\n@Overridepublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123;           switch (code) &#123;               case INTERFACE_TRANSACTION: &#123;                    reply.writeString(DESCRIPTOR);                    return true;               &#125;               case TRANSACTION_addBook: &#123;                    data.enforceInterface(DESCRIPTOR);                    net.bingyan.library.Book _arg0;                    if ((0 != data.readInt())) &#123;                        _arg0 = net.bingyan.library.Book.CREATOR.createFromParcel(data);                    &#125; else &#123;                        _arg0 = null;                    &#125;                    this.addBook(_arg0);                    reply.writeNoException();                    return true;               &#125;               case TRANSACTION_getBookList: &#123;                    data.enforceInterface(DESCRIPTOR);                    java.util.List&lt;net.bingyan.library.Book&gt; _result = this.getBookList();                    reply.writeNoException();                    reply.writeTypedList(_result);                    return true;                &#125;           &#125;           return super.onTransact(code, data, reply, flags);&#125;\n这个方法我们是不是也很熟悉呢？我们在 Proxy 中有一个类似的方法 transact(int, Parcel, Parcel, int)，它们的参数一样，而且它们都是 Binder 中定义的方法，那么它们有什么联系呢？\n前面说了，transact() 执行了一个远程调用，如果说 transact() 是远程调用的发起，那么 onTransact() 就是远程调用的响应。真实过程是客户端发起远程方法调用，android 系统底层对这个调用进行响应和处理，之后回调服务端的 onTransact() 方法，从数据包裹中取出方法参数，交给服务端实现的同名方法，最后将返回值打包返回给客户端。\n需要注意的是， onTransact() 是在服务端进程的 Binder 线程池中进行的，这就意味着如果我们的要在 onTransact() 方法中更新 UI，就必须借助 Handler。\n这两个方法的第一个参数的含义是 AIDL 接口方法的标识码，在 Stub 中，定义了两个常量作为这两个方法的标示：\nstatic final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);\n服务端响应客户端的调用时，会根据这个参数进行判断：如果 code == TRANSACTION_addBook，说明客户端调用的是 addBook()；如果 code == TRANSACTION_getBookList，说明客户端调用的是 getBookList()，然后交由相应的服务端方法处理。\n最后用一张图来表示整个通信过程（来自《安卓开发艺术探索》）：\n了解了 AIDL 的原理，接下来我们看看 AIDL 在安卓程序中的应用。\nAIDL 的使用相信大家应该都和清楚 Service 的使用了吧，Service 虽然称作“服务”，并且运行于后台，但是它们默认还是运行在默认进程的主线程中。其实让 Service 运行在默认进程中，有点大材小用了。android 的很多系统服务都运行于单独的进程中，供其他应用调用，比如窗口管理服务。这样做的好处是可以多个应用共享同一个服务，节约了资源，也便于集中管理各个客户端，要注意问题的就是线程安全问题。\n那么接下来我们就用 AIDL 实现一个简单的 CS 架构的图书管理系统。\n首先我们定义服务端：\n\nBookManagerService\n\npublic class BookManagerService extends Service &#123;    private final List&lt;Book&gt; mLibrary = new ArrayList&lt;&gt;();    private IBookManager mBookManager = new IBookManager.Stub() &#123;        @Override        public void addBook(Book book) throws RemoteException &#123;            synchronized (mLibrary) &#123;                mLibrary.add(book);                Log.d(&quot;BookManagerService&quot;, &quot;now our library has &quot; + mLibrary.size() + &quot; books&quot;);            &#125;        &#125;        @Override        public List&lt;Book&gt; getBookList() throws RemoteException &#123;            return mLibrary;        &#125;    &#125;;    @Override    public IBinder onBind(Intent intent) &#123;        return mBookManager.asBinder();    &#125;&#125;\n&lt;service      android:process=&quot;:remote&quot;      android:name=&quot;.BookManagerService&quot;/&gt;\n服务端我们定义了 BookManagerService 这个类，在它里面我们创建了服务端的 Stub 对象，并且实现了需要实现的两个 AIDL 接口方法来定义服务端的图书管理策略。在 onBind() 方法中我们将 IBookManager 对象作为 IBinder 返回。我们知道，当我们绑定一个服务时，系统会调用 onBinder() 方法得到服务端的 IBinder 对象，并将其转换成客户端的 IBinder 对象传给客户端。对于进程间通信来说，虽然服务端的 IBinder 和 客户端的 IBinder 是两个 IBinder 对象，但他们在底层都是同一个对象。在 xml 中注册 Service 时我们给它指定了进程名，这样 Service 就能运行在单独的进程中了。\n接下来看看客户端的实现：\n\nClient\n\npublic class Client extends AppCompatActivity &#123;    private TextView textView;    private IBookManager bookManager;    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.library_book_manager_system_client);        Intent i  = new Intent(Client.this, BookManagerService.class);        bindService(i, conn, BIND_AUTO_CREATE);        Button addABook = (Button) findViewById(R.id.button);        addABook.setOnClickListener(v -&gt; &#123;            if (bookManager == null) return;            try &#123;                bookManager.addBook(new Book(0, &quot;book&quot;));                textView.setText(getString(R.string.book_management_system_book_count, String.valueOf(bookManager.getBookList().size())));            &#125; catch (RemoteException e) &#123;                e.printStackTrace();            &#125;        &#125;);        textView = (TextView) findViewById(R.id.textView);    &#125;    private ServiceConnection conn = new ServiceConnection() &#123;        @Override        public void onServiceConnected(ComponentName name, IBinder service) &#123;            Log.d(&quot;Client --&gt;&quot;, service.toString());            bookManager = IBookManager.Stub.asInterface(service);        &#125;        @Override        public void onServiceDisconnected(ComponentName name) &#123;            Log.d(&quot;Client&quot;, name.toString());        &#125;    &#125;;&#125;\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:weightSum=&quot;1&quot;    android:gravity=&quot;center&quot;&gt;    &lt;Button        android:text=&quot;add a book&quot;        android:layout_width=&quot;111dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:id=&quot;@+id/button&quot; /&gt;    &lt;TextView        android:layout_marginTop=&quot;10dp&quot;        android:text=&quot;@string/book_management_system_book_count&quot;        android:layout_width=&quot;231dp&quot;        android:gravity=&quot;center&quot;        android:layout_height=&quot;wrap_content&quot;        android:id=&quot;@+id/textView&quot; /&gt;&lt;/LinearLayout&gt;\n\n我们的客户端就是一个 Activity，onCreate() 中进行了服务的绑定，bindService() 方法中有一参数 ServiceConnection:conn，因为绑定服务是异步进行的，这个参数的作用就是绑定服务成功后回调的接口，它有两个方法：一个是连接服务成功后回调，另一个在与服务端断开连接后回调。我们现在关心的主要是 onServiceConnected() 方法，在这里我们只做了一件事：将服务端转换过来的 IBinder 对象转换成 AIDL 接口，我们定义 IBookManager:bookManager 字段来保持对其的引用。这样的话，我们就可以通过这个 bookManager 来进行方法的远程调用。我们给客户端的 Button 注册事件：每一次点击都会向服务端增加一本书，并将图书馆现有的图书数量显示出来。\n现在我们看看程序的运行效果：\n  \n\n每当我们点击按钮，我们就成功的向服务端添加了一本书，说明我们通过 AIDL 跨进程通信成功了。\n参考书籍《安卓开发艺术探索》 任玉刚 著\n","tags":["Android","IPC"]},{"title":"安卓动态加载入门","url":"/2016/11/11/2016-11-11-android-load-class-dynamically/","content":"安卓动态加载入门这几周为了理解安卓动态加载技术算是花了不少时间，遇到很多坑，当然也学到了不少。一开始是学习 java 虚拟机，了解类文件格式，然后又在各种博客网站上看 dalvik 虚拟机和 dex 文件格式，了解安卓的类加载机制，到后来又去了解 art 虚拟机和 oat 文件格式。虽然有些地方没搞太清楚，学习的不够深入，但总算把动态加载的大概原理弄清了，也算是为之后更深入学习安卓动态加载以及热修复、热更新等技术打下基础吧。\n\n\n什么是动态加载技术这个在网上没有看到严格的定义，不过就我个人的理解，动态加载代码就是通过在运行时加载外部代码（磁盘，网络等）改变程序行为的技术。关于安卓动态加载技术的文章网上有很多，但很多都是基于较低安卓版本的，对于较高版本有些地方不一定适用。我这里准备基于 andriod M 来和大家分享一下安卓的动态加载技术，让大家对这项技术有一个初步的了解。\n动态加载技术详解不管是 java 应用还是安卓应用，动态加载技术的核心都是类加载机制，所以我们有必要先了解下安卓的类加载机制，而安卓的类加载机制沿袭了普通的 java 应用的类加载机制，因此我们先看看 java 虚拟机（JVM）是怎么加载类的。\nJVM 类加载机制JVM 的类加载机制是双亲委派模型，但是这个“双亲”感觉有点误导，因此我更喜欢叫它委派式模型。这里不对 JVM 委派式的类加载机制做过多分析，贴上一张图供大家去理解：\n\n结合这张图说明几点：\n\nBootStrapClassLoader 是顶级的类加载器，它是唯一一个不继承自 ClassLoader 的类加载器，它高度集成于 JVM，是 ExtensionClassLoader 的父加载器，它的类加载路径是 JDK\\jre\\lib 和 用户指定的虚拟机参数 -Xbootclasspath 的值。\nExtensionClassLoader 是 BootStrapClassLoader 的子加载器，同时是 SystemClassLoader （有的地方称 AppClassLoader）的父加载器，它的类加载路径是 JDK\\jre\\lib\\ext 和系统属性 java.ext.dirs 的值。\nSystemClassLoader 是 ExtensionClassLoader 的子加载器，同时是我们的应用程序的类加载器，我们在应用程序中编写的类一般情况下（如果没有用到动态加载技术的话）都是通过这个类加载加载的。它的类加载路径是环境变量 CLASSPATH 的值或者用户通过命令行可选项 -cp (-classpath) 指定的值。\n类加载器由于父子关系形成树形结构，开发人员可以开发自己的类加载器从而实现动态加载功能，但必须给这个类加载器指定树上的一个节点作为它的父加载器。\n因为类加载器是通过包名和类名（或者说类的全限定名），所以由于委派式加载机制的存在，全限定名相同的类不会在有 祖先—子孙 关系的类加载器上分别加载一次，不管这两个类的实现是否一样。\n不同的类加载器加载的类一定是不同的类，即使它们的全限定名一样。如果全限定名一样，那么根据上一条，这两个类加载器一定没有 祖先-子孙 的关系。这样来看，可以通过自定义类加载器使得相同全限定名但实现不同的类存在于同一 JVM 中，也就是说，类加载器相当于给类在包名之上又加了个命名空间。\n如果两个相同全限定名的类由两个非 祖先-子孙 关系的类加载器加载，这两个类之间通过 instanceof 和 equals() 等进行比较时总是返回 false。\n\n我们知道，安卓应用和普通的 java 应用不同，它们运行于 Dalvik 虚拟机。JVM 是基于栈的虚拟机，而 Dalvik 是基于寄存器的虚拟机。因此，java 虚拟机具有更大的指令集，而 Dalvik 虚拟机的指令更长。除此之外，考虑到 Dalvik 虚拟机运行于移动设备，内存空间和 CPU 执行效率有限，因此采用 dex 作为储存类字节码信息的文件。当 java 程序编译成 class 后，编译器会使用 dx 工具将所有的class 文件整合到一个 dex 文件，目的是使其中各个类能够共享数据，在一定程度上降低了冗余，同时也是文件结构更加紧凑。虽然这两种虚拟机有诸多不同，但是 Dalvik 继承了 JVM 的委派式的类加载机制，因此上面的部分（主要是后面四条）结论对于安卓来说也是同样适用的。\n因为安卓的类加载机制也是委派式的，所以如果你知道 JVM 的类加载机制，那么通过类比学习安卓的类加载机制就很容易了。本来准备放张图来对比说明安卓的类加载模型的，但是想想我们还是有必要先了解安卓中两个重要的类加载器以及内部的细节：DexClassLoader 和 PathClassLoader。\nDexClassLoader &amp; PathClassLoader先看看这两个类加载器的定义（点击超链接可查看注释）：\n\nDexCloassLoader\n\npackage dalvik.system;import java.io.File;public class DexClassLoader extends BaseDexClassLoader &#123;       public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) &#123;        super(dexPath, new File(optimizedDirectory), libraryPath, parent);    &#125;&#125;\n\n\nPathClassLoader\n\npackage dalvik.system;public class PathClassLoader extends BaseDexClassLoader &#123;       public PathClassLoader(String dexPath, ClassLoader parent) &#123;        super(dexPath, null, null, parent);    &#125;    public PathClassLoader(String dexPath, String libraryPath, ClassLoader parent) &#123;        super(dexPath, null, libraryPath, parent);    &#125;&#125;\n\n可以看到，这两个类加载器都是继承自 BaseDexClassLoader，只是分别实现了自己的构造方法。那么我们自然对这个 BaseDexClassLoader 很感兴趣，看看它的构造方法：\npublic BaseDexClassLoader(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123;        super(parent);        this.pathList = new DexPathList(this, dexPath, librarySearchPath, optimizedDirectory);&#125;\n\n说下这个构造方法的几个参数：\n\n第一个参数指的是我们要加载的 dex 文件的路径，它有可能是多个 dex 路径，取决于我们要加载的 dex 文件的个数，多个路径之间用 : 隔开。\n第二个参数指的是优化后的 dex 存放目录。实际上，dex 其实还并不能被虚拟机直接加载，它需要系统的优化工具优化后才能真正被利用。优化之后的 dex 文件我们把它叫做 odex （optimized dex，说明这是被优化后的 dex）文件。其实从 class 到 dex 也算是经历了一次优化，这种优化的是机器无关的优化，也就是说不管将来运行在什么机器上，这种优化都是遵循固定模式的，因此这种优化发生在 apk 编译。而从 dex 文件到 odex 文件，是机器相关的优化，它使得 odex 适配于特定的硬件环境，不同机器这一步的优化可能有所不同，所以这一步需要在应用安装等运行时期由机器来完成。需要注意的是，在较早版本的系统中，这个目录可以指定为外部存储中的目录，较新版本的系统为了安全只允许其为应用程序私有存储空间（/data/data/apk-package-name/）下的目录，一般我们可以通过 Context#getDir(String dirName) 得到这个目录。\n第三个参数的意义是库文件的的搜索路径，一般来说是 .so 库文件的路径，也可以指明多个路径。\n第四个参数就是要传入的父加载器，一般情况我们可以通过 Context#getClassLoader() 得到应用程序的类加载器然后把它传进去。\n\n这个构造函数的意义很简单，它做了两件事：连接了父加载器；构造了一个 DexPathList 实例保存在 pathList 中。这个 pathList 现在我们还不知道它是何方神圣，但是我们通过类名隐约的感觉到它保存了 Dalvik 虚拟机要加载的 dex 文件的路径，实际情况如何呢？我们看看这个类：\npublic DexPathList(ClassLoader definingContext, String dexPath,            String librarySearchPath, File optimizedDirectory) &#123;        if (definingContext == null) &#123;            throw new NullPointerException(&quot;definingContext == null&quot;);        &#125;        if (dexPath == null) &#123;            throw new NullPointerException(&quot;dexPath == null&quot;);       &#125;       if (optimizedDirectory != null) &#123;           if (!optimizedDirectory.exists())  &#123;               throw new IllegalArgumentException(                       &quot;optimizedDirectory doesn&#x27;t exist: &quot;                       + optimizedDirectory);           &#125;           if (!(optimizedDirectory.canRead()                           &amp;&amp; optimizedDirectory.canWrite())) &#123;               throw new IllegalArgumentException(                       &quot;optimizedDirectory not readable/writable: &quot;                       + optimizedDirectory);           &#125;       &#125;       this.definingContext = definingContext;       ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;();       // save dexPath for BaseDexClassLoader       this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,                              suppressedExceptions, definingContext);       // Native libraries may exist in both the system and       // application library paths, and we use this search order:       //       //   1. This class loader&#x27;s library path for application libraries (librarySearchPath):       //   1.1. Native library directories       //   1.2. Path to libraries in apk-files       //   2. The VM&#x27;s library path from the system property for system libraries       //      also known as java.library.path       //       // This order was reversed prior to Gingerbread; see http://b/2933456.       this.nativeLibraryDirectories = splitPaths(librarySearchPath, false);       this.systemNativeLibraryDirectories =               splitPaths(System.getProperty(&quot;java.library.path&quot;), true);       List&lt;File&gt; allNativeLibraryDirectories = new ArrayList&lt;&gt;(nativeLibraryDirectories);       allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories);       this.nativeLibraryPathElements = makePathElements(allNativeLibraryDirectories,                                                         suppressedExceptions,                                                         definingContext);       if (suppressedExceptions.size() &gt; 0) &#123;           this.dexElementsSuppressedExceptions =               suppressedExceptions.toArray(new IOException[suppressedExceptions.size()]);       &#125; else &#123;           dexElementsSuppressedExceptions = null;       &#125;&#125;\n\n这个构造方法也很简单，这里我们主要看这几行代码：\nthis.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,                              suppressedExceptions, definingContext);...this.nativeLibraryDirectories = splitPaths(librarySearchPath, false);this.systemNativeLibraryDirectories =                 splitPaths(System.getProperty(&quot;java.library.path&quot;), true);List&lt;File&gt; allNativeLibraryDirectories = new ArrayList&lt;&gt;(nativeLibraryDirectories);allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories);this.nativeLibraryPathElements = makePathElements(allNativeLibraryDirectories,                                          suppressedExceptions,                                          definingContext);\n\n这几行代码做的事也很清晰明了，就是给两个字段赋值。一个是 dexElements，另一个是 nativeLibraryPathElements。我们来看看这两个字段是怎么得到的：\n\ndexElements 是通过 makeDexElements() 方法得到的，我们主要关注这个方法的前两个参数。第二个参数前面已经说了，是 dex 文件优化后的存放目录。第一个参数是通过 splitDexPath() 得到的，这个方法方法最终会调用 splitPaths()，所以我们看看 splitPaths() 是怎样的：\n\nprivate static List&lt;File&gt; splitPaths(String searchPath, boolean directoriesOnly) &#123;       List&lt;File&gt; result = new ArrayList&lt;&gt;();       if (searchPath != null) &#123;           for (String path : searchPath.split(File.pathSeparator)) &#123;               if (directoriesOnly) &#123;                   try &#123;                       StructStat sb = Libcore.os.stat(path);                       if (!S_ISDIR(sb.st_mode)) &#123;                           continue;                       &#125;                   &#125; catch (ErrnoException ignored) &#123;                       continue;                   &#125;               &#125;               result.add(new File(path));           &#125;       &#125;       return result;&#125;\n\n这个方法做的事正如其名字所表达的，就是把用 : 分隔的路径分割后保存为 File 类型的列表返回。现在看看 makeDexElements() 这个方法：\nprivate static Element[] makeDexElements(List&lt;File&gt; files, File optimizedDirectory,                                            List&lt;IOException&gt; suppressedExceptions,                                            ClassLoader loader) &#123;     return makeElements(files, optimizedDirectory, suppressedExceptions, false, loader);&#125;\n就是利用已有参数简单调用了 makeElements()，其中，ignoreDexFiles 传入的是 false，makeElements() 的实现： \nprivate static Element[] makeElements(List&lt;File&gt; files, File optimizedDirectory,                                          List&lt;IOException&gt; suppressedExceptions,                                          boolean ignoreDexFiles,                                         ClassLoader loader) &#123;       Element[] elements = new Element[files.size()];       int elementsPos = 0;       /*        * Open all files and load the (direct or contained) dex files        * up front.        */       for (File file : files) &#123;           File zip = null;           File dir = new File(&quot;&quot;);           DexFile dex = null;           String path = file.getPath();           String name = file.getName();           if (path.contains(zipSeparator)) &#123;               String split[] = path.split(zipSeparator, 2);               zip = new File(split[0]);               dir = new File(split[1]);           &#125; else if (file.isDirectory()) &#123;               // We support directories for looking up resources and native libraries.               // Looking up resources in directories is useful for running libcore tests.               elements[elementsPos++] = new Element(file, true, null, null);           &#125; else if (file.isFile()) &#123;               if (!ignoreDexFiles &amp;&amp; name.endsWith(DEX_SUFFIX)) &#123;                   // Raw dex file (not inside a zip/jar).                   try &#123;                       dex = loadDexFile(file, optimizedDirectory, loader, elements);                   &#125; catch (IOException suppressed) &#123;                       System.logE(&quot;Unable to load dex file: &quot; + file, suppressed);                       suppressedExceptions.add(suppressed);                   &#125;               &#125; else &#123;                   zip = file;                   if (!ignoreDexFiles) &#123;                       try &#123;                           dex = loadDexFile(file, optimizedDirectory, loader, elements);                       &#125; catch (IOException suppressed) &#123;                           /*                            * IOException might get thrown &quot;legitimately&quot; by the DexFile constructor if                            * the zip file turns out to be resource-only (that is, no classes.dex file                            * in it).                            * Let dex == null and hang on to the exception to add to the tea-leaves for                            * when findClass returns null.                            */                           suppressedExceptions.add(suppressed);                       &#125;                   &#125;               &#125;           &#125; else &#123;               System.logW(&quot;ClassLoader referenced unknown path: &quot; + file);           &#125;           if ((zip != null) || (dex != null)) &#123;               elements[elementsPos++] = new Element(dir, false, zip, dex);           &#125;        &#125;       if (elementsPos != elements.length) &#123;           elements = Arrays.copyOf(elements, elementsPos);       &#125;       return elements;&#125;\n\n这个方法的名字也很好的说明了它要做的事，就是装配 Element 数组。装配 Element 数组的工作主要在 for 循环中，除了异常情况，它的每一次循环都构造了一个 Element。Element 是什么东西？你可以大概的把它理解为一个实体类。忽略异常情况，我们现在来分析这些 Element 是如何构造的，首先循环的开始部分定义了构造 Element 要用到的参数，然后对传入的每个 File 判断其类型：\n\n第一个判断我也没看太懂，不知道为什么这么做，好在这不是重点，我们往后看。\n\n第二个判断是，如果文件是一个目录，那么直接把这个目录传入 Element 的构造方法构造一个 Element；如果不是就进行下一个判断。\n\n第三个判断中又有两个判断：\n\n根据后缀看它是不是 dex 文件，如果是，那么就通过 loadDexFile() 来加载一个 DexFile 对象（这个 DexFile 是什么我们等下再讲，你可以把它理解为一个对应着一个 dex 文件的对象）。如果成功加载了，那么就把它传入 Element 构造方法构造一个 Element。\n如果不是 dex 文件，那么不管它什么后缀名，都把它看作是一个 zip，前提是它必须是一个 zip 格式的文件（如 zip，jar，apk），并且这个 zip 格式的文件必须要包含一个 dex 文件，同时这个文件须位于 zip 内部的根目录下。然后又会利用这个 zip 文件加载一个 DexFile 对象。最后将这个 zip 和连同加载出来的 DexFile 对象一起传入 Element 的构造方法构造一个 Element 对象。\n\n\n\nElement 数组的构造我们大概理解清楚了。现在看下 loadDexFile() 怎样加载 DexFile 的：\nprivate static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader,                                      Element[] elements) throws IOException &#123;       if (optimizedDirectory == null) &#123;           return new DexFile(file, loader, elements);       &#125; else &#123;           String optimizedPath = optimizedPathFor(file, optimizedDirectory);           return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements);       &#125;&#125;\n\n先说明下，无论是 DexFile(File file, Classloader loader, Elements[] elements) 还是DexFile.loadDex() 最终都会调用 DexFile(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements) 这个构造方法。所以 loadDexFile() 这个方法的逻辑就是：如果 optimizedDirectory 为 null，那么就直接利用 dex 文件对应的 file 构造一个 DexFile；否则就根据要加载的 dex（或者包含了 dex 的 zip） 的文件名和优化后的 dex 存放的目录组合成优化后的 dex（也就是 odex）文件的输出路径，然后利用原始路径和优化后的输出路径构造出一个 DexFile。关于 DexFile 内部的细节到时候分析类加载过程的时候会讲，这里就不细说了。\n通过前面的分析我们知道，我们可以知道 dexElements 主要作用就是用来保存和 dex 文件对应的 DexFile 对象的。 \n\nnativeLibraryPathElements 产生的方法和 pathList 差不多，它保存的主要是本地方法库（本地方法库的存在形式一般是 .so 文件）对应的对象，包括应用程序的本地方法库和系统的本地方法库。这里就不对它过多讲解了。\n\n分析完这两字段，现在我们回过头来看看 DexPathList 这个对象，这个对象持有 dexElements 和 nativeLibraryPathElements 这两个属性，也就是说它保存了 dex 和 本地方法库。而 dex 保存着类的字节码信息，这样的话如果我们的类加载器要加载某个类的话，是不是只要操作这个对象就可以了呢？事实上的确如此，我们看看 DexPathList 的文档说明：\n\nA pair of lists of entries, associated with a {@code ClassLoader}.One of the lists is a dex&#x2F;resource path &mdash; typically referredto as a “class path” &mdash; list, and the other names directoriescontaining native code libraries. Class path entries may be any of:a {@code .jar} or {@code .zip} file containing an optionaltop-level {@code classes.dex} file as well as arbitrary resources,or a plain {@code .dex} file (with no possibility of associatedresources).This class also contains methods to use these lists to look upclasses and resources.\n\n大概的意思就是 DexPathList 的作用和 JVM 中的 classpath 的作用类似，JVM 根据 classpath 来查找类，而 Dalvik 利用 DexPathList 来查找并加载类。DexPathList 包含的路径可以是 .dex 文件的路径，也可以是包含了 dex 的 .jar 和 .zip 文件的路径。\n对于类加载器的分析先到这里，现在我们看看 BaseDexClassLoader 是如何加载类的。\nBaseClassLoader 加载类的过程我们知道，一个类加载器的入口方法是 loadClass()：\nprotected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123;        Class&lt;?&gt; clazz = findLoadedClass(className);        if (clazz == null) &#123;            ClassNotFoundException suppressed = null;            try &#123;                clazz = parent.loadClass(className, false);            &#125; catch (ClassNotFoundException e) &#123;                suppressed = e;            &#125;            if (clazz == null) &#123;                try &#123;                    clazz = findClass(className);                &#125; catch (ClassNotFoundException e) &#123;                    e.addSuppressed(suppressed);                    throw e;                &#125;            &#125;        &#125;        return clazz;    &#125;\n这个方法封装了委派式加载机制，所以一般不重写。CLassLoader 的子类通常重写 findClass() 来定义自己的类加载策略。BaseDexClassLoader 也继承自 ClassLoader，因此我们就从 findClass() 方法来分析下 BaseClassLoader 加载类的过程。\n@Overrideprotected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;       List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;();       Class c = pathList.findClass(name, suppressedExceptions);       if (c == null) &#123;           ClassNotFoundException cnfe = new ClassNotFoundException(&quot;Didn&#x27;t find class \\&quot;&quot; + name + &quot;\\&quot; on path: &quot; + pathList);           for (Throwable t : suppressedExceptions) &#123;               cnfe.addSuppressed(t);           &#125;           throw cnfe;       &#125;       return c;&#125;\n\n这个方法的重点就是 Class c = pathList.findClass(name, suppressedException)，pathList 很熟悉对不对？它就是前面分析的 BaseDexClassLoader 中的 DexPathList 对象。这里 BaseClassLoader 把查找类的任务委托给了 pathList。\n我们看看 DexPathList 的 findClass() 对象做了哪些事：\npublic Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123;       for (Element element : dexElements) &#123;           DexFile dex = element.dexFile;           if (dex != null) &#123;               Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);               if (clazz != null) &#123;                   return clazz;               &#125;           &#125;       &#125;       if (dexElementsSuppressedExceptions != null) &#123;           suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));       &#125;       return null;&#125;\n\n方法的逻辑很清晰，它遍历了 dexElements 中的所有 DexFile，通过 DexFile 的 loadClassBinaryName() 方法加载目标类。可见，dexElements 又把查找类的任务委托给了 DexFile，看来 DexFile 这个对象的地位最低，大佬们都假装把活干完了，暗地里却把活丢给了它。前面说了，DexFile 对应着一个 dex 文件(或者包含 dex 文件的 zip 格式文件)，那么我们看看他是怎样在对应的 dex 文件中查找类的。\n首先分析它的构造方法：\nprivate DexFile(String sourceName, String outputName, int flags, ClassLoader loader,           DexPathList.Element[] elements) throws IOException &#123;       if (outputName != null) &#123;           try &#123;               String parent = new File(outputName).getParent();               if (Libcore.os.getuid() != Libcore.os.stat(parent).st_uid) &#123;                   throw new IllegalArgumentException(&quot;Optimized data directory &quot; + parent                           + &quot; is not owned by the current user. Shared storage cannot protect&quot;                           + &quot; your application from code injection attacks.&quot;);               &#125;           &#125; catch (ErrnoException ignored) &#123;               // assume we&#x27;ll fail with a more contextual error later           &#125;       &#125;       mCookie = openDexFile(sourceName, outputName, flags, loader, elements);       mFileName = sourceName;       //System.out.println(&quot;DEX FILE cookie is &quot; + mCookie + &quot; sourceName=&quot; + sourceName + &quot; outputName=&quot; + outputName);&#125;\n\n估计你已经找到这个方法的重点了，没错，就是 openDexFile()，它最终会调用 openDexFileNative()，这家伙是个本地方法，我们就不深究了。它做的事就是把对应的 dex 文件加载到内存中，然后返回给 Java 层一个 Object:mCookie 用来标识本次和 Java 层的交互，后续的操作包括从 dex 文件中加载目标类和关闭 DexFile 对象释放资源都用到了这个 mCookie。此外，这个本地方法还做了一件重要的事，那就是优化 dex 并将其输出到指定文件夹。\n在构造方法中 DexFile 就完成了 dex 文件的加载过程。现在我们回到 DexFile 对象的 loadClassBinaryName()：\npublic Class loadClassBinaryName(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed) &#123;       return defineClass(name, loader, mCookie, this, suppressed);&#125;private static Class defineClass(String name, ClassLoader loader, Object cookie,                                    DexFile dexFile, List&lt;Throwable&gt; suppressed) &#123;       Class result = null;       try &#123;           result = defineClassNative(name, loader, cookie, dexFile);       &#125; catch (NoClassDefFoundError e) &#123;           if (suppressed != null) &#123;               suppressed.add(e);           &#125;       &#125; catch (ClassNotFoundException e) &#123;           if (suppressed != null) &#123;               suppressed.add(e);           &#125;       &#125;       return result;&#125;\n\n终于看到了尽头，没错，class 对象在 java 层加载过程的尽头就是这个 defineClass() 方法。这个方法调用本地方法 defineClassNative() 从 dex 中查找目标类，如果找到了，就把这个代表这个类的 Class 对象返回。至此，Dalvik 虚拟机加载类的整个过程就结束了。现在我们回过头看看 DexClassLoader() 和 PathClassLoader()，这两个类加载器的唯一区别就是前者指定了优化后的 dex 文件的输出路径，后者没有指定。也就这一点差异造成了它们不同的使用场景：DexClassLoader 用来加载 .dex 文件以及包含 dex 文件的 .jar、.zip 和未安装的 .apk 文件，因此需要指定优化后的 dex 文件的输出路径；PathClassLoader 一般用来加载已经安装到设备上的 .apk，因为应用在安装的时候已经对 apk 文件中的 dex 进行了优化，并且会输出到 /data/dalvik-cache 目录下（android M 在这目录下找不到，应该是改成了 /data/app/com.example.app-x/oat 目录下），所以它不需要指定优化后 dex 的输出路径。下面用一张图来总结下安卓的类加载机制：\n\n对这个模型作一下说明：\n\nBootClassLoader 是顶级的类加载器，这个类加载器在系统启动时就已经建立了，整个系统只有一个实例，它用来加载安卓核心类库。\n\nPathClassLoader 是每个应用进程的 Dalvik 虚拟机私有的类加载器，在应用启动时创建。它的 DexPathList 的 dex 加载路径是 /data/app/apk-package-name-x/base.apk（android M），用来加载我们已安装应用的 apk 中的 dex 文件。我们在应用中编写的的类默认是委托此类加载。\n\nCustom ClassLoader，这是开发人员自己实现的类加载器，通常是 PathClassLoader 或者 DexClassLoader。如果使用前者通常用来加载已经安装过的插件 apk 中的 dex 文件，如果使用后者通常用来加载 .dex 文件以及包含 dex 的 .jar、.zip 和 未安装的 .apk 文件。\n\n我们可以做如下类比：\n\n把 Dalvik 类比于 JVM\n把 dex 文件 类比于 class 文件\n把 dex 文件的路径（DexPathList） 类比于 类加载路径（classpath） 。\n\n\n\n相信现在大家对安卓的类加载机制有了大概的了解，为了避免文章篇幅过长，我打算把动态加载在安卓中的应用放在下一篇博客当中，感谢大家的阅读。\n","tags":["Android","动态加载"]},{"title":"命令行编译制作一个 Java 程序","url":"/2016/11/05/2016-11-5-compile-java-through-command-line/","content":"命令行编译制作一个 Java 程序和很多同学一样，一开始学 java 都是用 Eclipse、intellij 等 IDE 来写 java 程序的，这些 IDE 极大的简化了开发流程，很多工作都在不知不觉中帮我们做好了。出于好奇，在网上查阅各种资料后，决定自己动手用最原始的方式————命令行，编译并打包一个 hello world。\n\n\n第一步：编写源代码因为是一个 hello world，用记事本来写也没任何问题。首先我们在桌面创建项目文件夹 HelloWorld，在里面新建一个包名为 xyz.lwenkun，然后在该包下编写如下程序：\npackage xyz.lwenkun;import com.lib;//Example.javapublic class Example &#123;   public static void main(String[] args) &#123;      Lib lib = new Lib();      lib.print();   &#125;&#125;\n\n同时在桌面新建一个包 ”com.lib“，在里面编写 Lib.java 作为我们 HelloWorld 要依赖的类： \npackage com.lib//Lib.javapublic class Lib &#123;   public void print() &#123;      System.out.println(&quot;hello world&quot;);   &#125;&#125;\n\n第二步：编译源码准备好后，就开始编译工作了，编译源码需要用到 javac 命令，使用方法是 \njavac &lt;options&gt; &lt;source-files&gt;\n\n因为我们的项目依赖于 Lib 这个类，所以我们首先把这个类编译好：\njavac /Users/lwenkun/desktop/com/lib/Lib.java\n\n然后再编译主类：\njavac -cp /Users/lwenkun/desktop /Users/lwenkun/desktop/HelloWorld/xyz/lwenkun/Example.java\n\n不同于编译 Lib 类，这里我们用到了 -cp 选项。其中 -cp 是 -classpath 的简写，-classpath 后面指定的一般是被引用的类所属类包所在的目录或者所在 jar 包的路径（我们称其为 classpath），编译时或者运行时 JVM 的系统类加载器就要用到 classpath 变量来搜索目标类。注意这个变量指明的是类所属类包所在的目录或者所在 jar 包的路径而不是具体类的路径。比如在编译某个类时要引用另一个类 Lib1，这个类在类包 com.example1 中，而这个类包又在 /Users/lwenkun/desktop/package-dir1 目录下 ，那么我只需指定 classpath 为 /Users/lwenkun/desktop/package-dir1 就可以了。当然在实际情况中一个类引用到的类有很多，如果这些被引用的类(1)在同一个包下(2)或者它们所属类包在同一目录下(3)或者在同一 jar 包内，classpath 自然就为同一个值，那就不需要重复指定了。但是如果它们(1)在不同的包里而且这些类包位于不同的目录下(2)或者在不同的 jar 包内，比如我还要引用一个类 Lib2，它在一个名为 com.example2 的类包下，这个类包又位于 /Users/lwenkun/desktop/package-dir2 目录下，那么就要指定多个 classpath 了，这些 classpath 之间用 : （macOSx、Linux、Unix）或者 ; （Windows）隔开，如：\njavac -cp /Users/lwenkun/desktop/package-dir1:/Users/lwenkun/desktop/package-dir2 ClassToBeCompiled.java\n\n关于 classpath 的更多解释，可以看看这篇文章。要注意的是：如果不指定的话，classpath 的默认值是 .，代表的就是当前的用户目录；如果用户指定了那这个默认值就会被清除。\n在我们的 HelloWorld 项目中，我们用到了位于桌面的 com.lib 包中的 Lib 类，所以我们需要指定的 classpath 当然是 ／Users/lwenkun/desktop 了。\n执行完后这两个编译命令后会分别在各自源文件所在目录生成 java 字节码文件 Example.class 和 Lib.class。源文件现在已经没用了，我们把源文件移除，只留下 Example.class 和 Lib.class。\n实际上编译完之后就可以运行了，运行 java 字节码的命令是\njava &lt;options&gt;  &lt;main-class&gt; [args...]\n\n这里我们运行的命令是：\njava -cp /Users/lwenkun/desktop:/Users/lwenkun/desktop/HelloWorld xyz.lwenkun.Example\n\n发现和编译时格式差不多，-cp 后面指定的是运行时的 classpath, 虚拟机此时会根据这个值查找目标类。要注意的就是最后面的类名是主类的全限定名，比如我们的主类的全限定名就为 xyz.lwenkun.Example。系统查找类会根据类包所在目录结合类的全限定名来定位具体的类。来说下这条命令做了些什么：首先当然是启动 java 虚拟机，然后查找指定的主类，依据什么来查找呢？当然就是前面指定的 classpath，先在第一个目录下找，根据全限定名，类的位置应该是 /Users/lwenkun/desktop/xyz/lwenkun/Example，发现找不到，再用同样的方法在第二个目录中找，这时候类的位置应该是 /Users/lwenkun/desktop/HelloWorld/xyz/lwenkun/Example，发现找到了，那么就加载这个类并执行这个类的 mian() 方法。main() 方法中又用到了 Lib 这个类，它在 Example 中的声明是 com.lib.Lib，类加载器又用类似方法开始查找 Lib 类，发现在第一个目录中找到了该类，那么就把它加载到内存当中。这里省略了很多细节，关于系统查找类的详细说明，可以看看这篇文章。\n命令的运行结果是：\nhello world\n\n第三步：打包打包就是我们的项目打包成 jar 包，jar 包是一种 zip 格式的文件，从结构上来看我们可以简单的理解为 jar 包就是把几个类包压缩在一起。常见的 jar 包有两种：一种作为其他程序的依赖库，没有主类；另一种是作为可执行的程序，有主类，用鼠标点击就可以运行。我们的项目包含主类，因此我们把它打包成可执行的 jar 包。关于 jar 包更深入的分析可以看看这篇文章。jar 文件构大致如下：\n \n 不管是哪种 jar 包，它们都有一个 META-INF 目录，下面有一个 MANIFEST.MF 文件，这个文件是个清单，记录着 jar 包相关的一些属性，常用的如 Main-Class 和 Class-Path，前者指定主类，也就是程序的入口点，后者的作用和命令行中的 -cp 是同样的含义，用来指定引用到的类所属类包所在的目录或者所在的 jar 包路径。如果打包时我们不指明清单文件那么打包工具会生成一个默认的清单添加到 jar 包中：\nManifest-Version: 1.0Created-By: 1.8.0_101 (Oracle Corporation)\n\n默认的清单中没有 Main-Class 和 Class-Path 等属性，如果需要这些属性我们必须自己添加。添加方法是新建一个 MANIFEST.txt 文件(文件名和后缀不重要)，用文本编辑器打开，在里面添加某些属性：\n属性名1: 属性值1属性名2: 属性值2\n\n到时候我们就能通过打包命令把这个文件中的属性追加到默认的清单文件中了。如果有和默认属性名称相同的属性，会将默认属性覆盖掉。\n打包用到的命令是：\njar &#123;ctxui&#125;[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files ...\n\n其中 jar-file 是输出的 jar 包的文件名，manifest-file 是清单文件的名称（如果有的话），files... 是指若干要打包的 Class 文件。\n介绍几种比较简单的打包方式（更多 jar 相关命令）：\n\n使用默认清单文件和几个类包创建一个 jar 文件\n\njar cf class.jar package-root-dirs...\n\n\n使用现有清单文件和几个类包创建一个 jar 文件\n\njar cfm class.jar mainfest-file package-root-dirs...\n\n\n使用现有的清单文件并用 foo 目录下的所有包创建一个 jar 文件\n\njar cvfm classes.jar manifest-file -C foo/ .\n\n其中，package-root-dir 指的是包的根目录，例如，在我们的项目中就是 /Users/lwenkun/desktop/HelloWorld/xyz。foo 就是包所在的目录，在我们的项目中就是 /Users/lwenkun/desktop/HelloWorld。\n我们先将依赖类所在包的打成 lib.jar ：\njar cf lib.jar /Users/lwenkun/desktop/com\n\n然后把生成的 lib.jar 放在 HelloWorld 文件夹的 lib 文件夹中。\n对于主项目，因为我们的项目有主类，所以要声明 Main-Class 属性；又因为我们的项目有要依赖的类，并且我们要依赖的类的类包没有和我们的主项目的类包在同一目录下，所以要声明 Class-Path 属性。因此我们要创建包含如下内容的清单文件 MANIFEST.txt（文件名和后缀不重要，只要是文本类型的）：\nMain-Class: xyz.lwenkun.ExampleClass-Path: lib/lib.jar\n\n这样打包时文件中的这些属性就会追加到默认清单文件中了。根据前面我们对 classpath 的解释，如果我们的项目依赖的类分别处于三个 jar 包和一个类包中，其中 jar 包位于 lib 目录下，名称分别为 lib1.jar、lib2.jar 和 lib3.jar，类包位于桌面（desktop），那么我们的清单内容就应该是这样的：\nMain-Class: xyz.lwenkun.ExampleClass-Path: lib/lib1.jar lib/lib2.jar lib/lib3.jar /Users/lwenkun/desktop\n\nClass-path 前三项指定的是 jar 包的路径（相对），最后一项指定的是类包所在目录（绝对）。\n注意几点：\n\nMANIFEST 清单的格式是 key: value，冒号后面还有一个空格（如上）\n依赖库之间通过空格来分隔\n每行一个属性，但是如果我们依赖的库太多了，可以转行，但是行首要加个空格（如上）\n最后，也是最容易忽视的一点，最后一个属性写完后要连续回车两次作为结束。否则，最后一行属性会被丢弃\n\n现在我们来打包主项目中的类包：\njar cfm helloworld.jar MANIFEST.txt /Users/lwenkun/desktop/HelloWorld/xyz\n\n这样我们就在当前目录下(项目根目录 HelloWorld)生成了一个 helloworld.jar。把类包打包后，类包对于我们来说已经没用了，可以都移除掉。现在我们用命令行运行这个程序：\njava -jar /Users/lwenkun/desktop/HelloWorld/helloworld.jar\n\n输出：\nhello world\n\n这里是通过 jar 包来执行我们的程序，因为 jar 包中指定了 Main-Class，所以 JVM 就能找到相应的主类并执行；同时在 MANIFEST.MF 中我们指定了 Class-Path，把我们依赖的 jar 包的相对路径添加进去了，所以要用到依赖类的时候，JVM 也能根据这个相对路径和依赖类的全限定名定位到依赖类。\n如果我们打包时忘记了添加 Main-Class 这个属性怎么办呢？当然最好的方式是重新打包。当然你说你就不想重新打包，那也行，那么执行方式就是这样的了：\njava -cp /Users/lwenkun/desktop/HelloWorld/helloworld.jar xyz.lwenkun.Example\n\n输出：\nhello world\n\n这里把主项目的 jar 包的路径添加进 classpath，然后在后面指明主类。前面说了 classpath 指明的是类包所在目录，也可以是类所在 jar 包的路径。其实你可能已经明白，类包目录和 jar 包路径其实是同一回事，它们都是类包的容器。\n我们的程序有依赖库(/Users/lwenkun/desktop/HelloWorld/lib/lib.jar)，如果你又忘记添加 Class-Path 属性又该怎么办？可能你已经知道方法了：\njava -cp /Users/lwenkun/desktop/HelloWorld/helloworld.jar:/Users/lwenkun/desktop/HelloWorld/lib/lib.jar xyz.lwenkun.Example\n\n我们把依赖类所在 jar 包的路径添加到 classpath 中，这样的话，虽然 MANIFEST.MF 中没有声明我们程序依赖的 jar 包路径，JVM 照样能够根据 -cp 指定的路径找到我们的依赖类。\n参考资料：\n\nMANIFEST.MF中的格式问题\nJava环境变量Classpath\n命令行执行Java文件\nJAR 文件揭密\n\n","tags":["Java"]},{"title":"安卓应用获取系统服务的过程","url":"/2016/12/05/2016-12-05-how-android-apps-get-system-services/","content":"安卓应用获取系统服务的过程在安卓系统中存在着各种各样的系统服务， 例如 ActivityManagerService, WindowManagerService, ClipboardService 等。这些系统服务大都运行在进程 system_server 中，为每个应用提供服务。而应用程序运行于自己的默认进程当中，因此，想要获取系统服务，必定需要进行进程间的通信。而安卓中的进程间通信大多通过 Binder 机制进行，因此，要想深入理解应用是如何获取的系统服务的，必须先要了解安卓的 Binder 机制。如果对 Binder 机制不太了解的同学可以参考我的这篇博客。\n\n安卓中的系统服务作用各不相同，所以，如果对每个服务的内部细节做过多的探讨，不利于我们从宏观的角度去理解安卓的系统服务的大致原理。如果你想知道各个服务的具体实现，那么这篇文章并不适合你。\nContext#getSystemService大家对这方法应该很熟悉了，开发应用的时候我们就是通过这个接口获取系统服务的。系统设计人员总是想为应用开发者提供各种便利，减轻他们的负担。以至于对于开发者来说，系统服务的获取简单得用一行代码就能搞定。那么，我们看看系统到底是如何简化服务的获取过程的。首先从这个方法入手：\n@Overridepublic Object getSystemService(String name) &#123;    return SystemServiceRegistry.getSystemService(this, name);&#125;\n\n它的实现也是如此简单，以至于我们必须转入 SystemServiceRegistry 一探究竟。\nSystemServiceRegistry源码太多，我就不贴出来了，大家点击这里自己看看。\n这个类逻辑很简洁，它最引人注目的地方就是开头的那一大坨静态初始化代码块。这块代码异常整齐，清一色的 registerService()：\n......registerService(Context.WIFI_SERVICE, WifiManager.class,                new CachedServiceFetcher&lt;WifiManager&gt;() &#123;    @Override    public WifiManager createService (ContextImpl ctx)&#123;        IBinder b = ServiceManager.getService(Context.WIFI_SERVICE);        IWifiManager service = IWifiManager.Stub.asInterface(b);        return new WifiManager(ctx.getOuterContext(), service,                ConnectivityThread.getInstanceLooper());    &#125;&#125;);registerService(Context.WIFI_P2P_SERVICE, WifiP2pManager.class,                new StaticServiceFetcher&lt;WifiP2pManager&gt;() &#123;    @Override    public WifiP2pManager createService () &#123;        IBinder b = ServiceManager.getService(Context.WIFI_P2P_SERVICE);        IWifiP2pManager service = IWifiP2pManager.Stub.asInterface(b);        return new WifiP2pManager(service);    &#125;&#125;);......\n\n我们似乎明白，这里注册了一系列的系统服务。而且因为是写在静态代码块中，所以在类加载的时候这些服务就注册了。但是，为什么要对这些系统服务进行注册呢？且看 registerService() 这个方法：\n/** * Statically registers a system service with the context. * This method must be called during static initialization only. */private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass,                                       ServiceFetcher&lt;T&gt; serviceFetcher) &#123;        SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);        SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);&#125;\n\n又一个陌生的类 ServiceFetcher 出现了：\nstatic abstract interface ServiceFetcher&lt;T&gt; &#123;       T getService(ContextImpl ctx); &#125;\n\n这个接口定义了 getService() 这个方法，从名字也能看出，它是用来获取服务的。因此我们有理由推断，这个接口就相当于一个服务获取策略。获取服务时，通过调用这个接口的 getService() 方法就能得到相应的服务。因此，registerService() 这个方法并没有将真正的服务注册进去，而是注册了一个服务获取策略。因为各种服务的获取策略不尽相同，系统定义了三种实现 ServiceFetcher 接口的抽象类，它们分别是 CachedServiceFetcher，StaticServiceFetcher 和 StaticApplicationContextServiceFetcher，简单说明一下这三个类：\n\nCachedServiceFetcher\n\nCachedServiceFetcher 获取服务的策略是：先从缓存数组中找，如果找到就将其返回；如果没有，那就创建一个服务，缓存之后再将其返回。\nstatic abstract class CachedServiceFetcher&lt;T&gt; implements ServiceFetcher&lt;T&gt; &#123;    private final int mCacheIndex;    public CachedServiceFetcher() &#123;        mCacheIndex = sServiceCacheSize++;    &#125;    @Override    @SuppressWarnings(&quot;unchecked&quot;)    public final T getService(ContextImpl ctx) &#123;        final Object[] cache = ctx.mServiceCache;        synchronized (cache) &#123;            // Fetch or create the service.            Object service = cache[mCacheIndex];            if (service == null) &#123;                service = createService(ctx);                cache[mCacheIndex] = service;            &#125;            return (T)service;        &#125;    &#125;    public abstract T createService(ContextImpl ctx);&#125;\n\n\n\nStaticServiceFetcher\n\nStaticServiceFetcher 获取服务的策略是：用一个 mCachedInstance 的成员变量作为缓存来保存服务，如果这个变量不为空就直接返回；否则就创建一个服务，缓存至这个变量后返回。\nstatic abstract class StaticServiceFetcher&lt;T&gt; implements ServiceFetcher&lt;T&gt; &#123;    private T mCachedInstance;    @Override    public final T getService(ContextImpl unused) &#123;        synchronized (StaticServiceFetcher.this) &#123;            if (mCachedInstance == null) &#123;                mCachedInstance = createService();            &#125;            return mCachedInstance;        &#125;    &#125;    public abstract T createService();&#125;\n\n\n\nStaticApplicationContextServiceFetcher\n\nStaticApplicationContextServiceFetcher 获取服务的策略和 StaticServiceFetcher 是一样的，就不赘述了。\nstatic abstract class StaticApplicationContextServiceFetcher&lt;T&gt; implements ServiceFetcher&lt;T&gt; &#123;    private T mCachedInstance;    @Override    public final T getService(ContextImpl ctx) &#123;        synchronized (StaticApplicationContextServiceFetcher.this) &#123;            if (mCachedInstance == null) &#123;                mCachedInstance = createService(appContext != null ? appContext : ctx);            &#125;            return mCachedInstance;        &#125;    &#125;    public abstract T createService(Context applicationContext);&#125;\n\n\n我们会发现，这三个抽象类有一个共同的特点，那就是它们都是用缓存策略实现了 getService() 这个方法，同时抽离出 CreateServiceFetcher() 这个抽象方法。这之中的意图可想而知，就是让子类只需关注如何将这个服务创建出来，不需要关注这个服务的缓存策略，因为缓存策略父类们都已经帮它们实现了。\n需要注意的是，CachedServiceFetcher 将获取过的服务缓存在 Context 的 mServiceCache 这个对象中，这个对象是一个 Object 类型的数组。你可能会问，为什么选择用数组来缓存，数组的容量是固定的，你怎么知道要缓存多少服务。我们看看 Context 的 mServiceCache：\nfinal Object[] mServiceCache = SystemServiceRegistry.createServiceCache();\n\n又回到了 SystemServiceRegister：\npublic static Object[] createServiceCache() &#123;     return new Object[sServiceCacheSize];&#125;\n\n结果发现这个数组的大小为 sServiceCacheSize，sServiceCacheSize 在上面 CachedServiceFetcher 的构造函数中进行了自增运算，而 CachedServiceFetcher 是在注册的时候创建的，因此注册了多少个 CachedServiceFetcher，cache 就有多大，因此我们不必担心缓存空间不够用。\n貌似有点扯远了，现在我们回过头来分析 registerService()，发现它就做了两件事：\n\n把该服务的 class 对象和服务名对应起来\n把该服务的服务名和获取该服务的策略对应起来\n\n服务获取策略注册完了，那么你自然会问，怎样通过这个策略获取服务呢？现在我们来看看 SystemServiceRegistry 的 getSystemService() 方法：\npublic static Object getSystemService(ContextImpl ctx, String name) &#123;    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);    return fetcher != null ? fetcher.getService(ctx) : null;&#125;\n\n这就印证了我们之前的推断。获取系统服务时，先通过注册时的对应好的关系找出这个服务对应的服务获取策略（也就是 ServiceFetcher 对象），然后调用这个服务的获取策略的 getService() 方法获取这个服务。前面分析了，三种 ServiceFetcher 获取服务的策略都是先从缓存中找，如果没有就创建一个。那么服务是怎样创建的呢？如果你仔细观察过那一系列的 registerService()，就会发现大多数服务是这样创建的：\nIBinder b = ServiceManager.getService(service_name);ServiceInterface service = ServiceInterface.Stub.asInterface(b);return new xxxManager(ctx, ServiceInterface);\n\n有没有种似曾相识的感觉？这和我们使用 AIDL 实现进程间通信时客户端的行为是一样的：\n\n获取服务端传过来的 Binder（对于进程间通信，其实它是一个 BinderProxy 对象）\n将这个 Binder 通过 asInterface() 转换成相应 AIDL 接口的客户端代理\n\n我们知道，Binder 的作用相当于一把钥匙，客户端拿到这个 Binder 用 asInterface() 将其转换成相应 AIDL 接口的客户端代理后就可以 “随意使唤” 服务端了。只不过在这里是服务接口(如 IActivityManager，IWindowManager)而不是 AIDL 接口，并且在服务接口的客户端代理上又包装了一层，但实际上还是通过操作代理对象进行进程间通信的。\n我们发现所有服务的客户端 Binder（BinderProxy） 都来自于 ServiceManager，看来这个类就是我们接下来要研究的重点。那么有请 ServiceManager 登场。\nServiceManager不用我过多解释估计你也明白这个类的作用，它就是服务的管理类。安卓的系统服务种类繁多，自然需要一个管理者对它们进行统一的管理，ServiceManager 就充当了这样一个角色。那么，它是怎样对那些系统服务进行管理的呢？我们可以看看它的源码。源码不多，我们首先看看这个方法：\npublic static IBinder getService(String name) &#123;    try &#123;        IBinder service = sCache.get(name);        if (service != null) &#123;            return service;        &#125; else &#123;            return getIServiceManager().getService(name);        &#125;    &#125; catch (RemoteException e) &#123;        Log.e(TAG, &quot;error in getService&quot;, e);    &#125;    return null;&#125;\n\n这个方法的作用很明显，就是根据服务名获取一个服务对应的客户端 Binder（BinderProxy）对象。获取 Binder 的过程是先从缓存 sCache 中查找是否存在缓存过的 Binder 对象，不存在就通过 getIServiceManager().getService(name) 来获取并返回。这里我们只对 sCache 和 getIServiceManager() 感兴趣。先看 sCache：\n\nsCache\n\n通过上面的代码我们发现，当缓存中没有需要的 Binder（BinderProxy）时，会通过 getIServiceManager().getService() 获取，但是我们并没有把获取到的 Binder（BinderProxy） 进行缓存，这样一来，sCache 岂不是一直都是空的？我们看看它是怎样得到的：\npublic static void initServiceCache(Map&lt;String, IBinder&gt; cache) &#123;        if (sCache.size() != 0) &#123;            throw new IllegalStateException(&quot;setServiceCache may only be called once&quot;);        &#125;        sCache.putAll(cache);&#125;\n\n那么我们只要找到 initServiceCache() 的调用者就可以知道 sCache 是怎样被初始化的。在源码中遨游一小阵子之后发现最终它是这样被初始化的（ActivityManagerService#getCommonServicesLocked）：\nprivate HashMap&lt;String, IBinder&gt; getCommonServicesLocked(boolean isolated) &#123;    if (mAppBindArgs == null) &#123;        mAppBindArgs = new HashMap&lt;&gt;();        if (!isolated) &#123;            // Setup the application init args            mAppBindArgs.put(&quot;package&quot;, ServiceManager.getService(&quot;package&quot;));            mAppBindArgs.put(&quot;window&quot;, ServiceManager.getService(&quot;window&quot;));            mAppBindArgs.put(Context.ALARM_SERVICE,                    ServiceManager.getService(Context.ALARM_SERVICE));        &#125;    &#125;    return mAppBindArgs;&#125;\n\n这就说明只有 PackageManagerService，WindowManagerService 和 AlarmManagerService 对应的客户端 Binder（BinderProxy） 被缓存在 sCache 中的，其他服务的都是现用现取。至于为什么只对这三个 BinderProxy 进行缓存，我也不是太清楚，大家有兴趣可以去研究研究。\n\ngetIServiceManager()\n\nprivate static IServiceManager getIServiceManager() &#123;        if (sServiceManager != null) &#123;            return sServiceManager;        &#125;        // Find the service manager        sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject());        return sServiceManager;&#125;\n\n这是典型的单例模式，并且我们还发现 sServiceManager 也是通过 IPC 得到的（源码中 xxxManagerNative 其实就相当于 AIDL 中的 Stub），说明这个 ServiceManager 其实也是一个代理类。也就是说我们获取系统服务的过程，就是通过 ServiceManager 这个代理获取其他服务的客户端代理的过程。\nOK，安卓获取系统服务的过程就介绍到这里，感谢大家的阅读，有什么不对的地方还望大家不吝赐教。\n","tags":["Android","IPC","System Service","Binder"]},{"title":"安卓中 Service 的启动过程（上）","url":"/2016/12/15/2016-12-13-process-of-starting-a-service/","content":"Service 的启动过程（上）作为四大组件的 Service，由于没有 UI 界面，只能默默无闻地在后台工作。虽然我们说他是后台工作的，但是他还是默认进程的主线程中运行的，除非我们给它指定了单独的进程。Service 的启动过程有两种，一种是 startService()，另一种是 bindService()。我会在接下来的两篇文章中分别来介绍着两种启动方式，首先我们来探究 startService() 启动服务的过程。\n\n\n通过 startService 启动一个 ServiceActivity 和 Service 都是从 ContextWrapper 继承而来，而 ContextWrapper 继承自 Context 这个抽象类，所以我们通常把 Activity 和 Service 看作是 Context 对象。ContextWrapper 的实现用的是典型的装饰者模式，它的一系列的方法都靠内部的被装饰者的同名方法来实现，这和代理模式有点类似。而这个被装饰者通常是一个 ContextImpl，它是 Context 的真正实现者。\nstartService() 是 Context 中定义的一个方法，由于 Activity 和 Service 属于 ContextWrapper 类型，所以这个方法真正的实现在 ContextImpl#startService() 中：\n@Overridepublic ComponentName startService(Intent service) &#123;    warnIfCallingFromSystemProcess();    return startServiceCommon(service, mUser);&#125;\nstartService() 会调用 startServiceCommon() 方法：\nprivate ComponentName startServiceCommon(Intent service, UserHandle user) &#123;    try &#123;        ......        ComponentName cn = ActivityManagerNative.getDefault().startService(            mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(                        getContentResolver()), getOpPackageName(), user.getIdentifier());           ......        return cn;    &#125; catch (RemoteException e) &#123;        throw e.rethrowFromSystemServer();    &#125;&#125;\nActivityManagerNative.getDefault() 返回的是一个 ActivityManagerProxy 对象，它作为 AMS 在本进程的代理，如果我们的应用程序要和 AMS 打交道，必须要以它为媒介。这样看来 ActvitiyManagerService 并不像它名字所暗示的那样只管理 Activity，Servcie 也同样归它管。显然，这是一个远程调用，具体的实现在 ActivityManagerService#startService() 中：\n@Overridepublic ComponentName startService(IApplicationThread caller, Intent service,        String resolvedType, String callingPackage, int userId)        throws TransactionTooLargeException &#123;    ......    synchronized(this) &#123;        final int callingPid = Binder.getCallingPid();        final int callingUid = Binder.getCallingUid();        final long origId = Binder.clearCallingIdentity();        ComponentName res = mServices.startServiceLocked(caller, service,                resolvedType, callingPid, callingUid, callingPackage, userId);        Binder.restoreCallingIdentity(origId);        return res;    &#125;&#125;\n这个方法并没有做什么，它把事情交给了 mService， mService 是一个 ActiveServices 对象。在早期的安卓版本中并没有这个类，后来重构时抽出这个类专门用来管理 Service，ActiveServices#startServiceLocked() 有点长，我们挑重要部分来看：\nServiceLookupResult res =        retrieveServiceLocked(service, resolvedType, callingPackage,                callingPid, callingUid, userId, true, callerFg, false);......ServiceRecord r = res.record;......return startServiceInnerLocked(smap, service, r, callerFg, addToStarting);\n这个方法根据这个 Service 对应的 Intent 解析出一个 ServiceRecord，然后把事情交给了 startServiceInnerLocked()，这个方法的核心就是调用了 bringUpServiceLocked()，因此我们进入 ActiveService#bringUpServiceLocked() 看看：\nprivate String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,        boolean whileRestarting, boolean permissionsReviewRequired)        throws TransactionTooLargeException &#123;                ......                final boolean isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != 0;        final String procName = r.processName;        ProcessRecord app;        if (!isolated) &#123;            app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);            ......            if (app != null &amp;&amp; app.thread != null) &#123;                try &#123;                    app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);                    realStartServiceLocked(r, app, execInFg);                    return null;                &#125; catch (TransactionTooLargeException e) &#123;                    throw e;                &#125; catch (RemoteException e) &#123;                    Slog.w(TAG, &quot;Exception when starting service &quot; + r.shortName, e);                &#125;             &#125;        &#125; else &#123;            app = r.isolatedProc;        &#125;                ......                if (app == null &amp;&amp; !permissionsReviewRequired) &#123;            if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags,                    &quot;service&quot;, r.name, false, isolated, false)) == null) &#123;                ......                bringDownServiceLocked(r);                return msg;            &#125;            if (isolated) &#123;                r.isolatedProc = app;            &#125;        &#125;              if (!mPendingServices.contains(r)) &#123;            mPendingServices.add(r);        &#125;        ...... &#125;\n这段代码中有一个分支：\n\n如果 Service 要运行在启动服务的进程中（默认情况），就直接转到 realStartServiceLocked() 方法；\n如果 Service 需要运行在指定进程（注册时给 Service 指定进程名）中就会通知 AMS 新开一个进程（如果这个进程不存在的话），并把这个 Service 对应的 ServiceRecord 对象放进等待列表 mPendingServices 中，当进程开启成功后会从列表中取出 ServiceRecord 对象，然后把 ServiceRecord 对应的 Service 在该进程中创建并运行。\n\n下面我们分别对这两种情况进行研究。\n在启动服务的进程中创建 Service前面说了，如果在启动服务的进程中启动 Service 会进入到 ActiveService#realStartServiceLocked() 方法中，它有两行代码值得关注：\n第一行代码app.thread.scheduleCreateService(r, r.serviceInfo,       mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),       app.repProcState);\n关于这行代码说明两点：\n\napp 是要运行 Service 的进程对应的 ProcessRecord 对象，系统源码很多地方用 ProcessRecord 代表一个应用进程，这和用 ActivityRecord 代表一个 Activity 以及用 ServiceRecord 代表一个 Service 是同样的道理。\nthread 是一个 ApplicationThreadProxy 对象，它是应用进程的 ApplicatonThread 对象在 AMS 端的代理，AMS 靠它来和应用进程进行通信。你可能会感到奇怪，前面不是说了应用进程和 AMS 通信靠的是 ActivityManagerProxy 吗，这里怎么出来了一个 ApplicationThreadProxy ？我们要清楚，Binder 实现的进程间通信是单向的，其信息传递方向是 BinderProxy —&gt; Binder。但是很显然，应用进程和 AMS 是需要双向通信的，所以要想实现双向通信，必须有两对 Binder-BinderProxy 才行，这就是 ApplicationThread 和 ApplicationThreadProxy 存在的的原因。应用进程和 AMS 的通信可以用下图来表示：\n\n\n虽然在这里是 ActiveServices 与应用进程通信，但 ActiveServices 也是用来辅助 AMS 管理 Service 的，所以也可以把这个过程看作是 AMS 与 应用进程的通信。（要知道早期的安卓版本没有 ActiveServices 这个类，这些逻辑都是在 AMS 中的）\n这行代码的作用是通知应用进程根据已知信息创建一个 Service，那么应用进程是怎样创建这个 Service 的呢？进入到 ApplicationThread#scheduleCreateService()：\npublic final void scheduleCreateService(IBinder token,        ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123;    updateProcessState(processState, false);    CreateServiceData s = new CreateServiceData();    s.token = token;    s.info = info;    s.compatInfo = compatInfo;    sendMessage(H.CREATE_SERVICE, s);&#125;\n\n在 scheduleCreateService() 中，先是把 AMS 传来的信息封装成一个 CreateServcieData 对象，然后调用 sendMessage() 把信息发送出去。注意，sendMessage() 是 ActivitytThead 的方法，因为 ApplicationThread 是 ActivityThread 的内部类，所以对 ActivityThread 有完全的访问权限。这样一来消息就从 ApplicationThread 传到了 ActivityThread，我们来看看 ActivityThread#sendMessage()：\nprivate void sendMessage(int what, Object obj) &#123;    sendMessage(what, obj, 0, 0, false);&#125;\n转到另一个重载方法：\nprivate void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123;    Message msg = Message.obtain();    msg.what = what;    msg.obj = obj;    msg.arg1 = arg1;    msg.arg2 = arg2;    if (async) &#123;        msg.setAsynchronous(true);    &#125;    mH.sendMessage(msg);&#125;\n这里把信息传给了 mH 这个 Handler 对象，这个 Handler 对象是在应用进程的主线程中创建的，所以最终的结果是把创建 Service 的消息传到了主线程。现在你终于明白了为什么 Service 会在主线程运行吧？看看 mH 是怎样处理这个消息的：\ncase CREATE_SERVICE:    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceCreate: &quot; + String.valueOf(msg.obj)));    handleCreateService((CreateServiceData)msg.obj);    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);    break;\n\n百转千回，消息最终传到了 handleCreateService()：\nprivate void handleCreateService(CreateServiceData data) &#123;    ......        LoadedApk packageInfo = getPackageInfoNoCheck(            data.info.applicationInfo, data.compatInfo);    Service service = null;    try &#123;        java.lang.ClassLoader cl = packageInfo.getClassLoader();        service = (Service) cl.loadClass(data.info.name).newInstance();    &#125; catch (Exception e) &#123;        ......    &#125;    try &#123;        if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name);        ContextImpl context = ContextImpl.createAppContext(this, packageInfo);        context.setOuterContext(service);        Application app = packageInfo.makeApplication(false, mInstrumentation);        service.attach(context, this, data.info.name, data.token, app,                ActivityManagerNative.getDefault());        service.onCreate();        mServices.put(data.token, service);        try &#123;            ActivityManagerNative.getDefault().serviceDoneExecuting(                    data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);        &#125; catch (RemoteException e) &#123;            throw e.rethrowFromSystemServer();        &#125;    &#125; catch (Exception e) &#123;        ......    &#125;&#125;\n这里是 Service 真正被创建的地方，这个方法做了以下几件事：\n\n根据类名用应用程序的类加载器加载并实例化一个 Service。\n创建一个 ContextImpl 对象，把 Service 作为它的额外层 Context 对象。\n为这个 Service 创建一个 Application 对象，当然，如果应用进程已经存在 Application 就不会重复创建，具体大家可以看看 LoadedAPK#makeApplication() 的实现，这里就不详细讲了。\n用 Service 的 attach() 方法把相应信息附加到 Service，其中，context 是之前创建的 ContextImpl 对象，在 attach() 方法中会把它作为 Service 内部的被装饰对象；this 代表本进程中的 ActivityThread 对象；data.info.name 是这个 Service 的名称；data.token 是从 AMS 传过来的 ServiceRecord 对象，它是一个 Binder，作为这个 Service 的标识。\n调用 Service 的 onCreate() 方法。\n把 token 和 Service 的映射关系保存在 mServices 中。\n通过 ActivityManagerProxy 告知 AMS Service 已经创建好了，让其完成后续的工作。\n\n关于后续 AMS 做了哪些事，我们就不深究了，大家有兴趣可以自行阅读源码。现在我们看看 ActiveService#realStartServiceLocked() 中的另一行代码。\n第二行代码sendServiceArgsLocked(r, execInFg, true);\n\n这个方法的核心部分在这里：\nr.app.thread.scheduleServiceArgs(r, si.taskRemoved, si.id, flags, si.intent);\n这里又通过 ApplicationThreadProxy 和应用进程进行了通信，我们看看应用进程是怎样响应这个方法调用的：\npublic final void scheduleServiceArgs(IBinder token, boolean taskRemoved, int startId,    int flags ,Intent args) &#123;    ServiceArgsData s = new ServiceArgsData();    s.token = token;    s.taskRemoved = taskRemoved;    s.startId = startId;    s.flags = flags;    s.args = args;    sendMessage(H.SERVICE_ARGS, s);&#125;\n和前面一样，同样是把信息封装好后通过安卓的消息机制投递到主线程中，我们看看 Handler:mH 是怎样处理这个消息的：\ncase SERVICE_ARGS:    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceStart: &quot; + String.valueOf(msg.obj)));    handleServiceArgs((ServiceArgsData)msg.obj);    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);    break;\n转入 ActivityThread#handleServiceArgs：\nprivate void handleServiceArgs(ServiceArgsData data) &#123;    Service s = mServices.get(data.token);    if (s != null) &#123;        try &#123;            ......            int res;            if (!data.taskRemoved) &#123;                res = s.onStartCommand(data.args, data.flags, data.startId);            &#125; else &#123;                s.onTaskRemoved(data.args);                res = Service.START_TASK_REMOVED_COMPLETE;            &#125;            QueuedWork.waitToFinish();            try &#123;                ActivityManagerNative.getDefault().serviceDoneExecuting(                        data.token, SERVICE_DONE_EXECUTING_START, data.startId, res);            &#125; catch (RemoteException e) &#123;                throw e.rethrowFromSystemServer();            &#125;            ensureJitEnabled();        &#125; catch (Exception e) &#123;            ......        &#125;    &#125;&#125;\n这里先根据 token 取出保存的 Service，然后根据 data.taskRemoved 的值回调 Service 中的相应方法，一般情况下这个值是为 false 的，也就是说 Service 的 onStartCommand() 方法会得到调用。至此在服务启动者的进程中创建服务的过程就分析完了，现在我们看看指定进程中启动服务的过程是怎样的。\n在指定进程中创建并启动 Service 的过程如果注册 Service 的时候我们给 Service 指定了进程名，那么 Service 就会在那个进程中被创建并运行，这个时候启动过程就会走向另一条分支，还记得出现分支的地方吗？它在 ActiveService#bringUpServiceLocked() 中，这条分支会执行以下代码：\nprivate String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,        boolean whileRestarting, boolean permissionsReviewRequired)        throws TransactionTooLargeException &#123;        ......                if (app == null &amp;&amp; !permissionsReviewRequired) &#123;            if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags,                    &quot;service&quot;, r.name, false, isolated, false)) == null) &#123;                ......                bringDownServiceLocked(r);                return msg;            &#125;            if (isolated) &#123;                r.isolatedProc = app;            &#125;        &#125;              if (!mPendingServices.contains(r)) &#123;            mPendingServices.add(r);        &#125;        ......&#125;\n注意到这行代码 mAm.startProcessLocked()，mAm 就是 AMS，这里通过 AMS 开启了一个进程。现在我们进入 ActivityManagerService#startProcessLocked() 这个方法：\nprivate final void startProcessLocked(ProcessRecord app,        String hostingType, String hostingNameStr) &#123;    startProcessLocked(app, hostingType, hostingNameStr, null /* abiOverride */,            null /* entryPoint */, null /* entryPointArgs */);&#125;\n转向它的一个重载方法，这个重载方法有点长，但它的核心代码也就一句话：\nProcess.ProcessStartResult startResult = Process.start(entryPoint,        app.processName, uid, uid, gids, debugFlags, mountExternal,        app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,        app.info.dataDir, entryPointArgs);\nProcess#start() 会利用这些参数向 native 层 fork 一个进程。注意到这个方法的第一参数 String:entryPoint，顾名思义，它是进程的入口点，其值为 &quot;android.app.ActivityThread&quot;。对于 ActivityThread 我们应该很熟悉了，每个应用进程都有一个 ActivityThread 对象，它代表着应用进程的主线程，处理着内部类 ApplicationThread 发送过来的来自 AMS 的各种消息。进程创建好后 native 层代码后就会调用这个类的静态方法 main()，它的实现如下：\npublic static void main(String[] args) &#123;    ......    final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());    TrustedCertificateStore.setDefaultUserDirectory(configDir);    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);    Looper.prepareMainLooper();    ActivityThread thread = new ActivityThread();    thread.attach(false);    if (sMainThreadHandler == null) &#123;        sMainThreadHandler = thread.getHandler();    &#125;    if (false) &#123;        Looper.myLooper().setMessageLogging(new                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));    &#125;    // End of event ActivityThreadMain.    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);    Looper.loop();    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);&#125;\n它很简短，主要做了这几件事：\n\n为主线程准备消息循环\n为应用进程创建一个 ActivityThread 对象\n调用 ActivityThread 的 attach() 方法\n开启消息循环\n\n这样我们的应用进程就进入到一个死循环中了，不断的接受消息并执行。所以我们会说安卓应用是消息驱动的。我们重点关注 attach() 方法，它有这样一段代码值得关注：\nfinal IActivityManager mgr = ActivityManagerNative.getDefault();try &#123;    mgr.attachApplication(mAppThread);&#125; catch (RemoteException ex) &#123;    throw ex.rethrowFromSystemServer();&#125;\n这里通过 ActivityManagerProxy 远程调用了 AMS 的 attachApplication() 方法，参数是 mAppThread，而它是这样初始化的：\nfinal ApplicationThread mAppThread = new ApplicationThread();\n说明它就是 ApplicationThread 对象，前面说了，AMS 要想向应用进程发送消息，需要借助 ApplicationThreadProxy 对象。而通过 Binder 机制 ApplicationThread 在 AMS 那边就转化成了 ApplicationThreadProxy 对象，所以这个对象就是在此时传给 AMS 的。在 AMS 中，attachApplication() 会直接调用 attachApplicationLocked()，对于这个方法，我们挑需要的代码段来看：\nif (!badApp) &#123;    try &#123;        didSomething |= mServices.attachApplicationLocked(app, processName);    &#125; catch (Exception e) &#123;        Slog.wtf(TAG, &quot;Exception thrown starting services in &quot; + app, e);        badApp = true;    &#125;&#125;\nmServices 就是 ActiveServices，进入 ActiveServices#attachApplicationLocked()：\nboolean attachApplicationLocked(ProcessRecord proc, String processName)        throws RemoteException &#123;    boolean didSomething = false;    // Collect any services that are waiting for this process to come up.    if (mPendingServices.size() &gt; 0) &#123;        ServiceRecord sr = null;        try &#123;            for (int i=0; i&lt;mPendingServices.size(); i++) &#123;                sr = mPendingServices.get(i);                if (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid                        || !processName.equals(sr.processName))) &#123;                    continue;                &#125;                mPendingServices.remove(i);                i--;                proc.addPackage(sr.appInfo.packageName, sr.appInfo.versionCode,                        mAm.mProcessStats);                realStartServiceLocked(sr, proc, sr.createdFromFg);                didSomething = true;                if (!isServiceNeeded(sr, false, false)) &#123;                    bringDownServiceLocked(sr);                &#125;            &#125;        &#125; catch (RemoteException e) &#123;           ......        &#125;    &#125;    ......&#125;\n大家还记得 mPendingServices 吗？前面说了，如果在指定进程当中运行一个 Service，会先创建一个进程，然后在把该 Service 对应的 ServiceRecord 对象放入 mPendingServices 中，待进程创建好了就会从中取出 ServiceRecord，然后根据它在进程中创建 Service。具体过程是怎样的呢？我们看看这个方法主要作了哪些事：\n遍历 mPendingServices，根据 ProcessRecord:proc 和 String:processName 提供的进程信息找出要运行在这个进程的 ServiceRecord，然后调用 realStartServiceLocked() 方法并把找到的 ServiceRecord 作为参数传入其中。realStartServiceLocked() 之后的流程前面已经有介绍，这里就不重复讲了。\n至此，通过 startService() 启动服务的整个过程就介绍完了，在接下来的一篇文章中我会介绍通过 bindService() 创建并绑定一个 Service 的详细流程。感谢大家的阅读，有什么不对的地方还望大家不吝赐教。\n","tags":["Android","四大组件"]},{"title":"android 记坑","url":"/2017/02/24/2017-02-24-android-dev-log/","content":"android 记坑调用相机获取图片有两种方法获取图片，分别对应不同的需求：一种是获取缩略图，适合用来做头像或者其他比较小的 icon ；另一种是获取原图，如果有保存或查看原图的需求，就应该用这种方法。\n\n\n获取缩略图Intent getThumbnail = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);File file = createEmptyFile();if (getThumbnail.resolveActivity(getPackageManager()) != null)    startActivityForResult(getThumbnail, REQUEST_GET_THUMBNAIL);\n\n这样就调用了相机拍照，然后我们在 onActivityResult() 中获取图片：\n@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;    if (requestCode == REQUEST_GET_THUMBNAIL) &#123;        if (resultCode == RESULT_OK) &#123;            Bitmap bitamp;            if (data != null)                 bitmap = (Bitmap) data.getExtras().get(&quot;data&quot;);            thumbnail.setImageBitmap(bitmap);        &#125;    &#125;&#125;\n\n获取原图Intent getBigPhoto = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);File file = createEmptyFile(); //用于输出原图currentFile = file;Uri uri = Uri.fromFile(file);//将 file 转换成 uri 格式getBigPhoto.putExtra(MediaStore.EXTRA_OUTPUT, uri);startActivityForResult(Intent, REQUEST_GET_BIG_PHOTO);\n然后图片就会自动输出到你指定的文件，如果同时你又想获取原图，你就会这样做：\n@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;    if (requestCode == REQUEST_GET_BIG_PHOTO) &#123;        if (resultCode == RESULT_OK) &#123;            Bitmap bitamp;            if (data != null)                 bitmap = (Bitmap) data.getExtras().get(&quot;data&quot;);            thumbnail.setImageBitmap(bitmap);        &#125;    &#125;&#125;\n好了，看似一切正常，但是总有一些你意想不到的异常发生，我来指出这之中有问题的几个坑吧（权限问题就不讲了）吧：\n\nFile 转换成 Uri 格式这一步时，如果你是上面那样转换的，那么在 android N 上你就会得到 FileUriExposedException，因为这样做是不安全的，你将文件的真实 Uri 暴露出去了，其他应用可能对这个文件有完全的控制权。安全的做法是通过 [FileProvider.getUriForFile(Context, String, File)](https://developer.android.google.cn/reference/android/support/v4/content/FileProvider.html#getUriForFile(android.content.Context, java.lang.String, java.io.File)) 暴露所要提供的 Uri。这样提供给其他的应用的 Uri 不会暴露出文件的真实位置，因为这只是这是文件的一个 “镜像地址”，其他应用只能调用系统功能才能将此 Uri 定位到实际位置。\n如果你想同时获取原图和缩略图，那么你就错了，这二者不可兼得。每次调用相机，只能获取缩略图或者原图，这和你是否指定 MediaStore.EXTRA_OUTPUT 附加字段有关：如果没有指定，说明你并不想将获取的图片输出（即保存为原图)，此时 onActivityResult() 的第三个参数就不为 null，你可以从中取出缩略图；但是如果指定了，说明你想将照片输出为原图，那么第三个参数就为 null，你并不能从中获取缩略图。\n\n将图片添加至媒体库我们的应用经常有将图片保存到磁盘的需求，但是保存的图片在下一次开机前媒体库是检测不到的，也就是说我们在图库中是看不到刚才保存的图片的，因此也就无法和其他应用共享。要将保存的图片加入媒体库中需要做一点额外的工作，下面介绍实现方法：\n发送广播通知媒体库扫描此图片这一方法在安卓官方培训教程中有提到，它是这样做的：\nprivate void galleryAddPic() &#123;    Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);    File f = new File(mCurrentPhotoPath);    Uri contentUri = Uri.fromFile(f);    mediaScanIntent.setData(contentUri);    this.sendBroadcast(mediaScanIntent);&#125;\n\n和系统进程通信将图片添加至媒体库另外一种是通过 MediaScannerConnection 实现的，这一方法的原理就是和系统进程进行通信，具体做法是这样的：\npublic Class Client implements MediaScannerConnectionClient &#123;    private MediaScannerConnection conn;    private String filePath;    private String mimeType;        public Client(Context c, String filePath, String mimeType) &#123;        conn = new MediaScannrConnection(context, this);    &#125;    @Override    public void onMediaScannerConnected() &#123;        conn.scanFile(filePath, mimeType);    &#125;    @Override    public void onScanCompleted(String path, Uri uri) &#123;        Log.d(&quot;Client&quot;, &quot;path:&quot; + path + &quot;; uri:&quot; + uri);    &#125;        public void scanFile(String path, String mimeType) &#123;        this.filePath = filePath;        this.mimeType = mimeType;        conn.connect();    &#125;&#125;\n\n直接操作媒体库的数据库第三种方法是直接将图片信息直接添加媒体库的数据库中，其实前面两种方法的底层实现也是这样的，只是屏蔽了相关细节，避免我们直接接触数据库。因为要操作其他应用的数据库，所以要用到 ContentResolver，具体实现是这样的：\nContentValues values = new ContentValues();values.put(Images.Media.DATE_TAKEN, System.currentTimeMillis());values.put(Images.Media.MIME_TYPE, &quot;image/jpeg&quot;);values.put(MediaStore.MediaColumns.DATA, filePath);context.getContentResolver().insert(Images.Media.EXTERNAL_CONTENT_URI, values);\n下面分别介绍其中遇到的坑：\n\n第一种方法在 android 4.4 以下时是可以的，但是有个问题就是通过广播将单个文件添加至媒体库性能上不划算；在 android 4.4 会出现 SecurityException，原因是 android 4.4 禁止非系统应用发送系统广播，而扫描媒体文件的广播属于系统广播，因此运行时会崩溃；但是我在 android 5.0 至 7.1 上实测却可行，或许系统已经开放了此权限。\n第二种和第三种方法没有版本限制，是通用的方法。\n前两种方法有一点要注意，如果该图片存放至应用的私有目录下（无论内部存储还是外部存储），媒体库都无法扫描到该文件（没有权限）；第三种方法则没有这种限制，因为它不是通过扫描，而是直接操作数据库的方式添加的。\n\n通知###创建通知\n\n如果你的 target sdk 大于 26 (O)，那么发布通知时应该指定通知渠道，否则通知不能发送成功。\n发送通知时必须指定 smallIcon，并且 smallIcon 必须是 drawable 资源 ID ，否则会导致系统的 SystemUI 崩溃。\n设置通知的 PendingIntent 时需要注意，如果 Intent 中有附加字段需要传递，一定记得带 FLAG_UPDATE_CURRENT 这个标志，至于为什么，可以看看这篇文章：说说 PendingIntent 的内部机制。\n\n— 未完待续\n","tags":["Android","记坑"]},{"title":"探究 Java 虚拟机栈","url":"/2017/03/06/2017-03-06-explore-java-vm-stack/","content":"探究 Java 虚拟机栈前言Java 虚拟机的内存模型分为两部分：一部分是线程共享的，包括 Java 堆和方法区；另一部分是线程私有的，包括虚拟机栈和本地方法栈，以及程序计数器这一小部分内存。今天我就 Java 虚拟机栈做一些比较浅的探究。\n熟悉 Java 的同学应该都知道了，JVM 是基于栈的。但是这个“栈” 具体指的是什么？难道就是虚拟机栈？想要回答这个问题我们先要从虚拟机栈的结构谈起。\n\n\n虚拟机栈何为虚拟机栈虚拟机栈的栈元素是栈帧，当有一个方法被调用时，代表这个方法的栈帧入栈；当这个方法返回时，其栈帧出栈。因此，虚拟机栈中栈帧的入栈顺序就是方法调用顺序。什么是栈帧呢？栈帧可以理解为一个方法的运行空间。它主要由两部分构成，一部分是局部变量表，方法中定义的局部变量以及方法的参数就存放在这张表中；另一部分是操作数栈，用来存放操作数。我们知道，Java 程序编译之后就变成了一条条字节码指令，其形式类似汇编，但和汇编有不同之处：汇编指令的操作数存放在数据段和寄存器中，可通过存储器或寄存器寻址找到需要的操作数；而 Java 字节码指令的操作数存放在操作数栈中，当执行某条带 n 个操作数的指令时，就从栈顶取 n 个操作数，然后把指令的计算结果（如果有的话）入栈。因此，当我们说 JVM 执行引擎是基于栈的时候，其中的“栈”指的就是操作数栈。举个简单的例子对比下汇编指令和 Java 字节码指令的执行过程，比如计算 1 + 2，在汇编指令是这样的：\nmov ax, 1 ;把 1 放入寄存器 axadd ax, 2 ;用 ax 的内容和 2 相加后存入 ax\n\n而 JVM 的字节码指令是这样的：\niconst_1 //把整数 1 压入操作数栈iconst_2 //把整数 2 压入操作数栈iadd //栈顶的两个数相加后出栈，结果入栈\n\n由于操作数栈是内存空间，所以字节码指令不必担心不同机器上寄存器以及机器指令的差别，从而做到了平台无关。\n注意，局部变量表中的变量不可直接使用，如需使用必须通过相关指令将其加载至操作数栈中作为操作数使用。比如有一个方法 void foo()，其中的代码为：int a = 1 + 2; int b = a + 3;，编译为字节码指令就是这样的：\niconst_1 //把整数 1 压入操作数栈iconst_2 //把整数 2 压入操作数栈iadd //栈顶的两个数出栈后相加，结果入栈；实际上前三步会被编译器优化为：iconst_3istore_1 //把栈顶的内容放入局部变量表中索引为 1 的 slot 中，也就是 a 对应的空间中iload_1 // 把局部变量表索引为 1 的 slot 中存放的变量值（3）加载至操作数栈iconst_3 iadd //栈顶的两个数出栈后相加，结果入栈istore_2 // 把栈顶的内容放入局部变量表中索引为 2 的 slot 中，也就是 b 对应的空间中return // 方法返回指令，回到调用点\n\n需要说明的是，局部变量表以及操作数栈的容量的最大值在编译时就已经确定了，运行时不会改变。并且局部变量表的空间是可以复用的，例如，当指令的位置超出了局部变量表中某个变量 a 的作用域时，如果有新的局部变量 b 要被定义，b 就会覆盖 a 在局部变量表的空间。\n盗用别人的图以让大家对虚拟机栈有个直观的认识（其中小字体 Stack 指的的是虚拟机栈，Frame 是栈帧，Local variables 是局部变量表，Operand Stack 是操作数栈）：\n\n由虚拟机栈引出的问题看完上面的代码大家可能会有几点疑惑：什么是 slot？那些指令是什么意思？为什么 a 对应的 slot 的索引值不是从零开始的，它明明是第一个定义的变量啊？\n对于这些问题我们一个个来解决。\n什么是 slot首先什么是 slot？slot 是局部变量表中的空间单位，虚拟机规范中有规定，对于 32 位之内的数据，用一个 slot 来存放，如 int，short，float 等；对于 64 位的数据用连续的两个 slot 来存放，如 long，double 等。引用类型的变量 JVM 并没有规定其长度，它可能是 32 位，也有可能是 64 位的，所以既有可能占一个 slot，也有可能占两个 slot。\nJVM 字节码指令第二个问题，那些指令是什么意思？\n指令格式首先我们要理解 Java 指令的格式，Java 的指令以字节为单位，也就是一个字节代表一条指令。比如 iconst_1 就是一条指令，它占一个字节，那么自然 Java 指令不会超过 256 条。实际上 Java 指令目前定义了 200 多条。指令虽然是一个字节，但是它也可以带自己的操作数。JVM 中有这样一条指令 putstatic，其作用是给特定的的静态字段赋值。但是给哪个字段赋值呢？仅仅通过这条指令并不能说明，那么只有通过操作数来指定了。紧跟在 putstatic 后面的两个字节就是它的操作数，这个操作数是一个索引值，指向运行时常量池中该静态字段对应的符号引用。由于符号引用包含了该字段的基本信息，如所属类、简单名称以及描述符，因此 putstatic 指令就知道是给哪个类的哪个字段赋值了。\n指令的操作数分两种：一种是嵌入在指令中的，通常是指令字节后面的若干个字节；另一种是存放在操作数栈中的。为了区别，我们把前者叫做直接操作数，把后者叫做栈内操作数。这两者的区别是：直接操作数是在编译时就已经确定的，运行时不会改变，它和指令一样存放于类文件方法表的 Code 属性中；而栈内操作数是运行时确定的，即程序在执行过程中动态生成的。拿 putstatic 指令来说，它有一个直接操作数，该操作数是一个索引值（前面已经提到），它由两个字节组成，紧跟在 putstatic 对应的字节之后；同时它还有一个栈内操作数，位于操作数栈的栈顶，这个操作数就是要赋给静态字段的值，其对应的字节数根据静态字段的类型决定。如果静态字段的类型是 short、int、boolean、char 或者 byte，那么这个操作数就必须是 int 类型，即由栈顶的 4 个字节组成；如果是 float、double 或者 long 类型，那么操作数就是相应的类型，即由栈顶的 4 个、8 个 或者 8 个 字节组成；如果静态字段是引用类型，那么这个操作数的类型也必须是引用类型，即由栈顶的 8 个字节组成。\n再举一个例子。iconst_&lt;i&gt; 代表了一个指令族，它的意思是把整数 i 放入操作数栈中，i 的范围是(m1, 0, 1, 2, 3, 4, 5)，其中 m1 代表的是 -1。注意，这里的 i 并不是指令的操作数（即非直接操作数，也非栈内操作数），如 iconst_1、iconst_2 和 iconst_3 都是由一个字节组成的字节码指令。我们可以把 i 可以看作是指令的 “隐含操作数”，即指令本身就蕴含了操作数。如果整数 i 超过 [-1, 5] 这个范围，就不能用 iconst_&lt;i&gt; 表示了，因为仅一个字节的字节码指令不可能蕴含所有的整数。此时就需要 bipush 这条指令了，这条指令有一个直接操作数，由一个字节组成，用来表示要放入栈顶的那个整数，该整数放入栈顶时通过扩展符号位变为 32 位的整型。但是一个字节也表示不了所有的整数，如果整数值超过一个字节所能表示的范围，就只能通过 ldc 这条指令了，这条指令带有一个字节的直接操作数，它代表的是一个指向运行时常量池中 Constant_Integer_info 类型常量的索引，通过索引的方式引用运行时常量池中的整数，再大的整数也不怕了。\n阅读指令文档授之以鱼不如授之以渔，在这里不可能将所有的指令都讲解一番，因此我和大家分享一下如何阅读 oracle 官网关于字节码指令的文档吧。文档的地址是：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html\n我们拿 astore 指令来说：关于它的文档描述如下：\n\n说明和翻译：\n\n第一行的粗体字是指令的名称；\nOperation 是指令的功能：把引用存入本地变量中；\nFormat 是指令的格式：它的第一个字节是指令，名称为 astore，第二个字节是指令的直接操作数，名称为 index；Forms 指的是指令的十进制（十六进制）码，astore 的十进制（十六进制）码是 58（0x3a)；\nOperation Stack 是指令执行前后的操作数栈的状态：第一行代表的是指令执行前操作数的状态，第二行是指令执行后操作数栈的状态，箭头是栈顶方向。astore 执行前栈顶是对象引用 objectRef，它是 astore 的栈内操作数，执行后 objectRef 被弹出并存入局部变量表中；\nDescription 是对这条指令的描述：index 是无符号字节，这个 index 必须指向当前栈帧的局部变量表的某个位置。操作数栈的栈顶的那个引用值必须是 returnAddress（方法返回地址）或者是 reference （对象引用）。这个引用会被弹出，其值会被存入局部变量表中索引为 index 的 slot 中；\nNotes 是注意事项：实现 Java 中的 finally 子句时，astore 指令使用的操作数类型是一个 returnAddress，与 astore 对应的 aload 指令（将局部变量表的的引用值压栈）不能将类型为 returnAddress 类型的值加载到操作数栈，而只能是 reference 类型。aload 和 astore 这种不对称的设计是有意而为之的。astore 指令可以和 wide 指令配合使用以用无符号双字节类型的索引来获取局部变量表中的变量。\n\n局部变量表的第一个变量从 Java 语言的层面讲，静态方法和实例方法的本质区别在于是否是对象所共享的。而从 JVM 的角度来看，方法（无论静态方法还是实例方法）其实都是对象共享的，实例变量才是对象私有的。对 JVM 而言，静态方法和实例方法的本质区别在于是否需要和具体对象关联：静态方法可以通过类名来调用，它不需要和具体对象关联；而实例方法必须通过对象来进行调用，它需要和具体对象关联。那么，实例方法和具体对象是如何产生关联的呢？其实很简单，编译器在编译时会将方法接收者作为一个隐含参数传入该实例方法，这个参数在方法中有一个很熟悉的名字，叫做 “this”。之所以实例方法可以访问该类的实例变量和其它实例方法，正是因为它有 “this” 这个隐含参数。举个例子，类 A 中的某个方法 b 需要访问实例变量 x，由于实例变量是对象私有的，如果 b 是静态方法，由于它没有具体对象的引用，它并不知道该访问哪个对象的实例变量 x；如果 b 是实例方法，通过隐含参数 this 就能确定要访问的实例变量是 this.x。那么，为什么静态方法也不能调用该类的实例方法呢？本质原因也是没有 this 引用。因为调用实例方法的前提是要传入一个隐含参数，实例方法本来就有这个引用，所以能够把它作为隐含参数传入另一个实例方法；静态方法没有 this 引用，无法给实例方法提供指向方法接收者的隐含参数，因此不能调用实例方法。\n如果看懂了上面说的那些，第三个问题也就迎刃而解了。因为我们定义的方法是 void foo()，它是实例方法，因此会有一个指向具体对象的隐含参数 this，this 就存放在局部变量表的第一个位置，即存放在索引为 0 的 slot 中，又由于它的作用域从方法开始一直到方法结束，因此它在局部变量表中的位置不会被其他变量覆盖，从而使得我们在方法中定义的变量只能放在局部变量表后面的位置中。需要注意的是，如果方法有参数（非隐含参数），那么参数会按顺序紧接着 this 存放在局部变量表中，由于参数作用域也是整个方法体，所以方法中定义的局部变量就只能放在参数后面了。总的来说局部变量表中变量的存放顺序为： this（如果是实例方法）&#x3D;&gt; 参数（如果有的话）&#x3D;&gt; 定义的局部变量（如果有的话）。\n感谢阅读关于虚拟机栈就讲这么多了，Java 虚拟机是一个完整的知识体系，仅仅了解虚拟机栈是不够的，这里没有细讲的关于虚拟机的其它知识，如内存模型、运行时常量池、类加载模型等，还需读者自己学习掌握。这篇文章权起激发大家的学习 JVM 兴趣的作用，同时也作为个人的学习记录和知识总结。之后可能还会写些 JVM 其它方面的总结性文章和大家分享。由于个人水平和理解有限，如果有不对的地方还请大家不吝赐教，感谢阅读！\n参考书籍 :《深入理解 Java 虚拟机》周志明 著Java 虚拟机规范 : The Java® Virtual Machine Specification\n","tags":["Java","JVM"]},{"title":"动态加载应用之简单热更新","url":"/2017/03/09/2017-03-09-android-hot-fix/","content":"动态加载应用之简单热更新在之前的一片文章中，我和大家分享了安卓动态加载的原理，这篇文章就和大家分享一下动态加载在热更新方面的应用，我会通过一个假想的案例来演示如何在项目利用动态加载实现热更新。\n\n\n案例某项目需要对某些数据集进行排序，但由于时间原因，开发团队使用了一个比较基础的算法实现该排序功能。上线之后才发现该排序算法的性能太差，影响了用户体验，因此开发团队不得不对该算法进行优化。优化后的新版本经过测试、发布、审核成功上线，但对项目进度造成了一定的影响。经历这次事件之后，开发团队吸取了教训：对于经常变动或者需要后期优化的功能，采用热更新技术避免重新发布新版本，从而降低人力成本。接下来我就用一个 demo 来模拟开发团队这次热更新技术的应用。\n实践在项目中插入热更新逻辑因为热更新需要从外部加载代码，而项目中的原本的代码并不能预知外部代码细节，因此我们需要定义一份接口实现项目中的代码和外部代码的对接。定义的接口如下：\npublic interface Sort &#123;    String getName(); // 获取排序算法的名称    void sort(int a[]);&#125;\n不同的排序策略可以对该接口采用不同的实现，我们当前在项目采用的排序策略是插入排序，其实现如下：\npublic class InsertSort implements Sort &#123;    @Override    public String getName() &#123;        return &quot;插入排序&quot;;    &#125;    @Override    public void sort(int[] a) &#123;        for (int i = 1; i &lt; a.length; i ++) &#123;            int key = a[i];            int pos = i;            for(int j = i - 1 ; j &gt;= 0; j--) &#123;                if (a[j] &lt; key) break;                a[j + 1] = a[j];                pos = j;            &#125;            a[pos] = key;        &#125;        System.out.println(&quot;I&#x27;m InsertSort&quot;);    &#125;&#125;\n把以上两个类放入项目中，同时创建一个 SortActivity，在该 Activity 中对排序算法进行了应用：\npublic class SortActivity &#123;    private static final int[] collection = &#123;21, 70, 1, 88, 4, 54, 22, 10, 9, 104, 37&#125;;        @Override    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_dynamic_loading);        TextView tvResult = (TextView) findViewById(R.id.tv_result);                Sort sort = getDefaultSort();        sort.sort(collection);        // 显示排序结果        StringBuilder result = new StringBuilder(sort.getName() + &quot;: &quot;);        for (int i = 0; i &lt; collection.length; i++) &#123;            result.append(collection[i]);            if (i != collection.length - 1) result.append(&quot;, &quot;);        &#125;        tvResult.setText(result.toString());    &#125;        private Sort getDefaultSort() &#123;        return new InsertSort();    &#125;&#125;\n上面的代码和采用热更新技术之前的项目代码无异，为了达到热更新的目的，我们要把关于热更新这一部分的逻辑写在程序中：\n@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_dynamic_loading);        Sort sort;    if (hasUpdate()) &#123; //如果排序算法有更新        sort = getNewSort(); // 应用新的排序算法    &#125; else &#123;        sort = getDefaultSort(); // 否则用默认实现的排序算法    &#125;    sort.sort(collection)    // 显示排序结果    ......&#125;private Sort getNewSort() &#123;    Sort newSort = null;    try &#123;        Class&lt;?&gt; clazz = getNewSortClass(); // 获取新的 Sort 实现类        newSort = (Sort) clazz.newInstance(); // 创建该实现类的实例    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;    return newSort; // 用新的排序算法实现排序&#125;private boolean hasUpdate()&#123;    // 根据需求自行实现，如询问服务器，这里通过读取配置文件内容模拟向服务器询问的过程    try &#123;        // 读取配置文件，默认值为 0，即没有更新        FileReader reader = new FileReader(Environment.            getExternalStorageDirectory().getAbsolutePath()            + File.separator + &quot;has_update.txt&quot;);        int hasUpdate = reader.read();        System.out.println(&quot;hasUpdate:&quot; + hasUpdate);        return hasUpdate == &#x27;1&#x27;;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;    return false;&#125;private Class&lt;?&gt; getNewSortClass() throws ClassNotFoundException &#123;    // 从服务器下载到本地磁盘    downLoadCodeFromServer();    // 假定下载的 .dex 文件在外部存储的根目录下，文件名为 newsort.dex    String path =  Environment.getExternalStorageDirectory().getAbsolutePath()             + File.separator + &quot;newsort.dex&quot;;    // .dex 文件优化输出后的目录为 “optimized_dir”    String optimizedDir = getDir(&quot;optimized_dir&quot;, MODE_PRIVATE).getAbsolutePath();    // 创建一个 DexClassLoader，用来加载从网络上下载的 .dex 文件    DexClassLoader loader = new DexClassLoader(path, optimizedDir, null, getClassLoader);    // 新的排序实现类的全名为 me.liwenkun.demo.NewSort，该名称也可从服务端或通过其他方式动态    // 获取，这里为了简化我们约定新的实现类的类名必须是 NewSort    loader.loadClass(&quot;me.liwenkun.demo.NewSort&quot;)&#125;\n对于上面的代码，需要说明几点：\n\n为了方便，我把网络请求和文件读取放在了主线程中，实际项目中不可能这样做；\n我忽略了权限相关的问题，大家在 demo 中一定要注意读写权限的配置，特别是 6.0 之后的动态权限申请，否则很可能导致热更新失败；\n优化后的输出目录一定要是私有的内部存储目录，否则在高版本的系统中会有运行时错误，因为这被认为是不安全的；从服务器下载的 .dex 的位置虽然没有限制，但安全起见最好也放置在内部私有目录中，本例中为了方便起见直接放在外部存储的根目录下（否则手机得 root）；\n如果关于 DexClassLoader 这个类加载器的原理和用法不熟悉的话，最好先看看我的这篇文章。\n\n至此，项目中关于热更新的逻辑就写完了。现在我们模拟上线，把应用装进手机并运行，结果如下图：\n\n实施热更新如果现在觉得这种排序算法还不够好，只需将新的 Sort 实现类编译成 .dex 文件发送给客户端就可以了，不必推送新的版本。比如我想用希尔排序取代插入排序，于是在项目中编写了 NewSort 类：\npublic class NewSort implements Sort &#123;    @Override    public String getName() &#123;        return &quot;希尔排序&quot;;    &#125;    @Override    public void sort(int[] a) &#123;        int h = 1;        int N;        for(N = a.length; h &lt; N / 25; h = h * 3 + 1);        while(h &gt;= 1) &#123;            for(int i = h; i &lt; N; ++i) &#123;                for(int j = i; j &gt;= h &amp;&amp; a[j] &lt; a[j - h]; j -= h) &#123;                    exch(a, j, j - h);                &#125;            &#125;            h /= 3;        &#125;    &#125;    private void exch(int[] a, int src, int dest) &#123;        int temp = a[src];        a[src] = a[dest];        a[dest] = temp;    &#125;&#125;\n\n编译之后，我们需要将此类以 jar 包的形式输出，为之后生成 .dex 文件做好准备。因此我们找到 Android Studio 的编译输出文件夹（我这里的位置是 Demo/app/build/intermediates/classes/debug/），找到 NewSort.class，连同 package 将其移出，结果如下图所示：\n\n在 me 的上一级目录处打开终端，输入命令 jar cf newsort.jar me，执行完后我们在与 me  同级的位置可以看到打包好的 newsort.jar 文件。（关于 .jar 文件的打包可以参考 命令行编译、打包并运行一个 java 程序 这篇文章。）\n接下来我们进入 sdk 目录，找到 build-tools 文件夹，该文件夹下有各个版本的 build-tools，如下图所示，我们选择最新的 25.0.2，进入之后会发现有一个名为 dx 的工具，它可以将 jar 包转换成 .dex 文件。所以把我们的 newsort.jar 放入 25.0.2 目录下，然后在 25.0.2 这个目录位置打开终端，输入命令 ./dx --dex --output=/Users/lwenkun/desktop/newsort.dex newsort.jar  ，命令执行完后在 desktop 文件夹下（也就是桌面）可以看到生成了 newsort.dex 文件，这个文件就是我们最终需要的。\n\n准备好了 .dex 文件后，我们就可以模拟热更新了。我们假设 .dex 文件已经从服务器下载到了本地，因此直接把 newsort.dex 文件拷贝到手机外部存储的根目录下。然后修改根目录下的 has_update.txt 文件，将其中的值修改为 1。然后我们退出应用，等再次打开应用时，插入排序已经成功替换成了希尔排序：\n\n感谢阅读动态加载在热更新方面的应用就分享到这里了，网上关于这方面的文章也有很多，大家可以找写这方面的文章看看。由于水平和理解能力有限，有什么不对的地方还望大家不吝赐教，感谢大家的阅读。\n参考资料：安卓动态加载\n","tags":["Android","动态加载","热更新"]},{"title":"Java 8 方法引用","url":"/2017/03/23/2017-03-23-java-8-method-references/","content":"Java 8 方法引用形如 ClassName::methodName 或者 objectName::methodName 的表达式，我们把它叫做方法引用（Method Reference）。可能你现在还理解不了，但是编译器足够聪明，或许你可以看看编译器是如何根据 “晦涩难懂” 的 Method Reference 来推断你的意图的。\n\n\n方法引用的种类方法引用有四种，分别是：\n\n指向静态方法的引用\n指向某个对象的实例方法的引用\n指向某个类型的实例方法的引用\n指向构造方法的引用\n\n下面通过一些代码示例来和大家分享一下这四种引用使用场景，先定义一个 Person 类，后面我们会用到它：\npublic class Person &#123;    private String name;        private String getName() &#123;        return name;    &#125;        public static int compareName(Person a, Person b) &#123;        return a.getName().compareTo(b.name);    &#125;&#125;\n\n指向静态方法的引用形式：ContainingClass:staticMethodName\n如果要想实现一群人按名字排序，一般你会这么做：\nArrays.sort(personArray, new Comparator() &#123;    @Override    public int compare(Person a, Person b) &#123;        return a.getName().compareTo(b.getName());    &#125;&#125;);\n\n第二个参数很复杂，但是目的却很简单：实现 Comparator 的一个比较方法。我们自然会想——相信很多程序员都会这么想：有没有一种方法能够既简单明了又能无歧义的表达我们的意图？当然有，Java 8 引入的 lambda 表达式便很好的简化了我们的代码，瞧：\nArray.sort(personArray, (a, b) -&gt; &#123;    return a.getName().compareTo(b.getName());&#125;);\n\n(a, b) 是 lambda 表达式的参数列表，箭头后的是方法体。编译器已经被训练得足够聪明：它知道 (a, b) 就是代表着要比较的两个 Person 对象。它在脑海里构想出了这个 lambda 表达式的 “原型”：\nnew Comparator() &#123;    @Override    public int compare(Person a, Person b) &#123;        return a.getName().compareTo(b.getName());    &#125;&#125;\n\n机智的编译器从简化的代码中推断出了 Comparator 对象的 “原型”。但是程序员并不满足：还能不能进一步简化？当然可以，在不造成歧义的前提下可以无限地简化一个语法。我们注意到，Person 类有一个静态方法可以用来实现两个对象的比较，于是引入 指向静态方法的引用：\nArrays.sort(personArray, Person::compareName);\n\nPerson.compareName() 方法有两个 Person 类型的参数，一个 int 类型的返回值，所以Person::compareName 这个方法引用拥有两个 Person 类型的不确定量（在这里指的就是 compareName() 的两个参数；文章末尾有关于不确定量的具体解释）和一个 int 类型的返回值。而 Comparator 中待实现的方法 compare() 也有两个 Person 类型的参数和一个 int 的返回值。方法引用和 Comparator 中要实现的方法有足够的相似度，因此编译器将 Person::compareName 的不确定量和返回值与 compare() 的参数和返回值对应了起来，由此推断出我们的意图是：\nArrays.sort(personArray, new Comparator() &#123;    @Override    public int compare(Person a, Person b) &#123;        return Person.compareName(a, b);    &#125;&#125;)\n\n编译器成功地识别了程序员的意图。但是编译器的聪明程度也是有限的，假如方法引用所对应的静态方法返回值不是 int 而是 boolean，那么编译器无法将该方法引用还原为一个 Comparator 对象，因为它并不知道该返回什么 int 值。幸亏我们提供的静态方法引用有 int 类型的返回值，编译器还原时就可以把它返回。\n指向某个对象的实例方法的引用形式：containingObject::instanceMethodName\n有一个比较器，它可以比较多种对象：\npublic class Comparator() &#123;    public int comarePerson(Person a, Person b) &#123;        return a.getName().compareTo(b.getName());    &#125;        public int compareDog(Dog a, Dog b) &#123;        return a.getName().compareTo(b.getName());    &#125;        ......&#125;\n\n上面的 Dog 类和 Person 类结构相似，所以代码就省略了。现在我们要根据一群狗的名字给它们排序，我们同样使用方法引用（当然，你依旧可以用 lambda 表达式），但是这次是 指向某个对象的实例方法的引用：\nComparator aComparator = new Comparator(); // 实例化一个比较器// aComparator::compareDog 是指向实例对象 aComparetor 的实例方法// compareDog() 的方法引用Arrays.sort(dogs, aComparator::compareDog); \n\ncompareDog() 方法的两个参数是 Dog 类型，返回值为 int，也就是说 aComparator::compareDog 有两个 Dog 类型的不确定量和一个 int 类型的返回值。而 Comparator 中的 compare() 方法也是接受两个 Dog 对象，返回一个 int 值。根据这些线索编译器足够推断出我们的意图：\nArrays.sort(dogs, new Comparator() &#123;    @Override    public int compare(Dog a, Dog b) &#123;        return aComparator.compareDog(a, b);    &#125;&#125;);\n\n指向某个类型的实例方法的引用形式：ContainingClass::instanceMethodName\nStream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).reduce(&quot;&quot;, new BinaryOperator() &#123;    @Override    public String apply(String a, String b) &#123;        return a.toUpperCase() + b.toUpperCase();    &#125;&#125;);\n\nreduce() 方法是把某类型对象的集合降解为一个对象，过程是两两合并。它的第一个参数为初始值，第二个参数是一个接口，用来定义两两合并的具体策略。如果你暂时不懂 Stream 以及它的 reduce() 方法也没关系，我们只关注它的第二个参数。我们实现 BinaryOperator 接口的方法是把两个字符串变成大写后连接起来。代码看起来很臃肿，但是没有办法，我们没有合适的方法引用来将它简化（现有方法中没有能够将两个字符串先转换成大写然后连接的，当然你可以自己实现一个这样的方法，但没必要，因为这样会使得代码更加复杂），顶多可以转化成 lambda 表达式：\nStream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).reduce(&quot;&quot;, (a, b) -&gt; &#123;        return a.toUpperCase() + b.toUpperCase();    &#125;&#125;);\n\n但是如果两两合并的方式是直接将两个字符串连接的话，情况就不同了。我们可以用 String::concat 这个 指向某个类型的实例方法的引用 来使代码更简洁：\nStream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).reduce(&quot;&quot;, String::concat);\n\n编译器看看这行代码，愣了一下，不知道如何转化。还好，我们的编译器足够聪明，眼珠一转分析了下：我们要实现的方法有两个 String 的参数，一个 String 类型的返回值，而 String::concat 也有两个 String 类型的不确定量和一个 String 类型的返回值，其中一个不确定量是由于 concat() 这个方法是实例方法导致的，因为它必须通过一个 String 实例来调用；另一个不确定量为 concat() 方法的参数，它接受一个 String 类型的参数。以上信息足够编译器来推断我们的意图：程序员一定是想把两个参数和 String::concat 的两个不确定量对应起来，一个作为 concat() 方法调用的接收者，一个作为 concat() 方法的参数。这样一来上面的代码就转化成这样了：\nStream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).reduce(&quot;&quot;, new BinaryOperator() &#123;    @Override    public String apply(String a, String b) &#123;        return a.concat(b);    &#125;&#125;);\n\nWonderful ！程序员正是这么想的。有心的程序员可能会发出疑问：根据编译器的推断思路，对于任意一个方法引用，是不是只要它有两个 String 类型的不确定量和一个 String 类型返回值（当然类型要为 String）就可以作为参数传入 reduce() 了呢？于是程序员想了个方法来测试：\nStream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).reduce(&quot;&quot;, Test::test);public class Test &#123;    public static String test(String a, String b) &#123;        return a.concat(b);    &#125;&#125;\n\n程序员在 IDE 中写下上面的代码后，编译器没有错误提示 &#x3D;&gt; 编译后通过 &#x3D;&gt; 猜想正确。原因是 Test 的 test() 是一个静态方法，它有两个 String 类型的参数，一个 String 类型的返回值，也就是说 Test::test 有两个 String 类型的不确定量和一个 String 类型的返回值，因此编译器推断出程序员的意图是：\nStream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).reduce(&quot;&quot;, new BinaryOperator() &#123;    @Override    public String apply(String a, String b) &#123;        return Test.test(a, b);    &#125;&#125;);\n\n指向构造方法的引用形式：ClassName::new\nStream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).toArray(new IntFunction&lt;String[]&gt;() &#123;     @Override     public String[] apply(int value) &#123;         return null;      &#125;&#125;);\n\ntoArray() 方法的作用是把数据流转换成一个数组，它接收的参数是一个 IntFunction 的接口实现对象。该接口有一个待实现的方法 apply()，它有一个 int 型的参数和一个 String[] 类型的返回值。我们依旧可以用方法引用来代替它，但这次我们用的是 指向构造方法的引用：\nStream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).toArray(String[]::new);\n\n指向构造方法的引用可能较其他方法引用难理解一点，但是编译器却很机智的猜测到了程序员的意图：String[]::new 这个 指向构造方法的引用 有一个 int 类型的不确定量，即数组的长度；有一个 String[] 类型的返回值（构造方法不会有返回值，但是指向构造方法的引用却返回了一个该类型的实例）。因此编译器这样还原此方法引用：\nStream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).toArray(new IntFunction&lt;String[]&gt;() &#123;    @Override    public String[] apply(int value) &#123;        return new String[value];    &#125;&#125;)\n\n总结其实，JVM 本身并不支持指向方法引用，过去不支持，现在也不支持。Java 8 对方法引用的支持知识编译器层面的支持，虚拟机执行引擎并不了解方法引用。编译器遇到方法引用的时候，会像上面那样自动推断出程序员的意图，将方法引用还原成 接口实现对象，或者更形象地说，就是把方法引用设法包装成一个接口实现对象，这样虚拟机就可以无差别地执行字节码文件而不需要管什么是方法引用了。\n需要注意的是，方法引用是用来简化接口实现代码的，并且凡是能够用方法引用来简化的接口，都有这样的特征：有且只有一个待实现的方法。这种接口在 Java 中有个专门的名称： 函数式接口。当你用试图用方法引用替代一个非函数式接口时，会有这样的错误提示： xxx is not a functional interface。\n文章中很多地方提到过 不确定量 这个名词，这个名词并非官方的，而是我为了更好地说明问题而引入的，它的意思是： 方法引用在转换成接口实现对象的过程中需要确定的变量。如 方法引用所对应方法的接受者（ 指向静态方法的引用 和 指向某个对象的实例方法的引用 没有该不确定量，因为前者不需要接受者，而后者接受者已经确定），以及 方法引用所对应方法的参数 都属于 不确定量。方法引用的 不确定量 以及返回值需要和接口中的待实现方法的参数和返回值对应起来，这样编译器才能成功将其还原。\n感谢阅读写这篇文章的目的是让大家对方法引用有一个更好的理解，同时也作为个人的学习记录，但由于理解和水平有限，差错在所难免，还请大家不吝赐教。最后，感谢大家的阅读。\n参考文章:Method References:: (double colon) operator in Java 8  \n","tags":["Java","Method Reference"]},{"title":"操作系统原理总结","url":"/2017/05/30/2017-05-30-operating-system-conclusion/","content":"操作系统原理总结对课本知识的概括和总结，来自《操作系统原理》第四版 —— 庞丽萍著\n\n用户环境操作系统的生成：\n\n系统生成\n\n根据计算机的硬件配置选择相应的功能模块来组装成一个可利用的操作系统\n\n硬件配置信息可通过从文件读取或者系统程序员\n\n系统初启\n\n引导程序 &#x3D;&gt; 系统核心 &#x3D;&gt; 核心初始化\n\n核心初始化：先建立 0# 进程（永远处于核心态，换页），再建立 1# 进程（初始化进程，实现系统初始化，负责为终端建立子进程）\n\n用户程序的运行过程\n\n编写源程序\n\n将源程序记录在某种介质上\n\n控制计算机工作，加工，得到计算结果\n\n编译\n链接\n静态链接：将外部调用函数链接到目标文件中形成一个完整的主存映像文件\n动态链接：运行时将动态链接库加载并链接到目标程序中\n\n\n运行\n\n\n操作系统的用户界面\n\n定义：用户和计算机打交道的外部机制。和用户上机类型和操作系统的的类型有关\n\n系统提供的用户界面：操作命令、系统功能调用\n\n系统功能调用\n\n用户程序调用系统例程，由用户态进入管态\n\n系统调用的实现：用户程序（用户态） &#x3D;&gt; 发出自愿访管命令 &#x3D;&gt; 访管中断程序保护现场，查找例行子程序入口地址表获取系统例程的入口地址 &#x3D;&gt; 根据入口地址进行系统调用（管态） &#x3D;&gt; 结果返回访管中断程序 &#x3D;&gt; 恢复用户程序现场（用户态）\n\n\n并发处理提高计算机的处理能力和机器的利用率，但容易造成错误。\n\n并发的特点\n\n失去程序的封闭性：计算结果不再和时间无关，依赖于各程序的相对执行速率\n\n程序和计算不再一一对应：过个计算可以公用一个程序\n\n程序并发执行的相互制约\n\n进程\n\n进程的定义\n\n一个程序在给定的空间和初始环境下，在一个处理机上的执行过程\n进程是指一个具有一定独立功能的程序关于某个数据集合的一次运行活动\n\n\n进程和程序的区别：\n\n程序是指令的有序集合，其本身没有任何运行的含义，它是一个静态的概念，可永久保存\n进程是程序（指令）在处理机上的一次执行的过程，是动态的概念，有生命周期，动态地产生和消亡\n进程是独立运行的单位，能与其他进程并行的活动\n进程是竞争计算机系统有限资源的基本单位，也是进行处理机调度额基本单位\n多任务的操作系统中，活动的最小单位是进程，进程一定包含一个程序，程序是进程应完成的功能的逻辑描述；一个程序可以多应多个进程\n\n\n进程的类型\n\n用户进程：为用户算题任务建立的进程\n系统进程：资源管理和控制作用\n\n\n进程的状态\n\n进程的基本状态：等待状态&#x3D;&gt;就绪状态&lt;&#x3D;&gt;运行状态&#x3D;&gt;等待状态\n\n\n进程的描述：进程控制块，是一个和进程对应的实体，记录进程的各种状态信息\n\n线程概念及特点\n\n什么是线程\n线程是比进程更小的活动单位，它是进程中的一个执行路径。一个进程可以有多条的执行路径，每条路径就是一条线程\n线程有自己的堆栈和处理机执行环境（尤其是处理器寄存器）\n共享分配给父进程的主存\n若系统支持线程运行，那么每个进程至少有一个执行线程\n\n\n\n\n线程的特点及状态\n\n线程的特点\n开销小，共享进程的程序和全局数据\n可以提高系统的并行处理能力\n线程拥有私有的指令计数器、私有的栈区、私有的寄存器集合和地址区域\n\n\n\n\n线程的状态以及变迁\n\n创建，建立一个新的线程，新生的线程处于新建状态\n就绪，线程处于就绪队列中，等待被调度      \n运行，一个线程正占用 CPU，执行它的程序\n等待，一个正在执行的线程如果发生某些事件，如被挂起或者需要执行费时的输入输出操作\n终止，线程已经退出，但该信息还没有被其他线程所收集\n\n\n用户线程和内核线程\n\n用户线程是在内核的支持下，在用户层通过线程库来实现的。线程库提供对线程的创建、调度和管理等方面的支持。用户线程对内核来说是透明的，即内核并不知道线程的存在。相当于在单线程的进程中模拟多线程，这种线程不是 CPU 调度的单位，调度单位依然是线程\n内核线程是内核可感知的，由操作系统直接支持，在内核空间内执行线程的创建、调度和管理\n内核线程的创建、调度以及管理要比用户线程慢\n\n\n进程控制\n\n进程的创建（linux 中 fork，vfork，clone 的区别）、撤销、阻塞、唤醒\n\n进程的相互制约关系\n\n进程竞争与合作\n\n竞争系统资源\n进程间合作：信息共享；并行处理\n\n\n进程互斥的概念\n\n临界资源：共享硬件资源、共享公用变量、共享表格等\n临界区：各个进程访问临界资源的那段程序\n在有限时间内进入临界区\n至多有一个进进程处于临界区\n进程在临界区内仅逗留有限的时间\n\n\n互斥：若干进程能够访问和修改的存储单元称为公共变量，公共变量或公共存储区一次只能被一个进程读写\n\n\n进程同步的概念\n\n同步的例子：病人看病，医生开化验单，病人拿化验单去化验，将化验结果交给医生\n\n\n同步机构\n\n锁：上锁原语&amp;开锁原语\n\n原语的概念：不可分割的一系列操作。在单处理机上，该功能由操作系统提供支持，即软件方法实现，使得某进程在执行某原语所包含的一系列指令执行时不被中断。在多核处理机上必须要由硬件支持。详见 stackoverflow、Linux内核同步原语之原子操作、百度百科-原子操作、并行编程3——内存模型之原子性\n\n单处理器上的原语靠操作系统实现，即使该原语由一系列的指令完成，但只要操作系统不把线程中断（如线程调度）即可保证这一系列指令的原子性；此时其他线程等待的是时间片（处于就绪态）\n多处理器上的原语靠硬件实现，如果某原语由一系列的指令完成，即使执行该原语的线程在其运行的 CPU 上不被调度（或者说被中断），其他 CPU 上可能会有线程操作该原语对应的内存区域，此时并不能保证该 “原语” 的原子性，此时就需要 CPU 提供 LOCK 指令使得原语所操作的内存被锁上，那么其他 CPU 上在线程就不能操作该内存了，从而保证了原语的原子性，此时这些线程等待的是 UNLOCK 指令（处于阻塞状态）\n总的来说原语就是要保证相同内存只能被一个线程所操作\n\n\n信号灯以及 P、V操作\n\n信号灯：从交通管理应用过来的一个术语，绿灯行（信号量非负），红灯停（信号量小于零）\nP、V操作：P 操作和 V 操作都为原语\nP 操作使得信号量减 1，如果信号量此时大于等于 0，那么进程继续；否则进入该信号灯的等待队列中\nV 操作使得信号量加一，如果此时信号量大于零进程继续；如果小于零，说明有进程处于等待队列中，因此需要从等待队列中唤醒一个进程（原因：该进程由于等待而挂起，并不能自己唤醒自己）\n\n\n\n\n进程互斥与同步的实现\n\n互斥的实现：1) 上锁原语、开锁原语； 2)信号灯\n\n同步的实现：信号灯以及 P、V 操作\n\n生产者消费者问题\n病人看病问题\n\n\n\n//病人看病main() &#123;    int s1 = 0; // 表示有无化验单的信号量，初始值为 0，表示没有    int s2 = 0; // 表示有无化验结果的信号量，初始值为 0，表示没有    cobegin                     labora();                  diagnosis();            coend&#125;labora() &#123;    while(化验为完成) &#123;        p(s1); // 询问有无化验单，无则等待        化验;        V(s2); // 送出化验结果    &#125;&#125;diagnosis() &#123;    while(看病工作未完成) &#123;        看病；        V(s1); // 送出化验单        P(s2); // 等化验结果        diagnosis; // 诊断     &#125;&#125;// 生产者消费者main() &#123;    int full = 0; // 满缓冲区数目    int empty = n; // 空缓冲区树木    int mutex = 1; // 对有界缓冲区进行操作的互斥信号灯    cobegin        p1();p2();...;pm(); // 生产        c1();c2();...;ck(); // 消费    coend&#125;producer() &#123;    while(生产未完成) &#123;           .           .        生产一个产品；        P(empty);        P(mutex);        送一个产品到有界缓冲区;        V(mutex);        V(full);    &#125;&#125;consumer() &#123;    while(还要继续消费) &#123;        P(full);        P(mutex);        从有界缓冲区中取出产品；        V(mutex);        V(empty);           .           .        消费一个产品;    &#125;       &#125;\n\n\n进程通信\n拷贝消息到另一个进程的地址空间\n信箱通信，进程 A 投递消息到进程 B 的信箱中；进程 B 投递从自己的信箱中获取消息。信箱可位于 B 的空间，也可位于系统空间\nsend 原语：可同步可异步，同步需等待对方接受；异步不关心对方是否接受\nreceive 原语：可以阻塞或非阻塞，如果阻塞，信息到来之前接收进程挂起；如果非阻塞，有消息将消息立即返回，无消息返回标志，表示没有消息可用\n\n\n\n\n\n资源分配与调度\n资源管理概述\n资源管理的目的和任务\n资源的静态分配和动态分配：运行前一次性分配为静态分配；运行时根据运行情况动态的分配为动态分配\n资源分配的目标\n保证资源的高利用率\n在合理的时间内使所用的用户有获得所需资源的机会\n对不可共享的资源实施互斥使用\n防止由资源分配不当而引起的死锁\n\n\n资源管理的任务\n资源数据结构的描述：资源物理名、逻辑名、类型、地址、分配状态等\n确定请求的分配原则和调度原则：资源分给谁，何时分配，分配数量\n资源分配的执行：按需分配资源，回收资源\n存取控制和安全保护\n\n\n\n\n资源的分类方法\n物理资源和程序资源：各种硬件资源为物理资源，系统服务、文件等为程序资源\n单一访问入口资源和多访问入口资源：单访问入口资源一次只能一个进程用，多访问入口资源一次允许多个进程用\n等同资源：多个资源的实例，如磁盘的各个扇区\n虚拟资源：如虚拟主存，虚拟 CPU 等\n\n\n资源分配机制\n资源描述器：描述资源最小分配单位的信息，如资源名、资源类型、分配标志等\n资源信息块（rib）\n等待队列头指针：指向等待该资源的的进程队列\n可利用资源队列头指针：指向资源描述器组成的队列\n资源分配程序入口地址：执行分配任务，把对应的资源分配给请求者\n\n\n资源分配策略\n先请求先服务（先进先出，FIFO）\n优先调度（针对处理机而言）：优先照顾需要尽快处理的作业或进程\n针对设备特性的调度：如对磁盘资源的请求会考虑移臂距离和旋转次数\n死锁\n同类资源的死锁：A、B 为两个进程，C 资源两个实例，A、B 各自拥有一个 C 资源的实例，它们不释放已有的资源实例，并且继续申请 C 资源，此时产生同类资源的死锁\n非同类资源的死锁：A、B 为两个进程，C、D 两个资源各有一个实例。A 占有 C 资源，B 占有 D 资源，它们都不释放已有的资源，同时 A 申请 D 资源，B 申请 C 资源，此时产生非同类资源的死锁\n死锁的原因和条件\n产生死锁的根本原因：系统提供的资源数少于申请该资源的数目\n产生死锁的必要条件：\n互斥条件：资源为非共享的，或者说单一入口资源\n不剥夺条件：资源使用完之前，其他进程不能强行剥夺其他进程的资源\n占有并等待：进程申请其他资源时，不会释放已占有的资源\n环路条件：A 进程需要的资源被 B 进程占有，而 B 进程需要的资源被进程 C 占有 …… * 进程需要的资源被 A 进程占有\n\n\n\n\n死锁的解决策略\n破坏死锁的必要条件之一\n\n\n死锁的避免：\n静态预防：从根源避免死锁，作业在运行前说明所需要的所有资源，如果系统能够提供，那么投入运行，否则不能投入运行\n动态避免\n有序资源分配法：给资源标序号，一个进程对于同类资源需一次性申请完，对不同类资源需要按序申请。该方法避免死锁的原因：每一时刻，总有一个进程 A 占有已分配资源中序号最高的那一个，此进程继续申请的资源的序号必定更高，这些资源必定处于空闲，因此进程 A 可以推进，在执行完后释放已有资源；进程 A 执行完后，又有一个进程 B 和进程 A 之前的状态一样，占有已分配资源中序号最高的那一个，于是 B 进程也可顺利执行结束；以此类推，所有进程都可顺利执行而不会发生死锁\n银行家算法：某个进程将来需要的各类资源当前系统能够满足，则将此进程投入运行。该方法避免死锁的原因：（1）进程 A 在运行时最多需要 5 个资源 B，此时系统拥有 B 的实例有 10 个，满足条件，将 A 投入运行，A 暂时只用到了 2 个 B 资源实例；（2）此时 C 进程想投入运行，它所需资源 B 的最大个数为 7 个，而系统此时有 8 个，故 C 投入运行，C 暂时只用了 6 个；（3）A 此时又想获取 3 个 B 实例，但是 B 资源只有 2 个不够，于是等待；（4）C 再次申请 1 个资源，成功，C 执行完毕并释放所有 B 资源实例；（4）A 获得 2 个资源，执行完毕后释放所有 B 资源实例。该算法成功避免死锁的原因在于后来的申请者一定会释放所申请资源，使得系统所拥有资源量符合对较早申请者的承诺。\n\n\n\n\n\n处理机调度\n处理机的多级调度\n\n批处理中的处理机调度\n\n先作业调度（宏观调度）：根据一定的策略挑选作业，建作业对应的进程，使其投入运行\n后进程调度（微观调度）：对于进入主存的进程的调度，什么时候把处理机分配给该进程\n\n\n多任务操作系统的处理机调度：处理机空闲时，选择一个就绪的进程投入运行\n\n多线程操作系统的处理机调度：处理机空闲时，选择一个就绪的线程投入运行\n\n作业调度\n\n作业的状态：后备状态（进入磁盘队列），执行状态（进入主存执行），完成状态（从完成到善后处理结束并退出）。\n\n作业调度的功能：确定数据结构，确定调度算法，资源分配，善后处理\n\n作业控制块：记录作业的有关信息，如作业名、作业类型、作业状态、作业对资源的要求等\n\n调度算法的衡量：平均周转时间和平均带权周转时间\n\n平均周转时间为各个作业从进入磁盘到完成作业所花时间的平均值\n平均带权周转时间为各个作业的周转时间和运行时间（不包括在磁盘队列中的等待时间）的比值的平均值\n\n\n作业调度算法\n\n先来先服务（FIFO）：考虑等待时间\n\n短作业优先：运行所花时间最短的作业优先执行，考虑运行时间\n\n相应比高者优先：（等待时间／运行时间） 最大者优先，同时考虑等待时间和运行时间\n\n优先调度算法：给各个作业分配优先数，优先数高者优先执行，优先数 &#x3D; waiting_time2 - running_time - 16 * output\n\n进程调度\n\n进程调度的功能和准则\n\n功能\n\n\n\n主存管理未完待续。。。\n","tags":["操作系统"]},{"title":"Glide 之磁盘缓存","url":"/2017/08/29/2017-08-29-glide-disk-cache-strategy/","content":"Glide 之磁盘缓存Glide 提供了灵活的磁盘缓存策略，用户可以定义自己的缓存策略，只需要实现 DiskCache 接口即可。Glide 中已经有两个 DiskCache 实现，一个是 DiskCacheWrapper，这个类什么都没干，就是一个空壳，用来包装其他的 DiskCache 实现类；另一个类是 DiskLruCaheWrapper，它是基于 DiskLruCache 实现的。接下来从 DiskLruCahce 分析一下 Glide 的磁盘缓存。\n\n磁盘缓存核心 —— DiskLruCahceDiskLruCache 的分析分为两部分：分别是日志，读、写缓存。\n日志DiskLruCache 的日志就是一个操作记录。例如，删除一条缓存条目，就会在日志文件中记录一条 REMOVE 记录；新建一条缓存，缓存文件刚建立时会增加一条 DIRTY 记录，缓存写入成功后再增加一条 CLEAN 记录；缓存被读取，会增加 READ 记录。日志文件的格式如下：\n\n\n\n记录类型\nkey\nlength1\nlength2\n\n\n\nCLEAN\n3400330d1dfc7f3f7f4b8d4d803dfcf6\n832\n21054\n\n\nDIRTY\n335c4c6028171cfddfbaae1a9c313c52\n\n\n\n\nCLEAN\n335c4c6028171cfddfbaae1a9c313c52\n3934\n2342\n\n\nREMOVE\n335c4c6028171cfddfbaae1a9c313c52\n\n\n\n\nDIRTY\n1ab96a171faeeee38496d8b330771a7a\n\n\n\n\nCLEAN\n1ab96a171faeeee38496d8b330771a7a\n1600\n234\n\n\nREAD\n335c4c6028171cfddfbaae1a9c313c52\n\n\n\n\nREAD\n3400330d1dfc7f3f7f4b8d4d803dfcf6\n\n\n\n\n之所以记录日志，就是为了在 DiskLruCache 初始化时建立起缓存的 LRU 结构。DiskLruCache 内部使用了 lruEntries:LinkHashMap 来存储所有的缓存项，在初始化的时候，DiskLruCache 会读日志文件上的记录，根据该日志文件的记录将所有历史操作“重做”一遍：在执行历史操作时，会根据日志记录对缓存项进行添加和删除操作。为什么这样能保证缓存项是按 LRU 的顺序排序的呢？因为构造 LinkedHashMap 的时候选择使用 Access Order（访问顺序）来保持元素的顺序，因此只需遍历日志根据日志记录向 LinkedHashMap 中放入缓存项（Entry）自然而然地就保持了 LRU 的顺序。读区日志记录的文件如下：\nprivate void readJournalLine(String line) throws IOException &#123;  int firstSpace = line.indexOf(&#x27; &#x27;);  if (firstSpace == -1) &#123;    throw new IOException(&quot;unexpected journal line: &quot; + line);  &#125;  int keyBegin = firstSpace + 1;  int secondSpace = line.indexOf(&#x27; &#x27;, keyBegin);  final String key;  if (secondSpace == -1) &#123;    key = line.substring(keyBegin);    if (firstSpace == REMOVE.length() &amp;&amp; line.startsWith(REMOVE)) &#123;      lruEntries.remove(key);      return;    &#125;  &#125; else &#123;    key = line.substring(keyBegin, secondSpace);  &#125;  Entry entry = lruEntries.get(key);  if (entry == null) &#123;    entry = new Entry(key);    lruEntries.put(key, entry);  &#125;  if (secondSpace != -1 &amp;&amp; firstSpace == CLEAN.length() &amp;&amp; line.startsWith(CLEAN)) &#123;    String[] parts = line.substring(secondSpace + 1).split(&quot; &quot;);    entry.readable = true;    entry.currentEditor = null;    entry.setLengths(parts);  &#125; else if (secondSpace == -1 &amp;&amp; firstSpace == DIRTY.length() &amp;&amp; line.startsWith(DIRTY)) &#123;    entry.currentEditor = new Editor(entry);  &#125; else if (secondSpace == -1 &amp;&amp; firstSpace == READ.length() &amp;&amp; line.startsWith(READ)) &#123;    // This work was already done by calling lruEntries.get().  &#125; else &#123;    throw new IOException(&quot;unexpected journal line: &quot; + line);  &#125;&#125;\n\n这个方法根据记录类型进行缓存的添加和删除：读取到 REMOVE 记录便从 lruEntries 删除对应的缓存项；然后通过 lruEntries.get() 方法尝试获取键值为 key 所对应的缓存项，如果不存在便新建一个并放入 lruEntries 中；判断记录的类型是不是 CLEAN 类型，是则对 entry 的 readable 和 currentEditor 字段进行更新，表示该缓存可供读取；如果类型是 DIRTY 类型，那么为 currentEditor 赋值；如果时 READ 记录，那么什么也不干，原因在注释里已经写明了：因为前面调用 lruEntries.get() 方法时，已经是对缓存元素进行了一次访问，因此可以保证这个被访问的元素排在最前面，即保证了元素按照 LRU 的次序排列。\n读取完之后还会对 lruEntries 中的元素进一步处理：\nprivate void processJournal() throws IOException &#123;  deleteIfExists(journalFileTmp);  for (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) &#123;    Entry entry = i.next();    if (entry.currentEditor == null) &#123;      for (int t = 0; t &lt; valueCount; t++) &#123;        size += entry.lengths[t];      &#125;    &#125; else &#123;      entry.currentEditor = null;      for (int t = 0; t &lt; valueCount; t++) &#123;        deleteIfExists(entry.getCleanFile(t));        deleteIfExists(entry.getDirtyFile(t));      &#125;      i.remove();    &#125;  &#125;&#125;\n该方法会将其中 currentEditor 不为 null 的 entry 全部删除。原因就是这些缓存项是脏数据，是上次缓存未成功提交的结果。一般来说，一条 DIRTY 记录后会紧跟着一条 key 值相同的 CLEAN 或者 REMOVE 记录，这表明了缓存经历了从被写入到之后成功提交或者删除的过程，这样一来，lruEntries 中要么就不存在该记录对应的 Entry 对象，要么该 Entry 对象的 currentEditor 为 null，即该缓存项有效。如果不清楚这一点可以先往下读再回来理解。\n现在，假设有如下日志记录：\nDIRTY KEY1；CLEAN KEY1；DIRTY KEY2；CLEAN KEY2；DIRTY KEY3；CLEAN KEY3；READ KEY3；READ KEY2 ；DIRTY KEY4；CLEAN KEY4；REMOVE KEY1\n这个日志反映的历史操作是：首先依次建立了 key 分别为 KEY1，KEY2，KEY3 的三个缓存文件，然后读取了 key 为 KEY2 和 KEY3 的两个文件，之后又建立了 key 为 KEY4 的文件，最后删除了 key 为 KEY1 的那个缓存文件。这样一来读取该日志文件时 LinkHashMap 添加和删除缓存项的过程就是这样的：首先依次添加 KEY1，KEY2，KEY3 对应的缓存项，再依次分别读取一次 KEY3，KEY2 对应的缓存项，再添加 KEY4 对应的缓存项，最后删除 KEY1 对应的缓存项。最终 lruEntries 中的缓存项的顺序为：KEY3，KEY2，KEY4，其中 KEY4 排在最前面，即最不容易被淘汰。\n读写缓存首先看 DiskLruCache 读缓存的方式：\nDiskLruCache cache = DiskLruCache.open(directory, appVersion, valueCount, maxSize);Value v = cache.get(key);File cacheFile = v.getFile(0);......\nDisLruCache 的 open() 方法有四个参数：第一个参数是缓存文件的根目录，第二个是应用版本号，第三个是一个 key 对应的缓存文件数目（一般传 1 就可以了，我们通常只需要一份缓存文件），第四个是缓存的最大值，以字节为单位。Value 被称之为“快照”，它包含了缓存项的一些信息，比如缓存项对应的缓存文件。它的 getFile() 方法就是获取该缓存文件，客户端就可以将需要缓存的信息写入该文件。\n写缓存的方式如下：\nEditor editor = cache.edit(key);File cacheFile = editor.getFile(0);...eidtor.commit();\n\n首先调用 edit() 方法开启了在键值为 key 的缓存项上的一次操作，它返回的是一个 Editor 对象，该对象的 getFile() （参数 0 表示的是该 key 对应的缓存项中的第一个缓存文件）方法返回缓存文件供外部执行写缓存操作。需要注意的是，对缓存文件操作完之后需要调用 editor.commit() 方法进行提交，否则这次写在日志文件中只会生成一条 DIRTY 记录与之对应（而不会生成 CLEAN 记录），使得缓存无效。\n现在来看读写缓存的内部原理，首先要理解 DiskLruCache 的几个内部类及其角色。其中一个是 Entry，Entry 代表了一个缓存项，这个缓存项不一定就是一个缓存文件，它对应的是含有相同 key 的所有缓存文件，这些文件有 CLEAN 状态的，也有 DIRTY 状态的。其内部的数据结构大致是这样的：\nclass Entry &#123;    String key; // 缓存项对应的 key    File[] dirtyFiles; // 临时文件，不完整，不可读取，只可写入    File[] cleanFiles; // 完整缓存文件，已缓存完毕，可供读取    long[] lengths; // 完整的缓存文件对应的大小    Editor currentEditor; // 当前在此 Entry 上执行操作的 Editor 对象    ......&#125;\n其构造方法如下：\nprivate Entry(String key) &#123;  this.key = key;  this.lengths = new long[valueCount];  cleanFiles = new File[valueCount];  dirtyFiles = new File[valueCount];  // The names are repetitive so re-use the same builder to avoid allocations.  StringBuilder fileBuilder = new StringBuilder(key).append(&#x27;.&#x27;);  int truncateTo = fileBuilder.length();  for (int i = 0; i &lt; valueCount; i++) &#123;      fileBuilder.append(i);      cleanFiles[i] = new File(directory, fileBuilder.toString());      fileBuilder.append(&quot;.tmp&quot;);      dirtyFiles[i] = new File(directory, fileBuilder.toString());      fileBuilder.setLength(truncateTo);  &#125;&#125;\n它的构造方法利用了 key 去构造那些 File 对象：key.index 就是 Clean File，key.index.tmp 就是 Dirty File。也就是说，在读取日志文件的时候，已经将所有缓存项的对应的缓存文件对象都初始化好了，需要注意的是，这里仅仅是根据文件名来构造相应的缓存文件对象而已，那些 cleanFiles 和 dirtyFiles 并不一定是磁盘上存在的文件。\n另一个类是 Editor，它的内部字段有：\nclass Editor &#123;    Entry entry; //该 Editor 操作的缓存项    boolean[] written; // 完整文件是否被修改    ......&#125;\n\n现在我们看看写缓存文件的过程。首先是获取 Editor 对象：\nprivate synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException &#123;  checkNotClosed();  Entry entry = lruEntries.get(key);  if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == null      || entry.sequenceNumber != expectedSequenceNumber)) &#123;    return null; // Value is stale.  &#125;  if (entry == null) &#123;    entry = new Entry(key);    lruEntries.put(key, entry);  &#125; else if (entry.currentEditor != null) &#123;    return null; // Another edit is in progress.  &#125;  Editor editor = new Editor(entry);  entry.currentEditor = editor;  // Flush the journal before creating files to prevent file leaks.  journalWriter.append(DIRTY);  journalWriter.append(&#x27; &#x27;);  journalWriter.append(key);  journalWriter.append(&#x27;\\n&#x27;);  journalWriter.flush();  return editor;&#125;\n这个方法做的事可以描述如下：先从 lruEntries:LinkedHashMap 中获取缓存项，然后对缓存的 sequenceNumber 进行验证，如果不存在该缓存项，便新建一个。然后由该缓存项构造出一个 Editor 对象，最后记录一条 DIRTY 日志并返回 Editor 对象。获取 Editor 对象后，便可通过其 getFile(0) 方法获取到对应的缓存文件对象：\npublic File getFile(int index) throws IOException &#123;  synchronized (DiskLruCache.this) &#123;    if (entry.currentEditor != this) &#123;        throw new IllegalStateException();    &#125;    if (!entry.readable) &#123;        written[index] = true;    &#125;    File dirtyFile = entry.getDirtyFile(index);    if (!directory.exists()) &#123;        directory.mkdirs();    &#125;    return dirtyFile;  &#125;&#125;\n\ngetFile() 返回的是缓存项的第 index 个临时文件对象，客户端便可由该对象建立输出流将缓存写入文件中。因为是写文件，所以在写的时候可能出现异常中断的现象（应用崩溃、应用进程被杀），因此写完缓存之后需要调用 editor.commit() 来提交本次操作：\npublic void commit() throws IOException &#123;  completeEdit(this, true);  committed = true;&#125;// suecess 为 true 表示提交本次操作，fale 表示放弃本次操作private synchronized void completeEdit(Editor editor, boolean success) throws IOException &#123;  Entry entry = editor.entry;  if (entry.currentEditor != editor) &#123;    throw new IllegalStateException();  &#125;  // If this edit is creating the entry for the first time, every index must have a value.  if (success &amp;&amp; !entry.readable) &#123;    for (int i = 0; i &lt; valueCount; i++) &#123;      if (!editor.written[i]) &#123;        editor.abort();        throw new IllegalStateException(&quot;Newly created entry didn&#x27;t create value for index &quot; + i);      &#125;      if (!entry.getDirtyFile(i).exists()) &#123;        editor.abort();        return;      &#125;    &#125;  &#125;  // 对缓存重命名  for (int i = 0; i &lt; valueCount; i++) &#123;    File dirty = entry.getDirtyFile(i);    if (success) &#123;      if (dirty.exists()) &#123;        File clean = entry.getCleanFile(i);        dirty.renameTo(clean);        long oldLength = entry.lengths[i];        long newLength = clean.length();        entry.lengths[i] = newLength;        size = size - oldLength + newLength;      &#125;    &#125; else &#123;      deleteIfExists(dirty);    &#125;  &#125;  redundantOpCount++;  entry.currentEditor = null;    // 记录日志  if (entry.readable | success) &#123;    entry.readable = true;    journalWriter.append(CLEAN);    journalWriter.append(&#x27; &#x27;);    journalWriter.append(entry.key);    journalWriter.append(entry.getLengths());    journalWriter.append(&#x27;\\n&#x27;);    if (success) &#123;      entry.sequenceNumber = nextSequenceNumber++;    &#125;  &#125; else &#123;    lruEntries.remove(entry.key);    journalWriter.append(REMOVE);    journalWriter.append(&#x27; &#x27;);    journalWriter.append(entry.key);    journalWriter.append(&#x27;\\n&#x27;);  &#125;  journalWriter.flush();  if (size &gt; maxSize || journalRebuildRequired()) &#123;    executorService.submit(cleanupCallable);  &#125;&#125;\n这个方法的逻辑是：先校验一下是不是只有一个 Editor 在操作该缓存项（保证同一时刻一个缓存项上只能有一个写操作），然后判断该缓存项是不是新建的，如果是，那么是不是该缓存项对应的所有的临时缓存文件都存在并且都被写过，如果不是，那么放弃这次操作。验证工作做完后就是重命名的过程了，接下来会把所有的该缓存项的所有实际存在的临时文件的名称都重命名为对应的完整文件的名称（即把后面的 .tmp 后缀去除）。最后就是记录日志，如果成功提交本次操作，那么记下一条 CLEAN 日志，如果选择放弃本次操作，那么记下 REMOVE 日志。通过这个方法可以知道，如果客户端写完缓存后没有调用 Editor#commit() CLEAN 记录是不会被记下的，因此下次读取日志文件的时候，会把该缓存项删除，原因前面已经讲了。\n如果缓存一直持续下去，是不是日志记录越来越大呢？答案是否定的，日志文件有一个上限，如果超过该上限便会重建。同样的，lruEntries 中的缓存项也不会无限增长，它受 maxSize 参数的限制，如果容量太大，便会从 LruEntries 中删除最久未被使用的缓存项，并将结果反映到磁盘上的缓存文件上，具体的细节这里就不再讲述了。\n感谢阅读以上便是对 Glide 磁盘缓存的核心类 DiskLruCache 的分析，如有不对还请大家不吝赐教。\n","tags":["Android","开源库"]},{"title":"Android 进程启动原理","url":"/2017/08/29/2017-08-29-how-an-android-process-starts/","content":"Android 进程启动原理前言Android 中的应用是支持多进程的，我们只要在 AndroidManifest 中给四大组件指定 android:process 属性即可让其运行在独立的进程当中。那么应用的主进程又是如何被创建的呢？一般来说，当我们的应用没有任何组件处于运行状态，此时其他应用启动我们应用的组件时，应用的主进程就会被创建，进程相当于是提供了组件运行的空间。最常见的触发应用主进程被创建的方式是应用 A 通过 startActivity 或者 startActivityForResult 启动应用 B，并且应用 B 此时没有任何组件处于运行状态，那么系统先会通过 AMS 为 B 创建一个进程，等进程创建好了再通知应用 B 创建并运行该 Activity。AMS 是运行在 system_server 进程当中的，这个进程并不会 fork 出应用进程，那么应用进程到底是哪个进程创建的呢？这就得从 Zygote 进程说起。\n\nZygote 进程zygote 进程的启动Zygote 的中文意思是“受精卵”，它的字面意思很形象的概括了 Zygote 进程在 Android 系统中的作用——“分裂”出其他进程。Zygote 进程是所有 Android 应用的父进程，并且还是 system_server 的父进程。由此看来，Zygote 进程在 Android 系统中发挥了举足轻重的作用。但是 Zygote 并不是 Android  系统中的第一个进程，它也是其他进程 fork 来的，这个进程就是 init 进程，它是用户空间的第一个进程。init 进程就是用来解析并执行 init.rc 配置文件的，这个文件位于系统根目录下，这个配置文件中会导入其他的配置文件如 init.zygote32.rc 或者 init.zygote64_32.rc，具体导入哪一个由 ro.zygote 的值决定。这两个配置文件的作用就是启动 Zygote 进程。在 init.zygote32.rc 中，启动 Zygote 的语句如下：\nserivce zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server\tclass main\tsocket zygote stream 660 root system\tonrestart write /sys/android_power/request_state wake\tonrestart write /sys/power/state on\tonrestart restart media\tonrestart restart netd\n\n我们主要看 service 块的第一行，这行命令的语义是：启动一个名为 zygote 的服务，这个服务的可执行文件路径是 &#x2F;system&#x2F;bin&#x2F;app_process。后面跟的都是 app_process 这个可执行文件的参数。app_process 对应的源码文件为你 app_main.c，这个源码文件的 main() 方法中有对这些参数的解释：以 - 开头的都是虚拟机参数，这些参数会传入即将要启动的虚拟机中；接下来是运行目录，有点类似终端执行命令时的当前目录，在这里是 &#x2F;system&#x2F;bin；接下来是一些以 – 开头的参数，这些参数表示启动参数，“–zygote” 表示启动的是 zygote 进程，“–application”表示启动的是普通 Java 进程，“–start-system-server” 表示要启动 system_server 进程，“–nice-name”用来指定进程的名字。接下来的参数指明的是要启动的 Java 类，如果前面使用了 “–zygote“参数，那么启动的就是 zygote 进程，这里就可以不指明，因为 zygote 进程默认就是执行 ZygoteInit 类，如果使用了 “–application”，那么启动的就是普通的 Java 进程，这里需要指明要执行的 Java 主类；接下来的参数是都是传入该主类的参数，这些参数只有启动的是普通 Java 进程时才有用。\napp_main.c 的 main() 方法的主要逻辑都是在解析相应的参数，它对参数的的解析主要分为以下几个步骤：\n\n创建 AppRuntime 并解析虚拟机参数：\n\nint main(int argc, char* const argv[])&#123;    ......    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));    // Process command line arguments    // ignore argv[0]    argc--;    argv++;    int i;    for (i = 0; i &lt; argc; i++) &#123;        if (argv[i][0] != &#x27;-&#x27;) &#123;            break;        &#125;        if (argv[i][1] == &#x27;-&#x27; &amp;&amp; argv[i][2] == 0) &#123;            ++i; // Skip --.            break;        &#125;        runtime.addOption(strdup(argv[i])); //将有效参数加入到虚拟机参数表中    &#125;    ......&#125;\n\n\n解析启动参数\n\nint main(int argc, char* const argv[]) &#123;\t\t......    while (i &lt; argc) &#123;        const char* arg = argv[i++];        if (strcmp(arg, &quot;--zygote&quot;) == 0) &#123;            zygote = true;            niceName = ZYGOTE_NICE_NAME;        &#125; else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) &#123;            startSystemServer = true;        &#125; else if (strcmp(arg, &quot;--application&quot;) == 0) &#123;            application = true;        &#125; else if (strncmp(arg, &quot;--nice-name=&quot;, 12) == 0) &#123;            niceName.setTo(arg + 12);        &#125; else if (strncmp(arg, &quot;--&quot;, 2) != 0) &#123;            className.setTo(arg); // 解析到了主类名，说明启动的是普通 Java 程序            break;        &#125; else &#123;            --i;            break;        &#125;    &#125;    ......&#125;\n\n\n准备要执行的主类的参数，这里的主类只有“ZygoteInit” 和 “RuntimeInit”两种\n\nint main(int argc, char* const argv[]) &#123;\t\t......    Vector&lt;String8&gt; args;    if (!className.isEmpty()) &#123;    \t // 非 zygote 模式，我们需要将后面的参数传入 AppRuntime 中保存，而不是传入 RuntimeInit 中        args.add(application ? String8(&quot;application&quot;) : String8(&quot;tool&quot;));        runtime.setClassNameAndArgs(className, argc - i, argv + i);    &#125; else &#123;        // zygote 模式        maybeCreateDalvikCache();        if (startSystemServer) &#123;            args.add(String8(&quot;start-system-server&quot;));        &#125;        char prop[PROP_VALUE_MAX];        if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) &#123;            LOG_ALWAYS_FATAL(&quot;app_process: Unable to determine ABI list from property %s.&quot;,                ABI_LIST_PROPERTY);            return 11;        &#125;        String8 abiFlag(&quot;--abi-list=&quot;);        abiFlag.append(prop);        args.add(abiFlag);        // zygote 模式中，将后面的参数全部传入 ZygoteInit 的 main() 方法中        for (; i &lt; argc; ++i) &#123;            args.add(String8(argv[i]));        &#125;    &#125;    ......&#125;\n\n\n修改进程名\n\nint main(int argc, char* const argv[]) &#123;\t\t......    if (!niceName.isEmpty()) &#123;        runtime.setArgv0(niceName.string());        set_process_name(niceName.string());    &#125;    ......&#125;\n\n\n启动 “ZygoteInit” 或者 “RuntimeInit” 类\n\nint main(int argc, char* const argv[]) &#123;\t\t......    if (zygote) &#123; // 如果启动的是 zygote 进程        runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);    &#125; else if (className) &#123; // 如果启动的是普通 Java 进程        runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);    &#125; else &#123; // 否则报错        fprintf(stderr, &quot;Error: no class name or --zygote supplied.\\n&quot;);        app_usage();        LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);        return 10;    &#125;    ......&#125;\nstart() 方法最终会启动虚拟机并执行上面传入的类。这里可能有点奇怪，说好的启动普通 Java 进程时启动的是指定的 Java 主类，为什么这里却是执行 RuntimeInit 呢？其实逻辑是这样的：先执行 RuntimeInit 做一些必要的设置，再回到 AppRuntime 中执行指定的 Java 主类。这也就为什么在第三步的时候普通 Java 类的类名和参数要通过 AppRuntime#setClassNameAndArgs 的成员变量中，而 ZygoteInit 的参数保存在 args:Vector 中。因为这样从 RuntimeInit 回到 AppRuntime 中时就可以根据之前保存的类名和参数去执行指定的 Java 主类了。更详细的解析需要通过阅读 AppRuntime 的源码来说明。\nAndroidRuntimeAppRuntime 继承自 AndroidRuntime，它的大部分方法都直接继承自 AndroidRuntime，它仅仅是实现了 AndroidRuntime 定义的一些生命周期回调方法。所以我们重点来看 AndroidRuntime，首先看看它的构造方法：\nAndroidRuntime::AndroidRuntime(char* argBlockStart, const size_t BlockLength) :        mExitWithoutCleanup(false),        mArgBlockStart(argBlockStart),        mArgBlockLength(argBlockLength)&#123;    SkGraphics::Init();    // mOptions 用来存储虚拟机参数    mOptions.setCapacity(20);    assert(gCurRuntime == NULL);        // 确保只有一个实例    gCurRuntime = this; // 将该实例的指针保存在 gCurRuntime 这个全局指针中&#125;\n\n在 app_main.c 的 main() 方法中我们看到过 AppRuntime 的实例化过程，它是作为一个局部变量创建的，在 C++ 中，局部变量是在栈上分配的，而栈上分配的变量有一个特点，就是在方法执行完后它对应的内存就会被自动释放掉，不管是否有指向该变量的引用，所以一般不让全局的指针指向局部变量，这一点和 Java 有所不同。因此这里会有一个问题：如果 main() 方法执行完了，那么 gCurRuntime 所指向的那块内存已经被释放掉了，那么当我们引用 gCurRuntime 时程序肯定会报错。的确，如果 main() 运行完毕了我们在通过引用 gCurRuntime 去调用 AppRuntime 实例的方法肯定会报错，但关键在于，main() 方法退出了程序也就退出了，程序根本没有再引用 gCurRuntime 的机会了，这样看来，是不用担心 gCurRuntime 指向已释放内存的，在程序中可以放心使用。\n现在来看看它的一个重要方法，也是上面用到过的方法——start()，这个方法主要做了以下几件事：\n\n启动虚拟机：\n\nJniInvocation jni_invocation;jni_invocation.Init(NULL);JNIEnv* env;if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123;    return;&#125;\n\n这里创建了虚拟机并且导出了 JNIEnv 对象，这个对象可以用来和 Java 层交互。\n\n回调 onVmCreated(env) 方法\n\nvirtual void onVmCreated(JNIEnv* env)&#123;    if (mClassName.isEmpty()) &#123;        return; // Zygote. Nothing to do here.    &#125;    // 将类名中的 . 替换成 /    char* slashClassName = toSlashClassName(mClassName.string());    mClass = env-&gt;FindClass(slashClassName); // 查找指定的类    if (mClass == NULL) &#123; // 找不到这个类        ALOGE(&quot;ERROR: could not find class &#x27;%s&#x27;\\n&quot;, mClassName.string());    &#125;    free(slashClassName);    mClass = reinterpret_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(mClass));&#125;\n之前说了，AppRuntime 实现了 AndroidRuntime 中定义的各种生命周期回调方法，onVmCreated() 方法就是其中之一，因此这个方法的实现在 AppRuntime 中。这里对启动的是 zygote 进程还是普通的 Java 进程进行了不同的处理，如果是  zygote 进程，那么什么也不干，如果是普通的 Java 进程，那么就根据之前保存的类名来加载这个类。\n\n注册 JNI 函数\n\nif (startReg(env) &lt; 0) &#123;    ALOGE(&quot;Unable to register all android natives\\n&quot;);    return;&#125;\n\n这一步会将很多 Java 层的 native 方法和 C++ 层的方法对应起来。\n\n准备 Java 类的参数\n\njclass stringClass;jobjectArray strArray;jstring classNameStr;stringClass = env-&gt;FindClass(&quot;java/lang/String&quot;);assert(stringClass != NULL);strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL);assert(strArray != NULL);classNameStr = env-&gt;NewStringUTF(className);assert(classNameStr != NULL);env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);for (size_t i = 0; i &lt; options.size(); ++i) &#123;    jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string());    assert(optionsStr != NULL);    env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr);&#125;\n这里创建了一个 Java 字符串数组对象，然后把 C++ 字符串转换成 Java 层的字符串对象后放进该数组中。除了原本在 options 中的字符串外，这里还会把要启动的类的完整类名作为第一个元素放进字符串数组中。\n\n启动 Java 类\n\n /*  * Start VM.  This thread becomes the main thread of the VM, and will  * not return until the VM exits.  */ char* slashClassName = toSlashClassName(className); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123;     ALOGE(&quot;JavaVM unable to locate class &#x27;%s&#x27;\\n&quot;, slashClassName);     /* keep going */ &#125; else &#123;     // 找到 main 方法     jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;,         &quot;([Ljava/lang/String;)V&quot;);     if (startMeth == NULL) &#123;         ALOGE(&quot;JavaVM unable to find main() in &#x27;%s&#x27;\\n&quot;, className);         /* keep going */     &#125; else &#123;         // 执行 main() 方法         env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);......     &#125; &#125; free(slashClassName); // 销毁虚拟机 ALOGD(&quot;Shutting down VM\\n&quot;); if (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)     ALOGW(&quot;Warning: unable to detach main thread\\n&quot;); if (mJavaVM-&gt;DestroyJavaVM() != 0)     ALOGW(&quot;Warning: VM did not shut down cleanly\\n&quot;);\n这里就是启动 Java 类的地方了，根据前面的分析我们知道，这里的 Java 类只有 ZygoteInit 和 RuntimeInit 两种情况。我们先考虑启动的是 zygote 进程的情况，因此我们接下来分析一下 ZygoteInit 这个类。\nZygoteInit先看它的 main() 方法：\npublic static void main(String argv[]) &#123;    ......    try &#123;        ......        boolean startSystemServer = false;        String socketName = &quot;zygote&quot;;        String abiList = null;        for (int i = 1; i &lt; argv.length; i++) &#123;            if (&quot;start-system-server&quot;.equals(argv[i])) &#123;                startSystemServer = true;            &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123;                abiList = argv[i].substring(ABI_LIST_ARG.length());            &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;                socketName = argv[i].substring(SOCKET_NAME_ARG.length());            &#125; else &#123;                throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);            &#125;        &#125;        ......        registerZygoteSocket(socketName);        ......        preload(); // 预加载系统资源        ......                // Zygote process unmounts root storage spaces.        Zygote.nativeUnmountStorageOnInit();        ZygoteHooks.stopZygoteNoThreadCreation();        if (startSystemServer) &#123;            startSystemServer(abiList, socketName);        &#125;        Log.i(TAG, &quot;Accepting command socket connections&quot;);        runSelectLoop(abiList);        closeServerSocket();    &#125; catch (MethodAndArgsCaller caller) &#123;        caller.run(); // 通过抛出异常的方式清理方法调用栈，从此处执行 zygote 子进程中的逻辑    &#125; catch (Throwable ex) &#123;        Log.e(TAG, &quot;Zygote died with exception&quot;, ex);        closeServerSocket();        throw ex;    &#125;&#125;\n解析参数，先是判断是否要启动系统进程，然后获取 abi 列表，最后获取 socket 名称。之后根据 socket 名称注册服务端 socket。接下来就会预加载系统资源，因为应用进程都需要用到系统资源，因此 zygote 提前将这些资源加载好，到时候 fork 出应用进程的时候就可以直接把预加载的系统资源复制过去了，避免每次 fork 后子进程都要重复加载一遍系统资源，提高了效率。之后会决定是否启动 system_server 进程。启动完 system_server 之后的 zygote 进程就会进入一个死循环中，它会一直监听 Socket，看有没有客户端进程向自己发起通信。\nZygote Fork 子进程我们通过 startActivity() 或者 startActivityForResult() 来启动另一个应用程序时，会通过 Binder 向 AMS 发动请求，AMS 接收到请求后会构造一个 ActivityRecord 对象，这个对象包含要启动的 Activity 的各种信息。之后 AMS 会判断时候 Activity 需要运行的进程是否存在，如果不存在，那么通过 socket 请求 zygote 进程 fork 出一个子进程，再将 ActivityRecord 通过 ApplicationThread 传给那个进程，让它根据这个 ActivityRecord 去启动对应的 Activity。在 AMS 中，请求 zygote fork 进程是通过 Process#start() 方法来完成的，这个方法又会调用 startViaZygote() 方法，这个方法准备好参数后会接着调用 zygoteSendArgsAndGetResult() 方法，这个的名称很好的解释了它的作用：向 zygote 进程发送参数然后获取结果。\nzygote 进程接收到消息后就会为本次建立连接，接着会调用 zygote.forkAndSpecialize() fork子进，这个方法是通过 native 层的 ForkAndSpecializeCommon() 方法来进行 fork 的，这里不再深入，直接看看 fork 之后 Java 层的结果：\ntry &#123;    if (pid == 0) &#123;        // in child        IoUtils.closeQuietly(serverPipeFd);        serverPipeFd = null;        handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);        // should never get here, the child is expected to either        // throw ZygoteInit.MethodAndArgsCaller or exec().        return true;    &#125; else &#123;        // in parent...pid of &lt; 0 means failure        IoUtils.closeQuietly(childPipeFd);        childPipeFd = null;        return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);    &#125;&#125; finally &#123;    IoUtils.closeQuietly(childPipeFd);    IoUtils.closeQuietly(serverPipeFd);&#125;\n这里根据不同的进程做了不同的处理，如果是子进程，就会调用 handleChildProc() 方法来进行子进程的初始化工作，这个方法如下：\nprivate void handleChildProc(Arguments parsedArgs,        FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)        throws ZygoteInit.MethodAndArgsCaller &#123;    closeSocket();    ZygoteInit.closeServerSocket();    if (descriptors != null) &#123;        try &#123;            Os.dup2(descriptors[0], STDIN_FILENO);            Os.dup2(descriptors[1], STDOUT_FILENO);            Os.dup2(descriptors[2], STDERR_FILENO);            for (FileDescriptor fd: descriptors) &#123;                IoUtils.closeQuietly(fd);            &#125;            newStderr = System.err;        &#125; catch (ErrnoException ex) &#123;            Log.e(TAG, &quot;Error reopening stdio&quot;, ex);        &#125;    &#125;    if (parsedArgs.niceName != null) &#123;        Process.setArgV0(parsedArgs.niceName);    &#125;    // End of the postFork event.    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);    if (parsedArgs.invokeWith != null) &#123;        WrapperInit.execApplication(parsedArgs.invokeWith,                parsedArgs.niceName, parsedArgs.targetSdkVersion,                VMRuntime.getCurrentInstructionSet(),                pipeFd, parsedArgs.remainingArgs);    &#125; else &#123;        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,                parsedArgs.remainingArgs, null /* classLoader */);    &#125;&#125;\n这里关闭了 socket，因为子进程不再需要这个 socket 了。之后会通过 parseArgs.invokeWith 来判断是启动应用进程还是启动普通 Java 进程，invokeWith 对应的是 AMS 传过来的 –invoke-with 参数，invokeWith 指定的是要执行的 Java 类。由此看来，Zygote 不仅可以启动 Android 应用进程，也可以启动普通 Java 进程。\n如果启动的是 Android 应用进程，那么 RuntimeInit.zygoteInit() 方法会得到调用，这个方法会执行一些初始化工作，如设置缺省的异常处理，设置时区以及初始化 Binder 线程池。最后会调用 invokeStaticMain() 方法调用 ActivityThread 类的 main() 方法。invokeStaticMain() 方法不会直接调用 ActivityThread 的 main() 方法，而是抛出了一个 MethodAndArgsCaller 类型的异常，这个异常和普通的异常不同，它的作用是清理栈帧，我们知道，应用程序的入口是 ActivityThread，而到目前为止，程序依旧跑在 runSelectLoop() 的循环中，在 ActivityThread.main() 方法之前已经积累了很多方法栈，应用程序正常情况下是不会退出 ActivityThread.main() 方法的，所以那些积累的方法栈除了占内存没有其他用途，因此通过抛出异常的方式将它们清理掉。invokeStaticMain() 方法如下：\nprivate static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)        throws ZygoteInit.MethodAndArgsCaller &#123;    Class&lt;?&gt; cl;    try &#123;        cl = Class.forName(className, true, classLoader);    &#125; catch (ClassNotFoundException ex) &#123;        throw new RuntimeException(&quot;Missing class when invoking static main &quot; + className, ex);    &#125;    Method m;    try &#123;        m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);    &#125; catch (NoSuchMethodException ex) &#123;        throw new RuntimeException(&quot;Missing static main on &quot; + className, ex);    &#125; catch (SecurityException ex) &#123;        throw new RuntimeException(&quot;Problem getting static main on &quot; + className, ex);    &#125;    int modifiers = m.getModifiers();    if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;        throw new RuntimeException(                &quot;Main method is not public and static on &quot; + className);    &#125;        throw new ZygoteInit.MethodAndArgsCaller(m, argv);&#125;\n这里将 main() 方法对应的 Method 对象和 argv 封装在了 MethodAndArgsCaller 对象中，然后将其抛出。异常抛出了，那么在哪里进行处理呢？在 ZygoteInit 的 main() 方法中：\npublic static void main(String argv[]) &#123;    ......    try &#123;        ......        runSelectLoop(abiList);        closeServerSocket();    &#125; catch (MethodAndArgsCaller caller) &#123;        caller.run(); // 通过抛出异常的方式清理方法调用栈，从此处执行 zygote 子进程中的逻辑    &#125; catch (Throwable ex) &#123;        Log.e(TAG, &quot;Zygote died with exception&quot;, ex);        closeServerSocket();        throw ex;    &#125;&#125;\n\n我们的程序之前一直在 runSelectLoop() 方法内（为什么？因为 zygote 进程就是在这个方法中无限循环，因此 fork 出来的子进程也会处于这个循环中），抛出 MethodAndArgsCaller 异常后就会在这里被 catch 住，之后便会执行 MethodAndArgsCaller#run() 方法，这个方法如下：\npublic void run() &#123;    try &#123;        mMethod.invoke(null, new Object[] &#123; mArgs &#125;);    &#125; catch (IllegalAccessException ex) &#123;        throw new RuntimeException(ex);    &#125; catch (InvocationTargetException ex) &#123;        Throwable cause = ex.getCause();        if (cause instanceof RuntimeException) &#123;            throw (RuntimeException) cause;        &#125; else if (cause instanceof Error) &#123;            throw (Error) cause;        &#125;        throw new RuntimeException(ex);    &#125;&#125;\n这个方法仅仅是简单的调用了 ActivityThread#main() 方法，至此，子进程才真正意义上地开始了工作。以上便是 Zygote 进程的启动原理和 Android 应用进程的启动方式，接下来会分析一下普通的 Java 进程是如何启动的。\n普通 Java 进程的启动普通的 Java 进程的启动靠的也是 app_process 这个可执行文件，一般会这样启动一个普通的 Java 程序： \napp_process -Djava.class.path=classpath parentDir MainClass MainClassArgs...\n其实在分析 Zygote 进程启动过程的时候已经把一部分普通 Java 进程的逻辑也分析了，因为这两种进程有很多相似的逻辑，因此他们的代码都写在一块了。分道扬镳的地方在 AppRuntime#start() 这个方法，如果启动的是普通 Java 进程，那么便会执行 RuntimeInit#main() 方法，这个方法初始化一些东西之后便会调用 AppRuntime#onStarted() 方法：\nvirtual void onStarted()&#123;    sp&lt;ProcessState&gt; proc = ProcessState::self();    ALOGV(&quot;App process: starting thread pool.\\n&quot;);    proc-&gt;startThreadPool();    AndroidRuntime* ar = AndroidRuntime::getRuntime();    ar-&gt;callMain(mClassName, mClass, mArgs);    IPCThreadState::self()-&gt;stopProcess();&#125;\n\n这个方法作了两件事：初始化 Binder 线程池，调用我们指定 Java 类的 main() 方法。前面讲过，如果执行的是普通的 Java 类，通过 AppRuntime#setClassNameAndArgs() 方法要启动的类的类名和参数分别保存在 mClassName 和 mArgs 字段中，mClass 是在 AppRuntime#onVmCreated() 中创建的，它对应的是该类的 Class 对象。至此，一个 Java 进程就启动了。现在我们通过实践来体会一下让 Android 系统启动我们写好的普通 Java 程序。\n在 Android 系统上运行普通的 Android 程序因为只是做个试验而已，因此我们就编写个 HelloWord 类：\npublic class HelloWorld &#123;\tpublic static void main(String[] args) &#123;\t\tSystem.out.println(&quot;hello world&quot;);\t\tSystem.out.println(args[0]);\t&#125;&#125;\n现在编译它，记住要用 JDK1.7 编译，因为 Android 目前还不支持 JDK1.8 编译出来的 class 类。编译好后就是一个 HelloWorld.class 文件了，我们知道 DVM 无法运行 class 文件，因此我们需要通过 dx 工具将该 class 文件转换成 dex 文件。dx 工具在 sdk/build-tools/build-tool版本号 目录下。我们将 Test.class 放置在该目录下，然后打开终端，切换到这个目录并执行如下命令：\ndx --dex --output=test.dex HelloWorld.class\n运行成功的话在这个目录下就能看到 test.dex 文件了，现在我们把这个文件放置在 &#x2F;sdcard 下，现在通过 adb 执行以下命令：\nadb shellapp_process -Djava.class.path=/sdcard/test.dex HelloWorld first-parameter\n接下来不出意外的话终端会出现这两行：\nhello worldfirst-parameter\n当然，除了通过终端的方式执行 Java 程序，也可以在 Android 应用的代码里执行。前面的步骤不变，我们编写如下代码：\npublic class MainActivity extends AppcompatActivity &#123;\t\t@Override\tpublic void onCreate(Bundle savedInstanceState) &#123;\t\tsuper.onCreate(savedInstanceState);\t\tsetContentView(R.layout.main);\t\t\t\ttry &#123;\t\t  Process proc = Runtime.getRuntime().exec(&quot;app_process -Djava.class.path=/sdcard/test.dex HelloWorld first-parameter&quot;);          InputStream in = proc.getInputStream();          InputStreamReader isr = new InputStreamReader(in);          BufferedReader br = new BufferedReader(isr)          Toast.makeText(this, br.readLine(), Toast.LENGTH_SHORT).show();          Toast.makeText(this, br.readLine(), Toast.LENGTH_SHORT).show();        &#125; catch (IOException e) &#123;          e.printStackTrace();        &#125;    &#125;&#125;\nAndroid 应用一启动时就会执行启动 Java 进程的命令，接着获取该命令的输入流（可通过 Process 获取三种流，输入流、错误输入流和输出流，这分别对应着 Process 的输出流、错误输出流和输入流），接着通过 Taost 依次显示从输入流获取的两行字符串。不出意外的 Toast 会依次显示 “hello world” 和 “first-parameter”。\n总结以上是对 《深入理解 Android 5.0 系统》中第八章的总结和理解。\n参考链接：\n\nAndroid中执行java命令的方法及java代码执行并解析shell命令\n\nexecute shell command from android\nAndroidXref - Android Source Code Cross Reference\n\n","tags":["Android","进程"]},{"title":"Java 注解学习总结","url":"/2017/08/29/2017-08-29-java-annotation/","content":"Java 注解学习前言注解是在 JDk 5 时引入的，注解可以提供一些元数据，它们能为所注解的代码提供一些不属于程序本身的数据，从而可以对程序提供一些辅助功能。这些辅助功能包括编译时检查（错误和警告）、编译时和部署时的代码加工，以及运行时的代码处理。这三种注解分别被称为源码级别的注解（这些注解主要是在编辑代码时为程序员提供错误信息）；编译时注解：这种类型的注解一般需要配合注解处理器框架使用，可以在编译器编译项目时生成一些文件，包括 .java 源文件和 .xml 配置文件等；运行时注解：在程序运行的时候为程序提供一些功能，一般配合反射框架使用。\n\n注解的定义和使用在细讲这三种注解的区别前，先简单说下注解的定义和使用。\n使用注解的使用想必大家很熟悉了，如最常见的 Override 注解，这种注解没有配置参数，被称为标记注解：\n@Overideint hashCode()&#123;&#125;;\n\n有参数的注解常见的有 SuppressWarnings 注解，这个注解用来关闭编译器的警告，如关闭 unchecked（未受检）警告和 deprecation（使用了已弃用方）警告：\n@SuppressWarnings(&quot;unchecked&quot;)useDeprecatedMethod() &#123;    deprecatedMethod();&#125;\n这个注解带有配置参数，并且参数值可以有多个，表示需要关闭多种类型的警告，比如需要同时关闭 unchecked 和 deprecation 警告：@SuppressWarnings({“unchecked”, “deprecation”})。\n定义Java 类库中有很多预定义好的注解，如上面那两个，用户也可以自己定义注解，注解的定义是这样的：\n@Target(ElementType.Type)@Documented@@Inherited@Repeatable@Retention(RetentionPolicy.SOURCE)public @interface Person &#123;    enum GENDER &#123;MALE, FEMALE&#125;    String name();    int id() default -1;    GENDER gender() default GENDER.MALE;    String[] hobit();&#125;\n上面的例子中，定义了一个名为 Person 的注解。注意 Person 前面的 @interface，它是来声明注解用的，和 class 和 enum 是一个级别的东西，所有的注解都会自动继承 Annation 接口。我们发现这个注解定义上也有多个注解，他们被称为“元注解”，作用是注解其他的注解。那么它们含义是什么呢？首先看 Target 注解，它用来说明我们定义的注解的总用范围，它含有一个枚举类型的参数，可以取以下值：\n\nElementType.ANNOTATION_TYPE 作用于注解类型上（元注解就是这种类型，而且这种类型的注解可以自注解，即自己作用在自己身上）。\nElementType.CONSTRUCTOR 作用于构造器。\nElementType.FIELD 作用于类属性。\nElementType.LOCAL_VARIABLE 作用于局部变量。\nElementType.METHOD 作用于方法。\nElementType.PACKAGE 作用于包的声明。\nElementType.PARAMETER 作用于方法参数。\nElementType.TYPE 作用于接口，类和枚举。\n\n@Documented 注解用来说明 javadoc 工具是否为该注解生成文档，因为注解默认是不生成文档的。@Inherited 注解表示的是该注解可从父类传给子类，比如用 Person 去注解一个类，那么这个类的子类即使没有 Person 所注解，但是由于 Person 的可继承性，子类也同样被隐式的被 Person 注解了。@Repeatable 表示该注解可以重复注解在某一个元素上，这个注解是在 java8 引入的。@Retention 注解用来说明该注解的级别，是源码级别的（编辑时注解），还是类级别的（编译时注解，这种注解会被编译器保留，但会被 JVM 忽略），运行时级别的（被 JVM 保留，并且在运行时被使用）。\n@Person 含有四个配置参数，它们的声明看起来像是方法。需要注意的是注解的配置参数的类型只可以是基本数据类型、枚举、Class、String 和以上类型的数组类型。当注解只含有一个配置参数时，一般参数名直接用 “value”，因为注解本身的名称就很好的解释了 value 的意义。现在看看如何用 @Person 注解：\n@Person(name=&quot;Chance&quot;, id=16, gender=GENDER.MALE&quot;, hobit=&#123;&quot;music&quot;, &quot;movie&quot;, &quot;game&quot;&#125;)public class Chance &#123;&#125;\n相信大家一目了然，就不细讲了。需要说明的是，这里使用名值对的形式表示注解。如果只有一个配置参数，那么写配置参数的时候可以将参数名称省略掉，就像 @SupperssWarnings 一样。并且要注意的是，注解的某些参数的配置参数后可以通过 default 关键字指定默认值，如果没有指定，那么使用该注解时一定要填写该参数值，否则编译器会报错。也就是说，没有默认值的参数是必填项。\n源码级别的注解之所以称之为源码级别的注解，就是注解信息仅仅会在源码中保留，不会编译到 class 文件中。这和它的作用相符：因为它仅仅是为编辑器提供信息而已。这种注解常见的如 @Override、@SuppressWarnings、@Deprecated 等。这种注解比较简单，就不细说了。\n编译时注解这种类型的注解要配合注解处理器来使用，什么是注解处理器？为什么要注解处理器？注解处理器顾名思义就是对注解进行处理的工具，为什么需要注解处理器呢？前面说了，注解其实对被注解的代码不会有任何影响，也就是说它们不会被项目中的代码识别，那么要想它们发挥作用，必定是需要能够识别它们的东西。编辑时注解器靠的就是编辑器来识别，而编译时处理器靠的便是注解处理器了，下面要说的运行时注解靠的就是反射框架了。如何定义注解处理器呢？\n运行时注解运行时注解可以反射框架来实现，比如对于上面那个例子，假设 @Person 注解是运行时注解，那么可以定义一个注解的运行时解析类在运行时获取注解的信息：\npublic class AnnotationUtil &#123;   public void inject(Object target) &#123;       Class cls = target.getClass();       if (cls.isAnnotationPresent(Person.class)) &#123;       \tPerson personAnnotation = cls.getAnnotation(Person.class);       \tSystem.out.print(personAnnotation.toString());        //  System.out.print(personAnnotation.gender());        //  System.out.print(personAnnotation.hobit());        //  System.out.print(personAnnotation.id());        //  System.out.print(personAnnotation.name());       &#125;   &#125;&#125;\n然后这样定义 Chance：\n@Person(name=&quot;Chance&quot;, id=16, gender=GENDER.MALE&quot;, hobit=&#123;&quot;music&quot;, &quot;movie&quot;, &quot;game&quot;&#125;)public class Chance &#123;\t\tpublic Chanece() &#123;\t\tAnnotationUtil.inject(this);\t&#125;\tpublic static void main(String[] args) &#123;\t\tChance c = new Chance();\t&#125;&#125;\n\n然后打印出来的结果是这样的：\n@com.company.MyAnnotation(gender=MALE, id=16, name=Chance, hobit=[music, movie, game])\n通过反射就可以拿到注解信息。如果注解作用在字段或者方法上，也是通过同样的方法获取注解的信息的，这里就不再说了。拿到注解信息后想干什么那就看自己的喜好了，很多第三方框架就是通过这种方法来获取注解信息然后实现一些看似很炫酷的功能。比如 Retrofit，刚接触的时候很疑惑，为什么在接口方法上使用注解就可以 “实现” 该接口呢？其实它就是在运行时获取注解信息然后根据这些信息通过动态代理的方式实现该接口。\n","tags":["Java"]},{"title":"Android 事件分发规律总结","url":"/2017/09/05/2017-09-05-android-how-motion-event-dispatched/","content":"Android 事件分发规律总结定义事件序列：手指接触屏幕开始到离开屏幕为止产生的事件为一次事件序列。\n规律一从父视图的角度来看，无论他的子视图是 View 还是 ViewGroup，对父视图来说都是透明的。它只知道如果当 ACTION_DOWN 事件传给子视图后子视图的 dispatchTouchEvent () 返回 true，说明子视图想要处理这个事件，那么以后的事件就都交给它，不管以后子视图的 dispatchTouchEvent() 返回的是 true 还是 false; 如果 ACTION_DOWN 事件传给子视图后子视图返回的是 false，那么以后的事件再也不会传给子视图（子视图没有处理 ACTION_DOWN 就视作它不想处理该事件序列）。如果一个子视图的 dispatchTouchEvent() 在处理 ACTION_DOWN 时返回 true ，只要父视图没有拦截事件, 那么该事件序列中的后续事件都会传入该视图中，也就是传入该视图的 dispatchTouchEvent() 方法中，就算手指的触摸区域已经超出了该视图的范围。并且对于该事件序列的之后所有事件，即使该视图的 dispatchTouchEvent() 返回 false 事件也同样会继续传入该视图，唯一的影响是会将该事件原路返回，最终落到 activity.onTouchEvent() 中。因此建议如果消耗了该事件，除非有特殊情况需要处理，最好不要返回 false，否则上级视图以为下面的视图没有处理事件从而自己处理。\n\n规律二父视图有两种角色，一种是 ViewGroup , 另一种是 View。当父视图的角色是 ViewGroup 时，父视图的主要任务就是分派事件给子视图；当父视图的角色为 View 时，它和普通的 View 一样处理事件。父视图在两种情况下会将事件拿给自己处理：1）如果没有子视图能够处理事件，那么只能由父视图自己处理，此时会把事件传给 super.dispatchTouchEvent()，也就是父类方法来处理（注意是父类，不是父视图）。2）假如本来整个事件序列都是要传给子视图的，但是中途父视图想要拦截的话，从父视图决定拦截开始之后的所以事件都不会再交给子视图处理了，但是决定拦截时的那一次的事件会还是会交给子视图的，只不过是事件的类型是 ACTION_CANCEL，这样做的原因我认为可能是通知一下子视图父视图拦截了你的事件，免得子视图事件被拦截了还蒙在鼓里（其实就是让开发者可以对这种情况加以处理）。从开始拦截的那一次开始，之后的所有事件（不包括拦截的那一次）都不会传给子视图了，都传入 super.dispatchOnToucnEvent() 中，即交给父视图给自己处理。\n规律三如果事件是交给自己处理，不管是子视图还是父视图，只要事件交给了自己处理，那么事件的处理流程都是一样的（这个流程在 View 中定义），下面来分析是如它们何处理事件的：如果视图将事件交给自己处理，那么事件首先都是从 dispatchTouchEvent() 传入的（父视图是 super.dispatchTouchEvent()），这个方法的逻辑是：如果该视图注册了OnTouchListener 监听器，并且监听器不为 null，那么就把事件交给监听器中的 onTouch() 方法。下一步就是看 onTouch() 的返回值了，如果返回值为 true，那么说明 onTouch() 消费了该事件，事件的传递到此为止， dispatchTouchEvent() 返回 true；如果返回值为 false，那么说明 onTouch() 方法并没有消耗该事件，那么进行下一步的事件分发。下一步事件会传给 onTouchEvent 方法，这个方法是最常见也最常用的方法，对于一个 自定义 View 来说，这个方法是根据事件来更改 View 的行为的主要场所。dispatchTouchEvent() 同样需要根据 onTouchEvent() 的返回值来决定下一步的事件转发流程。如果 onTouchEvent() 返回 false，那么 dispatchTouchEvent() 返回的就是 false，否则返回的就是 true。这个过程可以用如下代码表示：\npublic boolean dispatchTouchEvent(MotionEvent e) &#123;    return (onTouchListener != null) ? (onTouchListener.onTouch(e) ? true : onTouchEvent(ev)) : onTouchEvent(e);&#125;\n\n之前已经说到，如果当父视图接收到 ACTION_DOWN 事件时，如果没有子视图能够处理该事件，那么后续的事件就不会给该子视图了，并且该事件会交给父视图处理，即传入父视图的 super.dispatchTouchEvent() 方法中。子视图有没有处理该事件就是根据 dispatchTouchEvent() 的返回值来看的。返回 true 表示处理，false 表示未处理。如果子视图对于 ACTION_DOWN 事件进行了处理（dispatchTouchEvent() 返回true），那么之后的事件都会给它处理，不管子视图之后 dispatchTouchEvent() 是否返回 true，也就是说，父视图会忽略子视图接下来的 dispatchTouchEvent() 的返回值，只要事件继续发生就都传给该子视图。但是，返回 false 会导致事件从该子视图返回给上级视图，上级视图也不会处理该事件，该事件会一直上传，直至传到 Activity 中的 onTouchEvent() 方法中。 \n规律四关于事件的拦截：父视图可以在任何时候拦截本应该传递子视图的事件，拦截的依据就是 onInterceptTouchEvent() 的返回值，true 表示拦截，false 表示不拦截，父视图每次分发事件时会根据这个方法的返回值决定是否开始拦截：如果返回 false，即不拦截该事件，父视图下次分发事件时依然会调用这个方法来判断是否开始拦截事件；如果返回 true，说明该事件需要拦截，那么以后的事件，包括该事件都会直接交由父视图的 super.dispatchTouchEvent() 方法处理，而不会再传入子视图的 dispatchTouchEvent() 方法中 。但是开始拦截的那个事件还是会交给那个子视图，只是事件的类型变为了 ACTION_CANCEL。\n规律五事件在系统中的传递流程：ViewRootImpl &#x3D;&gt; DecorView(调用的方法是 dispatchTouchEvent()) &#x3D;&gt; WindowCallback(即Activity) &#x3D;&gt; PhoneWindow &#x3D;&gt; DecorView(调用的方法是 super.dispatchTouchEvent)\n规律六子视图可以调用父视图的 requestDisallowInterceptTouchEvent() 方法来向父视图请求不拦截事件。但是这个方法只对除 ACTION_DOWN 之外的其他事件有效，如果父视图选择拦截 ACTION_DOWN，子视图即使在此之前调用此方法也是没有任何用的。并且需要注意，如果父视图在此方法调用之前就已经对事件进行了拦截，那么这个方法也同样无效。\n规律七父视图如何找到能够接受某个事件的子视图？\n假设在父视图中的事件坐标是 (x, y)\n1）首先要转换成相对子视图的坐标，转换的步骤如下：\n首先要考虑父视图是否发生滚动，其次需要考虑子视图是否发生平移，如果用（x’, y’）表示转换后的坐标，那么有：\nx’ &#x3D; x + scrollX - child.left - child.translationX;y’ &#x3D; y + scrollY - child.top - child.translationY;\n其实在源码中上述变换过程分为两步进行：\n\n第一步不考虑平移：x’ &#x3D; x + scrollX - child.left; \n第二步通过 TransformationInfo（内含变换矩阵） 将平移考虑进去：x’ &#x3D; x + scrollX - child.left - child.translationX;\n\n2）然后根据相对子视图的坐标判断该点是否落在子视图的范围内。判断的依据是：x’ &lt; width &amp;&amp; y’ &lt; height &amp;&amp; x’ &gt;&#x3D; 0 &amp;&amp; y’ &gt;&#x3D; 0（width 和 height 是子视图的宽高）。\n","tags":["Android","View","事件分发"]},{"title":"Android LaunchMode 总结","url":"/2017/11/07/2017-11-07-android-launch-mode/","content":"Android LaunchMode 总结Android 中的 LaunchMode 是一个比较基础的知识点，关于这块之前每次都是先用现学，然后学了之后又忘了，现在把 LaunchMode 的规律记录下来以备后用。\n需要了解的知识点在讲 LaunchMode 之前，需要了解一下几点知识：\n\ntask 有属性 affinity，Activity 有属性 taskAffinity\n可以存在两个 affinity 一样的 task；\n一个 Activity 的 taskAffnity 默认值为 package name，如果有指定值就会设为指定值\n\nLuanchMode 规律总结Manifest 中注册了两个 Activity，它们的类型分别为 AActivity 和 BActivity。假设 AActivity 的 taskAffinity 为 a，现在通过 BActivity 的一个实例 B 启动 AActivity：\n如果此时 AActivity 的实例不存在于任何 task 中，那么：\n如果  AActivity 的启动模式为 singleTask， 那么先会找是否存在 affinity 为 a 的 task，如果存在并且这个 task 中的 Activity 不是 singleInstance，那么就在那个 task 中创建并启动一个 AActivity 的实例 ；如果不存在，那么新建一个 affinity 为 a  的 task，然后在新建的 task 中创建并启动一个 AActivity 的实例；\n如果 AActivity 的启动模式为 singleInstance，那么无论是否存在 affinity 为 a 的 task ，总会新建一个 affinity 也为 a 的 task，并在这个新建的 task 中创建并启动一个 AActivity 的实例；\n如果 Activity 的启动模式为 standard （默认值) 或者 singleTop，那么就要看 BActivity 的启动模式了：\n如果 BActivity 的启动模式不为 singleInstance 的话，那么  AActivity  的 taskAffinity 属性会被忽略，然后就在 B 所在的 task 中创建并启动一个 AActivity 的实例；\n如果  BActivity 的启动模式为 singleInstance 的话，那么 AActivity 的 taskAffinity 属性不会被忽略，此时系统就会去找一个 affinity 为 a 的 task：如果能找到并且这个 task 中的 Activity 不为 singleInstance，那么就会在那个 task 中创建并启动一个 AActivity 的实例；否则新建一个 affinity 为 a 的 task，然后在这个新建的 task 中创建并启动启动一个 AActivity 的实例。\n\n\n\n如果 AActivity 的实例已经存在于某个任务栈中，那么：\n如果 AActivity 的启动模式为 standard ，那么就要看 BActivity 的启动模式了：\n如果 BActivity 的启动模式不为 singleInstance 的话，那么  AActivity  的 taskAffinity 属性会被忽略，然后就会在 B 所在的 task 中启动；\n如果  BActivity 的启动模式为 singleInstance 的话，那么 AActivity 的 taskAffinity 属性不会被忽略，系统会去找一个 affinity 为 a 的 task：如果能找到并且这个 task 中的 Activity 不为 singleInstance，那么就会在那个 task 中创建并启动一个 AActivity 的实例；否则新建一个 affinity 为 a 的 task，然后在这个新建的 task 中创建并启动一个  AActivity 的实例。\n\n\n如果 AActivity 的启动模式为 singleTop 的话 ，同样要看 BActivity 的启动模式：\n如果 BActivity 的启动模式不为 singleInstance 的话，那么  AActivity  的 taskAffinity 属性会被忽略，然后就会在  B 所在的 task 中启动；但是，如果 BActivity &#x3D; AActivity，那么就不会创建并启动一个 AActivity 的实例了，此时只会调用 B 的 onNewIntent 方法；\n如果 BActivity 的启动模式为 singleInstance 的话，那么 AActivity 的 taskAffinity 属性不会被忽略，此时系统就会去找一个 affinity 为 a 的 task：如果能找到并且这个 task 中的 Activity 不为 singleInstance，那么就会在那个 task 中启动；但是如果这个 task 的栈顶已经有一个 AActivity 的实例 A，就不会再次创建并启动另一个 AActivity 的实例了，此时只会调用栈顶的这个 A 的 onNewIntent() 方法；\n\n\n如果 AActivity 的启动模式为 singleInstance，那么一定会找到一个 affinity 为 a 的 task（为什么？因为我们假设 AActivity 的实例已经存在于某个 task 中，而根据 singleInstance 的特点，这个 task 的 affinity 一定为 a），并且该 task 中只有一个 AActivity 的实例 A，此时不会再次创建并启动另一个 AActivity 的实例，此时只会调用  A 的 onNewIntent() 方法；\n如果  AActivity 的启动模式为 singleTask， 那么先一定会找到 affinity 为 a 的 task（为什么？因为我们已经假设 AActivity 的实例已经存在于某个 task 中，而根据 singleTask 的特点，这个 task 的 affinity 一定为 a），并且该栈中已经存在一个 AActivity 的实例 A，此时会把该 task 中位于 A 上方的所有 Activity 清理出栈，然后调用 A  的 onNewIntent() 方法。\n\n总结关于 LaunchMode，光靠阅读文章是不能深刻理解其中规律的。大家可以尝试自己写一些各种启动模式的 Activity，让他们相互启动，再通过 adb shell dumpsys 这个命令查看任务栈以及其中的 Activity，这样应该能很快理解 LaunchMode 的规律的，也能记得更牢。\n","tags":["Android","LaunchMode"]},{"title":"View 的焦点机制","url":"/2018/04/06/2018-04-06-android-focus/","content":"View 的焦点机制约定：文章中的 View 有时是指狭义的 View.class，有时指的是 View.class 和 ViewGruop.class 的统称，具体含义根据上下文而定。\n和焦点相关的 xml 属性在 xml 中，有两个比较重要的属性和焦点有关，它们是 focusable 和 focusableInTouchMode。前者决定这个 View 是否可获取焦点，如果它的值为 false，那么它就和焦点无缘了；后者决定这个 View 在触屏模式下是否可获取焦点，如果它的值为 false，那么即使 focusable 的值为 true，在触屏模式下它也无法获取焦点。比如 Button，如果我们通过外接键盘进行操作，我们会发现 Button 是可以获得焦点的，但是在触屏模式下，Button 是不可获取焦点的。所以我们可以知道 Button 的 focusable 属性默认为 true，而 focusableInTouchMode 属性为 false。\n\n\n一个 View 能够获取焦点不代表它拥有焦点，因此，即使你在 xml 中指定这两个属性为 true，在窗口显示时这个 View 也不一定能立马获取焦点。因为窗口上还存在其他能够获取焦点的 View，例如 EditText，它的这两个属性的默认值都为 true。虽然一个界面上可以有多个 View 拥有获得焦点的能力，但是每个时刻只有一个 View 能够真正的获取焦点。\n除了上面两个属性外，还有一些和焦点转移相关的属性，比如 nextFocusUp，nextFocusDown，nextFocusFoward 等。当我们通过外接键盘进行操作时，我们有时需要通过上下左右来控制焦点，nextFocusUp，nextFocusDown 等就是用来指明下一个焦点将转移到哪个视图上。当我们填写表单时，点击回车键可以将焦点转移到下一个 EditText 上，这时候我们就可以通过 nextFocusFoward 来指定这个 EditText。你会发现就算我们不指明这些属性系统都能够将焦点转移到合适的视图上，这是因为系统会通过计算帮你找到下一个能够获取焦点的最佳视图。关于系统的焦点转移算法可以参考 FocusFinder 这个类。\n和焦点相关的方法和焦点相关的方法主要有 hasFocus()，isFocused()，requestFocus()，unFocused()，clearFocus()，setFocusable() 和 setFocusableInTouchMode()。最后两个方法对应的就是 xml 中的那两个属性，我们主要讲下前面几个方法。\nhasFocus首先是 hasFocus() 方法，它在 View 和 ViewGroup 中的定义分别如下：\n// View.javapublic boolean hasFocus() &#123;    return (mPrivateFlags &amp; PFLAG_FOCUSED) != 0;&#125;// ViewGroup.javapublic boolean hasFocus() &#123;    return (mPrivateFlags &amp; PFLAG_FOCUSED) != 0 || mFocused != null;&#125;\nPFLAG_FOCUSED 这个标志位用来标识这个 View 是否具有焦点，mFocused 是 ViewGroup 特有的变量，它用记录自身具有焦点或者后代具有焦点的子 View，如果不存在这样的子 View， mFocus 的值就为 null。通过对比可以发现，hasFocus() 在 View 中的含义是这个 View 是否具有焦点，在 ViewGroup 中的含义是该 ViewGroup 是否具有焦点或者它的后代是否有焦点。\nisFocusedisFocused() 只在 View 中有定义，其定义如下：\npublic boolean isFocused() &#123;    return (mPrivateFlags &amp; PFLAG_FOCUSED) != 0;&#125;\n这个方法的和 hasFocus() 有点相似，不过它在 View 和 ViewGroup 中的含义都是一样的，表示这个 View 本身是否具有焦点。\nrequestFocusrequestFocus() 在 View 中的定义如下：\npublic final boolean requestFocus() &#123;    return requestFocus(View.FOCUS_DOWN);&#125;public final boolean requestFocus(int direction) &#123;    return requestFocus(direction, null);&#125;public boolean requestFocus(int direction, Rect previouslyFocusedRect) &#123;    return requestFocusNoSearch(direction, previouslyFocusedRect);&#125;private boolean requestFocusNoSearch(int direction, Rect previouslyFocusedRect) &#123;    // need to be focusable    if ((mViewFlags &amp; FOCUSABLE) != FOCUSABLE            || (mViewFlags &amp; VISIBILITY_MASK) != VISIBLE) &#123;        return false;    &#125;    // need to be focusable in touch mode if in touch mode    if (isInTouchMode() &amp;&amp;        (FOCUSABLE_IN_TOUCH_MODE != (mViewFlags &amp; FOCUSABLE_IN_TOUCH_MODE))) &#123;           return false;    &#125;    // need to not have any parents blocking us    if (hasAncestorThatBlocksDescendantFocus()) &#123;        return false;    &#125;    handleFocusGainInternal(direction, previouslyFocusedRect);    return true;&#125;\n\n\n对于 View 来说，requestFocus() 的返回值的含义是这个 View 是否成功获取了焦点。从上面的代码可知，如果这个 View 不可获取焦点，或者这个 View 不可见，或者这个 View 在触屏模式下不可获取焦点，那么这个方法返回 false，也就是说这个 View 获取不了焦点；否则调用 handleFocusGainInternal() 方法之后返回 true。由此在可见 handleFocusGainInternal() 方法中，View 成功获取了焦点。\nrequestFocus() 方法在 ViewGroup 中的定义如下：\npublic boolean requestFocus(int direction, Rect previouslyFocusedRect) &#123;    if (DBG) &#123;        System.out.println(this + &quot; ViewGroup.requestFocus direction=&quot;                + direction);    &#125;    int descendantFocusability = getDescendantFocusability();    switch (descendantFocusability) &#123;        case FOCUS_BLOCK_DESCENDANTS:            return super.requestFocus(direction, previouslyFocusedRect);        case FOCUS_BEFORE_DESCENDANTS: &#123;            final boolean took = super.requestFocus(direction, previouslyFocusedRect);            return took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect);        &#125;        case FOCUS_AFTER_DESCENDANTS: &#123;            final boolean took = onRequestFocusInDescendants(direction, previouslyFocusedRect);            return took ? took : super.requestFocus(direction, previouslyFocusedRect);        &#125;        default:            throw new IllegalStateException(&quot;descendant focusability must be &quot;                    + &quot;one of FOCUS_BEFORE_DESCENDANTS, FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS &quot;                    + &quot;but is &quot; + descendantFocusability);    &#125;&#125;\nViewGroup 覆盖了 View 的 requestFocus() 方法，它会根据 descendantFocusability 的值的不同进行不同的处理，descendantFocusability 有三个可能的值：第一个是 FOCUS_BLOCK_DESCENDANTS，它的意思是对焦点进行拦截，不给子 View 进行请求焦点的机会，而是自己请求；第二个是 FOCUS_BEFORE_DESCENDANTS，让自己先去请求焦点，如果没能成功获得焦点才让子 View 去请求焦点；第三个是 FOCUS_AFTER_DESCENDANTS，让子 View 先去请求焦点，如果子 View 没能成功请求到焦点才由自己请求。ViewGruop 的这个属性的默认值为 FOCUS_BEFORE_DESCENDANTS。\n当 descendantFocusability 为 FOCUS_BLOCK_DESCENDANTS 时，通过调用父类 View 的 requestFocus() 方法执行为自己请求焦点的逻辑；当值为 FOCUS_BEFORE_DESCENDANTS 时，先为自己请求焦点，如果未能成功，那么再调用 onRequestFocusInDescendants() 方法，这个方法从名字就能知道是为子 View 请求焦点，或者说是把请求焦点的任务交给了后代。因此，对于 ViewGroup 来说，这个方法的返回值和 View 有点不同：如果返回 true，说明这个 ViewGroup 获取了焦点或者它的某个后代成功地获取了焦点；否则，这个 ViewGroup 未能成功获取焦点并且它的子 View 也未能成功获取焦点。\n现在我们看下 onRequestFocusInDescendants() 的定义：\nprotected boolean onRequestFocusInDescendants(int direction,        Rect previouslyFocusedRect) &#123;    int index;    int increment;    int end;    int count = mChildrenCount;    if ((direction &amp; FOCUS_FORWARD) != 0) &#123;        index = 0;        increment = 1;        end = count;    &#125; else &#123;        index = count - 1;        increment = -1;        end = -1;    &#125;    final View[] children = mChildren;    for (int i = index; i != end; i += increment) &#123;        View child = children[i];        if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123;            if (child.requestFocus(direction, previouslyFocusedRect)) &#123;                return true;            &#125;        &#125;    &#125;    return false;&#125;\n\n这个方法会遍历所有的子 View，寻找第一个自身或者后代能够成功获取焦点的 View，如果找到了，停止后续的遍历并返回 true；如果不存在这样的 View，返回 false。\n从上面的分析可知，requestFocus() 方法不保证一定能获取焦点，还要看该 View 或者 ViewGroup 是否具有获取焦点的能力。对于 View 来说，要想在触屏模式下拥有获取焦点的能力，首先要可见，其次要保证自己的 focusable 和 focusableInTouchMode 这两个属性的值为 true；而对于 ViewGroup 来说，这种能力除了上面说的这些点之外，还要保证在 FOCUS_AFTER_DESCENDANTS 模式下，后代没有成功获取焦点。\nunFocus这个方法是内部方法，应用程序不能直接调用，它在 View 和 ViewGroup 中有不同的定义：\n// View.javavoid unFocus(View focused) &#123;    if (DBG) &#123;        System.out.println(this + &quot; unFocus()&quot;);    &#125;    clearFocusInternal(focused, false, false);&#125;void clearFocusInternal(View focused, boolean propagate, boolean refocus) &#123;    if ((mPrivateFlags &amp; PFLAG_FOCUSED) != 0) &#123;        mPrivateFlags &amp;= ~PFLAG_FOCUSED;        if (propagate &amp;&amp; mParent != null) &#123;            mParent.clearChildFocus(this);        &#125;        onFocusChanged(false, 0, null);        refreshDrawableState();        if (propagate &amp;&amp; (!refocus || !rootViewRequestFocus())) &#123;            notifyGlobalFocusCleared(this);        &#125;    &#125;&#125;// ViewGroup.java@Overridevoid unFocus(View focused) &#123;    if (DBG) &#123;        System.out.println(this + &quot; unFocus()&quot;);    &#125;    if (mFocused == null) &#123;        super.unFocus(focused);    &#125; else &#123;        mFocused.unFocus(focused);        mFocused = null;    &#125;&#125;\n对于 View 来说，这个方法仅仅是调用了 clearFocusInternal() 方法，最终达到的效果是清除了 PFLAG_FOCUSED 这个标志位，也就是清除了自身的焦点。而对于 ViewGroup 来说，如果自己的 mFocused  变量为 null 的话，就调用父类 View 的 unFoucs() 方法，执行取消自身焦点的逻辑；否则，调用 mFocused 指向的那个 View 的 unFocus() 方法，并且将 mFocused 置为 null。结合 mFocused 的含义来看，对于 ViewGroup 来说，这个方法达到的效果就是：如果自身有焦点（自身具有焦点的 ViewGroup 的 mFocused 值为 nul），那么将自身的焦点清除；否则通过递归调用将焦点路径（关于焦点路径在后面会有介绍）上从该节点开始的所有后续中间节点的 mFocused 置为 null，并将焦点路径的终止节点（即具有焦点的那个 View）的焦点清除。\nclearFocus这个方法只在 View 中有定义：\npublic void clearFocus() &#123;    if (DBG) &#123;        System.out.println(this + &quot; clearFocus()&quot;);    &#125;    clearFocusInternal(null, true, true);&#125;\n它也会调用 clearFocusInternal() 方法，只不过传入的参数和 unFocus() 中的不同。其作用是如果此 View 有焦点的话，清除自身的焦点并将焦点路径删除。\n焦点路径我们知道，对于一个窗口来说，其内部所有的 View 都是通过树的形式来组织的。每一个 View 都是这棵树的一个节点，DecorView 是这棵树的根节点，其他 ViewGroup 是这棵树的中间节点，View 是这棵树的子节点。前面说了，一个窗口中只能有一个 View 获取焦点，我们可以把从根节点到这个获取焦点的节点路径称之为焦点路径。很显然，焦点路径的起始节点是根节点，中间节点是各种类型的 ViewGroup，终止节点是那个拥有焦点的 View。\n在每次重新确定焦点视图后，系统都会建立一条这样一条焦点路径。系统是怎样标识这条路径的呢？就是前面讲到的 mFocused 变量。mFocused  的含义之前说了，指向的是这个 ViewGroup 的自身具有焦点或者后代具有焦点的子 View。而中间节点和根节点都是 ViewGroup 的子类，它们都持有 mFocused 变量，因此从根节点开始，通过 mFocused 变量可以到达最终拥有焦点的那个节点。因为一个窗口中只有一个焦点视图，因此焦路径也只有一条，而焦点视图是会发生变化的，所以可以推测，系统在建立新的焦点路径时，会将原来的那条焦点路径删除。\n现在我们来分析系统建立和删除焦点路径的过程。我们知道，View 成功获取焦点是在 handleFocusGainInternal() 中进行的，因此我们可以以这个方法为切入点追踪系统建立焦点路径的过程。handleFocusGainInternal() 定义如下：\nvoid handleFocusGainInternal(@FocusRealDirection int direction, Rect previouslyFocusedRect) &#123;    if (DBG) &#123;        System.out.println(this + &quot; requestFocus()&quot;);    &#125;    if ((mPrivateFlags &amp; PFLAG_FOCUSED) == 0) &#123;        mPrivateFlags |= PFLAG_FOCUSED;        View oldFocus = (mAttachInfo != null) ? getRootView().findFocus() : null;        if (mParent != null) &#123;            mParent.requestChildFocus(this, this);            updateFocusedInCluster(oldFocus, direction);        &#125;        if (mAttachInfo != null) &#123;            mAttachInfo.mTreeObserver.dispatchOnGlobalFocusChange(oldFocus, this);        &#125;        onFocusChanged(true, direction, previouslyFocusedRect);        refreshDrawableState();    &#125;&#125;\n这个方法做的事很简单：将这个 View 的 PFLAG_FOCUSED 标志位设为 1，也就是让其成功地获取了焦点；然后调用其父 View 的 requestChildFocus() 方法。这个方法有两个参数，第一个参数传入的是调用父 View 该方法的那个子 View；后面那个参数传入的是具有焦点的那个 View。因为此 View 既是调用父 View 方法的 View，又是具有焦点的 View，所以两个参数传入的都是自身。这个方法的定义在 ViewGroup 中：\npublic void requestChildFocus(View child, View focused) &#123;    if (DBG) &#123;        System.out.println(this + &quot; requestChildFocus()&quot;);    &#125;    if (getDescendantFocusability() == FOCUS_BLOCK_DESCENDANTS) &#123;        return;    &#125;    // Unfocus us, if necessary    super.unFocus(focused);    // We had a previous notion of who had focus. Clear it.    if (mFocused != child) &#123;        if (mFocused != null) &#123;            mFocused.unFocus(focused);        &#125;        mFocused = child;    &#125;    if (mParent != null) &#123;        mParent.requestChildFocus(this, focused);    &#125;&#125;\n\n这个方法的逻辑很清晰：先是调用父类 View 的 unFoucs() 方法执行清除自身焦点的逻辑，当然，可能这个 ViewGroup 可能本来就不具有焦点；再判断这个 ViewGroup 的 mFocused 变量和调用此方法的子 View 是不是同一个，如果不是，那么就在 mFocused 不为空的前提下调用其 unFocus() 方法，再将子 View 的值赋给 mFocused；最后，如果这个 ViewGroup 的 mParent 不为空，递归调用其 requestChildFocus() 方法，并分别将自身和具有焦点的那个 View 作为参数传入。\n结合之前对 unFocus() 的分析可知：如果不考虑递归，requestChildFocus() 的效果是：将该 ViewGroup 的 mFocused 变量置为调用此方法的子 View，并清除自身可能拥有的焦点；如果考虑递归，这个方法的效果是，清除自身可能拥有的焦点，并将上一条焦点路径上从该 ViewGroup 节点开始的所有后续中间节点的 mFocused 变量置为 null，将上一条焦点路径的终止节点的焦点清除，且将从根节点开始一直到此节点的这条路径上的所有节点的 mFocused 值赋为该节点在此路径上的后继节点。因为最开始调用 requestChildFocus() 方法的 View 是那个具有焦点的 View，因此，最终的效果便是：清除上一次的焦点路径，并建立一条从根节点到具有焦点的 View 的焦点路径。\n确定焦点的过程我们知道，如果我们新建一个只有一个 EditText 的 Activity，这个 EditText 在 Activity 启动时会自动获取焦点，那么系统是如何让这个 EditText 获取焦点的呢？现在我们来分析下。\n由之前的分析可知，View 通过是否设置标志位 PFLAG_FOCUSED 来标志自己是否拥有焦点，而在 View 的源码中发现只有 handleFocusGainInternal() 方法给 View 设置了这个标志位，因此可以认为 handleFocusGainInternal() 就是给 View 设置焦点的方法。我们可以通过 Android Studio 调试器的调用栈来分析这个方法的调用过程。我们在 Activity 中新建一个 EditText，因为当 Activity 启动时这个 EditText 会获取焦点，因此它的 handleFocusGainInternal() 方法会被调用。我们在 handleFocusGainInternal() 方法处设置断点，以调试模式启动这个 app。我们会发现程序一启动，就在断点处终止了，我们看看此时调试器中的方法栈：\n\n根据方法栈我们可以一直追踪到 ViewRootImpl#focusableViewAvailable()，是这个方法触发了焦点的确定过程：\n@Overridepublic void focusableViewAvailable(View v) &#123;    checkThread();    if (mView != null) &#123;        if (!mView.hasFocus()) &#123;            if (sAlwaysAssignFocus) &#123;                v.requestFocus();            &#125;        &#125; else &#123;            // the one case where will transfer focus away from the current one            // is if the current view is a view group that prefers to give focus            // to its children first AND the view is a descendant of it.            View focused = mView.findFocus();            if (focused instanceof ViewGroup) &#123;                ViewGroup group = (ViewGroup) focused;                if (group.getDescendantFocusability() == ViewGroup.FOCUS_AFTER_DESCENDANTS                        &amp;&amp; isViewDescendantOf(v, focused)) &#123;                    v.requestFocus();                &#125;            &#125;        &#125;    &#125;&#125;\n\n这个方法调用了参数 v 的 requestFocus() 方法，v 的实际类型是 DecorView，它就是根布局。因此，系统确定焦点的过程其实就是简单的调用了根部局的 requestFocus() 方法。因此，结合前面对 requestFocus() 和 onRequestFocusInDescendants() 方法的分析可知，根部局的这个方法会通过深度优先的方式调用视图树中各节点的 requestFocus() 方法。在时间顺序上，第一个该方法返回 true 的节点在成功地获取了焦点的同时会遍历终止，然后走建立新焦点路径和删除旧焦点路径的流程。在此节点之后 requestFocus() 方法返回 true 的节点将成为焦点路径上的中间节点，最后一个返回 true 的节点便是焦点路径的起始节点，也就是根节点。\n总结对于 View 来说，是否具有焦点将影响它的绘制，如果这个 View 是 EditText，是否具有焦点还会决定它能否获取键盘输入。如果我们想通过代码在某个没有焦点的 EditText 上弹出键盘，仅仅通过 InputMethodManager#showSoftInput() 是不够的，还需在此之前调用其 requestFocus() 方法让其获取焦点。而对于 ViewGroup 来说，焦点通常不会对绘制和输入带来影响，但是它需要根据自身特点处理后代的焦点问题，比如，对于 ViewPager，在换页的时候，如果不重新分配焦点的话，焦点可能还会停留在上一个页面中，因此需要调用下一个页面的根部局的 requestFocus() 让它或者它的后代拥有获取焦点的机会，我们可以在 ViewPager 的源码中看到这种处理。\n","tags":["Android","View"]},{"title":"Glide 源码探究","url":"/2017/07/20/2017-7-20-android-open-source-library-glide/","content":"Glide 源码探究前言Glide 是安卓平台上媒体管理和图片加载框架，它内部封装了媒体解码工具、内存和磁盘缓存以及资源池等，并向用户暴露简单易用的接口。我们可以用它来获取、解码、并展示视频、图片和 GIF 动画。如果大家有用过 Picasso 应该知道，Glide 的使用方式和 Picasso 非常相似，甚至很多 API 的名称都一样。但是相比 Picasso，Glide 的功能更加强大，内部实现也更加复杂。接下来我们就从源码的角度来探究一下 Glide 的内部原理。\n\n\nGlide 的简单使用在探究 Glide 的原理之前，我们先熟悉一下它的常见 API，这样有助于我们后面的分析。Glide 的 API 使用了流式 API 风格，加载图片一行代码就能搞定：\nGlide.with(context).load(url).into(imageView);\n当然，以上只是 Glide 最基础、最常见的用法，它的功能远不止于此，基本上关于图片加载的需求它都能满足。上面这行代码调用了三次方法，经历了三个不同的过程：with() 方法用来获取 RequestManager；load() 方法根据传入的 url 返回了一个 RequestBuilder 对象；into() 方法创建了图片加载请求对象 Request 并开启了加载工作。现在，我们就来分析这三个过程。\nGlide 原理获取 RequestManagerGlide 的 with(Context) 方法返回的不是 Glide 实例，而是一个 RequestManager 对象，顾名思义，它用来管理图片加载请求。with() 方法有多个重载，除了接受 Context，它还可以接受 Activity，Fragment，View 等对象，这些重载方法如下：\n[-&gt;Glide.java]\npublic static RequestManager with(Context context) &#123;    return getRetriever(context).get(context);&#125;public static RequestManager with(Activity activity) &#123;    return getRetriever(activity).get(activity);&#125;public static RequestManager with(android.app.Fragment fragment) &#123;    return getRetriever(fragment.getActivity()).get(fragment);   &#125;public static RequestManager with(View view) &#123;    return getRetriever(view.getContext()).get(view);&#125;\n上面这几个重载方法长得都差不多，结果都是返回一个 RequestManager 对象。这个过程分为两步：先通过 getRetriver() 获取一个 RequestManagerRetriever 对象，再通过这个对象的 get() 方法来获取 RequestManager。先看下 getRetriver() 方法：\n[-&gt;Glide.java]\nprivate static RequestManagerRetriever getRetriever(@Nullable Context context) &#123;    ......    return Glide.get(context).getRequestManagerRetriever();&#125;\n\n静态方法 Glide#get() 创建了 Glide 单例，然后通过它的 getRequestManagerRetriever() 返回一个 RequesetManagerRetriever 对象。RequestManagerRetriever 顾名思义，是用来获取 ReqeustManager 的，那么它是怎样得到 RequestManager 对象的呢？我们先来分析下它的一个参数类型为 Context 的 get() 重载方法 ：\n[-&gt;RequestManagerRetriever.java]\npublic RequestManager get(Context context) &#123;  if (context == null) &#123;    throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);  &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123;    if (context instanceof FragmentActivity) &#123;      return get((FragmentActivity) context);    &#125; else if (context instanceof Activity) &#123;      return get((Activity) context);    &#125; else if (context instanceof ContextWrapper) &#123;      return get(((ContextWrapper) context).getBaseContext());    &#125;  &#125;  return getApplicationManager(context);&#125;\n这个方法最终会转调两类方法：一是 get() 重载方法，二是 getApplicationManager()。调用 get() 方法的时机是：当前线程在主线程，并且 Context 的实际类型为 FragmentActivity，Activity 和 ContextWrapper 其中之一。其他情况下都会调用 getApplicationManager()。我们看看 get(Activity)：\n[-&gt;RequestManagerRetriever.java]\npublic RequestManager get(Activity activity) &#123;  if (Util.isOnBackgroundThread()) &#123;    return get(activity.getApplicationContext());  &#125; else &#123;    assertNotDestroyed(activity);    android.app.FragmentManager fm = activity.getFragmentManager();    return fragmentGet(activity, fm, null /*parentHint*/);  &#125;&#125;\n\n如果当前线程是后台线程，会再次调用 get(Context) 方法，因为传入的 Context 是 ApplicationContext，因此这个方法最终会调用 getApplicationManager(Context)；如果不是后台线程，在 Activity 还没销毁的前提下，会调用 fragmentGet()。get(FragmentActivity) 的逻辑和 get(Activity) 类似，这里就不赘述了，有兴趣可以自行查看源码。\n假设加载动作发生在主线程，fragmentGet() 会得到调用，其源码如下：\n[-&gt;RequestManagerRetriever.java]\nprivate RequestManager fragmentGet(Context context, android.app.FragmentManager fm,    android.app.Fragment parentHint) &#123;  RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);  RequestManager requestManager = current.getRequestManager();  if (requestManager == null) &#123;    Glide glide = Glide.get(context);    requestManager =        factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode());    current.setRequestManager(requestManager);  &#125;  return requestManager;&#125;// 获取当前 FragmentManager 中的 RequestManagerFragmentRequestManagerFragment getRequestManagerFragment(    final android.app.FragmentManager fm, android.app.Fragment parentHint) &#123;  // 根据 TAG 查找  RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);  if (current == null) &#123;    current = pendingRequestManagerFragments.get(fm);    if (current == null) &#123;      current = new RequestManagerFragment();      current.setParentFragmentHint(parentHint);      pendingRequestManagerFragments.put(fm, current);      // 将创建的 RequestManagerFragment 添加到 FragmentManager 中      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();      handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();    &#125;  &#125;  return current;&#125;\n\n通过上面的代码可以知道，get(Activity) 方法的逻辑是从当前 Activity 中找 RequestManagerFragment，有则从其中取出 RequestManager，无则创建一个ReqeustManagerFragment 和 RequestManager，将 RequestManagerFragment 和 RequestManager 关联之后把 RequestManager 对象返回。这里有一个比较奇怪的地方：为什么要创建 RequestManagerFragment？我们看下 RequestManagerFragment 的文档说明：\n\nA view-less {@link android.app.Fragment} used to safely store an {@link com.bumptech.glide.RequestManager} that can be used to start, stop and manage Glide requests started for targets the fragment or activity this fragment is a child of.\n\n通过文档可知，其实 Glide 在这里使用了 “奇技淫巧”，它借助 RequestManagerFragment 来跟踪 Activity 或者 Fragment 的生命周期。为什么要这么做呢？这要从图片加载的场景来理解。本着减少网络请求及各种资源消耗的目的，通常我们会希望如果当前界面被覆盖或者被销毁，图片是不进行加载的。而图片加载库如何能感知界面被覆盖和被销毁呢？我们知道 Activity 或者 Fragment 的生命周期其实和交互界面的变化是相关联的，因此可以利用 Activity 或者 Fragment 的生命周期来驱动图片的加载过程，比如可以在 onStart() 方法中开始图片加载，在 onStop() 方法中暂停图片的加载。然而，如果要在客户端代码中的每一个 Activity 或者 Fragment 中加入这些逻辑，首先代码显得混乱、冗余；其次将图片的加载管理交给开发者实现，增加了开发者的工作，开发者必须实现一套行之有效的图片加载管理方案，这显然不是一个优秀的图片加载库应该做的事。那怎么办呢？这时候 RequestManagerFragment 就派上用场了，如果将 RequestManagerFragment 动态添加入当前的 Activity 或者 Fragment 中，那么 RequestManagerFragment 也将获得生命周期，就可以用 RequestManagerFragment 生命周期来驱动 Glide 的加载。RequestManagerRetriever 的所有 get() 方法，其实都在做同一件事情：根据传入的参数找到当前加载环境关联的 Activity 或者 Fragment，然后设法将 RequesManagerFragment 嵌入其中，最后返回具备生命周期的 RequestManager。我们可以通过 get(View) 来进一步验证：\n[-&gt;RequestManagerRetriever.java]\npublic RequestManager get(@NonNull View view) &#123;  if (Util.isOnBackgroundThread()) &#123;    // 最终会调用 get(Context)，最终调用 getApplicationManager()    return get(view.getContext().getApplicationContext());  &#125;  Preconditions.checkNotNull(view);  Preconditions.checkNotNull(view.getContext(),      &quot;Unable to obtain a request manager for a view without a Context&quot;);  Activity activity = findActivity(view.getContext());  // The view might be somewhere else, like a service.  if (activity == null) &#123;    return get(view.getContext().getApplicationContext());  &#125;  if (activity instanceof FragmentActivity) &#123;    Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);    return fragment != null ? get(fragment) : get(activity);  &#125;  // Standard Fragments.  android.app.Fragment fragment = findFragment(view, activity);  if (fragment == null) &#123;    return get(activity);  &#125;  return get(fragment);&#125;\n\nget(View) 会取出 View 中的 Context 进行判断，如果 Context 没有关联到 Activity 或 Fragment 或者图片加载动作发生在后台，那么会调用 get(Context)，因为传入的是 Context 是 ApplicationContext，因此最终会调用 getApplicationManager()。如果 View 直接关联到 Activity，那么会调用 get(Activity) 或者 get(FragmentActivity) ，如果是直接关联到 Fragment 便会调用 get(Fragment)。\n这样看来，每个 Activity 和 Fragment 都会有一个 RequestManagerFragment（前提是有图片加载动作），而每一个 RequestManagerFragment 都关联着一个 RequestManager。也就是说，每一个 Activity 或者 Fragment 都对应着一个 RequestManager。那么 RequestManager 是如何获取生命周期的呢？上面的 fragmentGet() 中有这样一行代码：\n[-&gt;RequestManagerRetriever.java]\nrequestManager =        factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode());\n\n这行代码是赋予 RequestManager 生命周期的核心方法。factory 的实际类型是 GeneratedRequestManagerFactory，current 是 RequestManagerFragment 对象，getGlideLifecycle() 方法返回的是 ActivityFragmentLifecycle 对象，它实现了 Lifecycle 接口。\n[-&gt;RequestManagerFragment.java]\nActivityFragmentLifecycle getGlideLifecycle() &#123;  return lifecycle;&#125;class ActivityFragmentLifecycle implements Lifecycle &#123;  private final Set&lt;LifecycleListener&gt; lifecycleListeners =      Collections.newSetFromMap(new WeakHashMap&lt;LifecycleListener, Boolean&gt;());  private boolean isStarted;  private boolean isDestroyed;  @Override  public void addListener(LifecycleListener listener) &#123;    lifecycleListeners.add(listener);    if (isDestroyed) &#123;      listener.onDestroy();    &#125; else if (isStarted) &#123;      listener.onStart();    &#125; else &#123;      listener.onStop();    &#125;  &#125;  @Override  public void removeListener(LifecycleListener listener) &#123;    lifecycleListeners.remove(listener);  &#125;  void onStart() &#123;    isStarted = true;    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;      lifecycleListener.onStart();    &#125;  &#125;  void onStop() &#123;    isStarted = false;    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;      lifecycleListener.onStop();    &#125;  &#125;  void onDestroy() &#123;    isDestroyed = true;    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;      lifecycleListener.onDestroy();    &#125;  &#125;&#125;\n\nLifecycle 是一个管理生命周期监听器的接口。ActivityFragmentLifecycle 在实现接口的基础上增加了三个生命周期方法，它们会遍历所有的 LifecycleListener，调用其相应的生命周期方法。这三个方法主要是用来和 RequestManagerFragment 的生命周期对接：\n[-&gt;RequestManagerFragment.java]\n@Overridepublic void onStart() &#123;  super.onStart();  lifecycle.onStart();&#125;@Overridepublic void onStop() &#123;  super.onStop();  lifecycle.onStop();&#125;@Overridepublic void onDestroy() &#123;  super.onDestroy();  lifecycle.onDestroy();  unregisterFragmentWithRoot();&#125;\n\n因此，任何实现 LifecycleListener 的类可通过 addListener() 添加到 ActivityFragmentLifecycle 中从而获得生命周期。那么我们可以猜测 RequestManager 一定实现了 LifecycleListener 接口，事实也的确如此。那么 RequestManager 是如何添加进 ActivityFragmentLifecycle 中的呢？ 答案就在 RequestManager 的构造方法中：\n[-&gt;RequestManager.java]\nRequestManager(    Glide glide,    Lifecycle lifecycle,    RequestManagerTreeNode treeNode,    RequestTracker requestTracker,    ConnectivityMonitorFactory factory,    Context context) &#123;  this.glide = glide;  this.lifecycle = lifecycle;  this.treeNode = treeNode;  this.requestTracker = requestTracker;  this.context = context;  connectivityMonitor =      factory.build(          context.getApplicationContext(),          new RequestManagerConnectivityListener(requestTracker));  // If we&#x27;re the application level request manager, we may be created on a background thread.  // In that case we cannot risk synchronously pausing or resuming requests, so we hack around the  // issue by delaying adding ourselves as a lifecycle listener by posting to the main thread.  // This should be entirely safe.  if (Util.isOnBackgroundThread()) &#123;    mainHandler.post(addSelfToLifecycle);  &#125; else &#123;    lifecycle.addListener(this);  &#125;  lifecycle.addListener(connectivityMonitor);  setRequestOptions(glide.getGlideContext().getDefaultRequestOptions());  glide.registerRequestManager(this);&#125;\n\n这里根据当前线程决定如何将 RequestManager 添加至 Lifecycle 中。如果子线程，通过 post 添加；如果 UI 线程，就直接添加。原因注释里说的很清楚了，如果是 Application 级别的 RequestManager，也就是通过 getApplicationManager() 得到的那个 RequestMangaer，它可能创建于子线程中，那么就有可能冒同步停止和继续请求的风险。其实这段话我也没理解：），等以后上网查资料解决吧。\nget() 方法之间的调用关系可能有点复杂，贴上一张图便于理解：\n\n从上图可以看出几乎在所有的 get() 重载方法中，都会根据特殊情况直接或间接调用 getApplicationManager() 方法，这种特殊情况就是加载动作发生在后台线程或者无法找到关联的 Activity 或者 Fragment，此方法返回的 RequestManager 是没有生命周期的。这样做的目的是什么呢？我们知道生命周期是在 UI 线程接受回调的，让子线程也接受生命周期回调也不是不可以，但是子线程在加载，UI 线程通过生命周期也介入加载过程，相当于两个线程同时操作数据，这会带来线程安全问题，如果做同步，需要同步的地方很多，那么会带来严重的性能问题；而如果没有关联到 Activity 或者 Fragment，无法接受生命周期回调。对于这两种情况，Glide 没有办法，只能任其加载而不受生命周期控制，算是一种折中了吧。getApplicationManager() 的定义如下： \n[-&gt;RequestManagerRetriever.java]\nprivate RequestManager getApplicationManager(@NonNull Context context) &#123;  // Either an application context or we&#x27;re on a background thread.  if (applicationManager == null) &#123;    synchronized (this) &#123;      if (applicationManager == null) &#123;        // Normally pause/resume is taken care of by the fragment we add to the fragment or        // activity. However, in this case since the manager attached to the application will not        // receive lifecycle events, we must force the manager to start resumed using        // ApplicationLifecycle.        // TODO(b/27524013): Factor out this Glide.get() call.        Glide glide = Glide.get(context.getApplicationContext());        applicationManager = factory.build(glide, new ApplicationLifecycle(),                new EmptyRequestManagerTreeNode(),                context.getApplicationContext());      &#125;    &#125;  &#125;  return applicationManager;&#125;\n\n这个方法也有这样一行代码：\n[-&gt;RequestManagerRetriever.java]\napplicationManager = factory.build(glide, new ApplicationLifecycle(),                new EmptyRequestManagerTreeNode(),                context.getApplicationContext());\n\napplicationManager 也是通过 GeneratedRequestManagerFactory#build() 来创建的，但第二个参数和之前的有所不同，这里直接 new 了一个 ApplicationLifecycle() 传进去。ApplicationLifecycle 的定义如下：\n[-&gt; ApplicationLifecycle.java]\nclass ApplicationLifecycle implements Lifecycle &#123;  @Override  public void addListener(LifecycleListener listener) &#123;    listener.onStart();  &#125;  @Override  public void removeListener(LifecycleListener listener) &#123;    // Do nothing.  &#125;&#125;\n可以看出，这个 ApplicationLifecycle 其实是个假 Lifecycle，因为他根本没有将 LifecycleListener 添加进去，仅仅是立马调用了其 onStart() 方法。由此可见，getApplicationManager() 获取的是没有生命周期的 RequestManager。最后用一张图来总结 RequestManager 的获取过程：\n\n创建 RequestBuilder前面我们分析了 Request 的获取过程，既然请求管理器建好了，那么下一步肯定是构建请求了。Glide 使用建造者模式来构建 Request，这个构建者就是 RequestBuilder。建造者模式通常是这样的，通过构建器收集参数，最后调用其 build() 或 create() 方法构建目标对象。那么 RequestBuilder 为了构造一个 Request 会收集哪些参数呢？我们看看它的声明的字段：  \n[-&gt;RequestBuilder.java]\nprivate final Context context;private final RequestManager requestManager; // 关联的 RequestManagerprivate final Class&lt;TranscodeType&gt; transcodeClass; // 图片资源最终要转换成的对象类型private final RequestOptions defaultRequestOptions; // 默认的请求选项private final Glide glide;private final GlideContext glideContext; // Glide 上下文，精简版的 Glide@NonNull protected RequestOptions requestOptions; // 请求选项@NonNull@SuppressWarnings(&quot;unchecked&quot;)private TransitionOptions&lt;?, ? super TranscodeType&gt; transitionOptions; // 渐变动画选项@Nullable private Object model;// model may occasionally be null, so to enforce that load() was called, put a boolean rather// than relying on model not to be null.@Nullable private RequestListener&lt;TranscodeType&gt; requestListener; // 请求监听器@Nullable private RequestBuilder&lt;TranscodeType&gt; thumbnailBuilder; // 缩略图@Nullable private RequestBuilder&lt;TranscodeType&gt; errorBuilder; // 错误图@Nullable private Float thumbSizeMultiplier;// 缩略图的缩放因子private boolean isDefaultTransitionOptionsSet = true;private boolean isModelSet;private boolean isThumbnailBuilt;\n我们看下 RequestOptions 这个类，它是请求的附加选项，在发起一个图片请求时，我们可能对它会有一些特殊的要求，此时就可以通过 RequestOptions 来添加这些要求，ReqeustOptions 的定义：\n[-&gt;RequestOptions.java]\npublic class RequestOptions implements Cloneable &#123;  private static final int UNSET = -1;  private static final int SIZE_MULTIPLIER = 1 &lt;&lt; 1;  private static final int DISK_CACHE_STRATEGY = 1 &lt;&lt; 2;  private static final int PRIORITY = 1 &lt;&lt; 3;  private static final int ERROR_PLACEHOLDER = 1 &lt;&lt; 4;  private static final int ERROR_ID = 1 &lt;&lt; 5;  private static final int PLACEHOLDER = 1 &lt;&lt; 6;  private static final int PLACEHOLDER_ID = 1 &lt;&lt; 7;  private static final int IS_CACHEABLE = 1 &lt;&lt; 8;  private static final int OVERRIDE = 1 &lt;&lt; 9;  private static final int SIGNATURE = 1 &lt;&lt; 10;  private static final int TRANSFORMATION = 1 &lt;&lt; 11;  private static final int RESOURCE_CLASS = 1 &lt;&lt; 12;  ......  private int fields;  private float sizeMultiplier = 1f;  private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC;  private Priority priority = Priority.NORMAL;  private Drawable errorPlaceholder;  private int errorId;  private Drawable placeholderDrawable;  private int placeholderId;  private boolean isCacheable = true;  private int overrideHeight = RequestOptions.UNSET;  private int overrideWidth = RequestOptions.UNSET;  private Key signature = EmptySignature.obtain();  private boolean isTransformationRequired;  private boolean isTransformationAllowed = true;  private Drawable fallbackDrawable;  private int fallbackId;  private Options options = new Options();  private Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations = new HashMap&lt;&gt;();  private Class&lt;?&gt; resourceClass = Object.class;  ......&#125;\n\n可以看出，请求的附加选项包括底盘缓存策略，请求优先级，占位图，兜底图等常见选项，这些选项全部通过标志位来标识是否设立新值，为什么通过标志位来表示？因为很多选项都有默认值，通过判空来判断它们是否设定了新值是行不通的。RequestOptions 是可以合并的，两个 RequestOptions 可以合并成一个 RequestOptions，这个功能由 RequestOptions#apply(RequestOptions) 来实现。例如 A 想合并 B，可以这样： C &#x3D; A.apply(B) ，结果是 B 中的新值会覆盖 A 中的值，B 中的默认值不会覆盖 A 中的值。\n现在我们回头再看看 RequestManager 的 load() 方法：\n[-&gt;RequestManager.java]\npublic RequestBuilder&lt;Drawable&gt; load(@Nullable Drawable drawable) &#123;  return asDrawable().load(drawable);&#125;public RequestBuilder&lt;Drawable&gt; load(@Nullable Bitmap bitmap) &#123;  return asDrawable().load(bitmap);&#125;public RequestBuilder&lt;Drawable&gt; load(@Nullable Object model) &#123;  return asDrawable().load(model);&#125;public RequestBuilder&lt;Drawable&gt; asDrawable() &#123;  return as(Drawable.class).transition(new DrawableTransitionOptions());&#125;public &lt;ResourceType&gt; RequestBuilder&lt;ResourceType&gt; as(Class&lt;ResourceType&gt; resourceClass) &#123;  return new RequestBuilder&lt;&gt;(glide, this, resourceClass, context);&#125;\n\nas() 方法构建了一个 RequestBuilder 并指明了 resourceClass，这个 resourceClass 就是 RequestBuilder 中的  transcodeClass，表明图片资源最终转换成的对象。 asDrawable() 方法创建了一个 transcodeClass 为 Drawable 的 RequestBuilder，并且指定了 transitionOptions 的值。而 load() 方法最为最外层的方法，首先调用了 asDrawable()，然后调用 RequestBuilder#load() 将 model 传进去。\n[-&gt;ReuqestBuilder.java]\npublic RequestBuilder&lt;TranscodeType&gt; load(@Nullable Uri uri) &#123;  return loadGeneric(uri);&#125;public RequestBuilder&lt;TranscodeType&gt; load(@Nullable File file) &#123;  return loadGeneric(file);&#125;public RequestBuilder&lt;TranscodeType&gt; load(@Nullable Drawable drawable) &#123;  return loadGeneric(drawable)      .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));&#125;public RequestBuilder&lt;TranscodeType&gt; apply(@NonNull RequestOptions requestOptions) &#123;  Preconditions.checkNotNull(requestOptions);  this.requestOptions = getMutableOptions().apply(requestOptions);  return this;&#125;private RequestBuilder&lt;TranscodeType&gt; loadGeneric(@Nullable Object model) &#123;  this.model = model;  isModelSet = true;  return this;&#125;\n\n[-&gt;RequestOptions.java]\npublic static RequestOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy diskCacheStrategy) &#123;  return new RequestOptions().diskCacheStrategy(diskCacheStrategy);&#125;\nRequestBuilder 中有很多 load() 方法，上面只列举了一部分。以上三个 load() 方法都会转调 loadGeneric() 方法，第三个 load() 还会合并一个指定了磁盘缓存策略的 RequestOptions。loadGeneric() 做的事很简单，就是给 model 赋值。由此我们可以看出，model 的实际类型有很多种，可以是 Uri，也可以是 Bitmap，还可以是 File 等。\nRequestBuilder 的参数收集过程讲完了，下一步就是 Request 的构建过程了。从上面的分析可知，RequestManager#load() 方法返回的既然是 RequestBuilder，那 Request 的构建和执行一定都是在 into() 的调用栈中进行的。\nRequest 的构建和执行万事俱备，只欠东风。现在我们以 into() 为切入点，看看 Request 是如何构建和执行的。into() 定义在 RequestBuilder 中：\n[-&gt;RequestBuilder.java]\npublic &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(@NonNull Y target) &#123;  return into(target, /*targetListener=*/ null);&#125;@Synthetic &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(    @NonNull Y target,    @Nullable RequestListener&lt;TranscodeType&gt; targetListener) &#123;  return into(target, targetListener, getMutableOptions());&#125;public Target&lt;TranscodeType&gt; into(ImageView view) &#123;  ......  return into(context.buildImageViewTarget(view, transcodeClass), null,        requestOptions);&#125;\ninto() 有多个重载，但是最终都会调用一个含三个参数的重载方法。第三个 into() 我们很熟悉，我们经常使用它来将加载好的图片资源设置给 ImageView，这个 ImageView 在方法中会被包装成一个 Target 对象，然后传入含三个参数的 into() 重载方法中。Glide 把所有图片资源的目的用途抽象成 Target，这一点很巧妙，因为图片加载库的使用场景有很多，除了可以将它设置给 ImageView，还可以存入磁盘文件，内存，或者其他用途。我们可以看看 Target 的定义：\n[-&gt;Target.java]\npublic interface Target&lt;R&gt; extends LifecycleListener &#123;  void onLoadStarted(@Nullable Drawable placeholder);  void onLoadFailed(@Nullable Drawable errorDrawable);  void onResourceReady(@NonNull R resource, @Nullable Transition&lt;? super R&gt; transition);  void getSize(@NonNull SizeReadyCallback cb);  void removeCallback(@NonNull SizeReadyCallback cb);  void setRequest(@Nullable Request request);  @Nullable  Request getRequest();&#125;\n\n我们可以根据自己的需要实现 Target 接口，从而自定义图片资源的用途。buildImageViewTarget() 返回的是一个 ImageViewTarget 对象，它是一个抽象类，继承自 ViewTarget，有两个子类 BitmapImageViewTarget 和 DrawableImageViewTarget，前者的接收的图片资源类型是 Bitmap，后者是 Drawable。\n[-&gt;ImageViewTarget.java]\n@Overridepublic void onLoadStarted(@Nullable Drawable placeholder) &#123;  super.onLoadStarted(placeholder);  setResourceInternal(null);  setDrawable(placeholder);&#125;@Overridepublic void onLoadFailed(@Nullable Drawable errorDrawable) &#123;  super.onLoadFailed(errorDrawable);  setResourceInternal(null);  setDrawable(errorDrawable);&#125;@Overridepublic void onLoadCleared(@Nullable Drawable placeholder) &#123;  super.onLoadCleared(placeholder);  if (animatable != null) &#123;    animatable.stop();  &#125;  setResourceInternal(null);  setDrawable(placeholder);&#125;@Overridepublic void onResourceReady(@NonNull Z resource, @Nullable Transition&lt;? super Z&gt; transition) &#123;  if (transition == null || !transition.transition(resource, this)) &#123;    setResourceInternal(resource);  &#125; else &#123;    maybeUpdateAnimatable(resource);  &#125;&#125;private void setResourceInternal(@Nullable Z resource) &#123;  setResource(resource);  maybeUpdateAnimatable(resource);&#125;// 因为 ImageView 可接受 Bitmap 和 Drawable 这两种图片资源类型，因此抽象出这个方法供子类实现protected abstract void setResource(@Nullable Z resource);\n\n现在看下 RequestBuilder 含三个参数的 into() 方法：\n[-&gt;RequestBuilder.java]\nprivate &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(    @NonNull Y target,    @Nullable RequestListener&lt;TranscodeType&gt; targetListener,    @NonNull RequestOptions options) &#123;  Util.assertMainThread();  Preconditions.checkNotNull(target);  if (!isModelSet) &#123;    throw new IllegalArgumentException(&quot;You must call #load() before calling #into()&quot;);  &#125;  options = options.autoClone();  Request request = buildRequest(target, targetListener, options);  Request previous = target.getRequest();  if (request.isEquivalentTo(previous)      &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;    request.recycle();    // If the request is completed, beginning again will ensure the result is re-delivered,    // triggering RequestListeners and Targets. If the request is failed, beginning again will    // restart the request, giving it another chance to complete. If the request is already    // running, we can let it continue running without interruption.    if (!Preconditions.checkNotNull(previous).isRunning()) &#123;      // Use the previous request rather than the new one to allow for optimizations like skipping      // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions      // that are done in the individual Request.      previous.begin();    &#125;    return target;  &#125;  requestManager.clear(target);  target.setRequest(request); // 将 target 和 request 关联起来  requestManager.track(target, request); // 将 target 和 request 添加进 requestManager 进行管理  return target;&#125;\n\nbuildRequest() 创建了一个 Request，之后会判断这个 target 当前关联的 Request 是不是和这个新的 Request 是不是等效的，如果是，并且 isSkipMemoryCacheWithCompletePreviousRequest() 返回 false，便将这个新的 Request 回收掉，避免一个目标上有多个请求。然后判断之前的那个 Request 是不是还在跑，如果没有，那么就启动它，为什么这样做？注释里已经说的很清楚了，就是为了将当前绑定在 target 上的请求再执行一遍，这样请求完成后会将结果重新传递一遍；如果正在跑，没必要重启这个请求，因为请求完成之后会将结果传递回去。对于 isSkipMemoryCacheWithCompletePreviousRequest() 这个方法，其实有必要分析一下，为什么它返回 false 的时候才能将新的 Request 取消，不过目前为止我还没有完全理解，但还是先贴上这个方法供大家自行理解：\n[-&gt;RequestBuilder.java]\n// If the caller is using skipMemoryCache and the previous request is finished, calling begin on// the previous request will complete from memory because it will just use the resource that had// already been loaded. If the previous request isn&#x27;t complete, we can wait for it to finish// because the previous request must also be using skipMemoryCache for the requests to be// equivalent. See #2663 for additional context.private boolean isSkipMemoryCacheWithCompletePreviousRequest(    RequestOptions options, Request previous) &#123;  return !options.isMemoryCacheable() &amp;&amp; previous.isComplete();&#125;\n\n回到 into() 方法，真正处理加载请求的方法是 RequestManager#track() 方法：\n[-&gt;RequestManager.java]\nvoid track(Target&lt;?&gt; target, Request request) &#123;  targetTracker.track(target);  requestTracker.runRequest(request);&#125;\n\nRequestManager 中有两个 “追踪器”，一个是 TargetTracker，另一个是 RequestTracker，前者用来管理 target，后者管理 request。由于 TargetTracker 和 Target 都实现了 LifecycleListener 接口，这样生命周期就能从 RequestManager 传到 Target。真正启动请求的方法是 RequestTracker#runRequest() ：\n[-&gt;RequestTracker.java]\npublic void runRequest(Request request) &#123;  requests.add(request);  if (!isPaused) &#123;    request.begin(); // 执行请求  &#125; else &#123;    pendingRequests.add(request);  &#125;&#125;\n\nRequestTracker 首先将 request 加入请求列表 requests 中，这个列表保存的是所有请求；然后判断是否需要暂停加载（受生命周期的控制），如果是，则开始请求，否则将这个请求放入待处理队列 pendingRequests 中。为什么要用一个 pendingRequest 来管理这些待处理请求呢？其实并不是为了将他们储存起来待以后执行，而仅仅是为了让他们不被回收。requests 持有的是 Request 的弱引用，如果请求没有马上执行，这些 Request 仅仅被弱引用持有，那么就有被回收的可能，将他们放入 pendingRequests 中就是为了让他们被强引用持有防止被回收。更详细的解释可以看看这个 issue。\nRequest 是一个接口，它包含多了很多控制方法和状态查询方法。Request 在当前 Glide 版本中只有一个实现者：SingleRequest。SingleRequest 的 begin() 方法如下：\n[-&gt;SingleRequest.java]\npublic void begin() &#123;  ......  if (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;    onSizeReady(overrideWidth, overrideHeight);  &#125; else &#123;    target.getSize(this);   &#125;  if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)      &amp;&amp; canNotifyStatusChanged()) &#123;    target.onLoadStarted(getPlaceholderDrawable());  &#125;  ......&#125;\n\nbegin() 是 Request 的入口方法，它开启了图片请求的处理流程，而整个流程的第一步就是获取期望的图片宽高。第一个 if 语句块，它会判断用户是否显式要求了图片宽高，如果指明了，那么立马执行 onSizeReady()，否则执行 Target#getSize()。onSizeReady() 是 SingleRequest 实现的 SizeReadyCallback 接口中的方法。 \n[-&gt;Target.java]\nvoid getSize(@NonNull SizeReadyCallback cb);\n\ngetSize() 的作用就是用来获取图片的宽高，获取成功之后就通过 SizeReadyCallback#onSizeRady() 将结果返回。Target 是目标用途的抽象，所以图片的宽高理应由它来指定。比如，对于 ViewTarget 来说，它的 getSize() 返回的就是 View 的宽高。这里我们可能就有疑问了，为什么 getSize() 要设计成异步的？其实答案很简单，对于 View 来说，它的宽高只有在 Activity#onResume() 之后才能获取到，严格来说是 View#layout() 之后才能获取到。请求发起时可能 View 的宽高还获取不到，因此将 getSize() 设计成异步的是理所应当的。现在重点是 onSizeReady() ：\n[-&gt;SingleRequest.java]\nloadStatus = engine.load(    glideContext,    model,    requestOptions.getSignature(),    this.width,    this.height,    requestOptions.getResourceClass(),    transcodeClass,    priority,    requestOptions.getDiskCacheStrategy(),    requestOptions.getTransformations(),    requestOptions.isTransformationRequired(),    requestOptions.isScaleOnlyOrNoTransform(),    requestOptions.getOptions(),    requestOptions.isMemoryCacheable(),    requestOptions.getUseUnlimitedSourceGeneratorsPool(),    requestOptions.getUseAnimationPool(),    requestOptions.getOnlyRetrieveFromCache(),    this);\n上面这段代码是 onSizeReady() 的主要逻辑，它调用了 Engine#load()，传入了一些和请求相关的各种参数，这个方法返回的是一个 LoadStatus 对象，关于它我们待会儿再分析。\n[-&gt;Engine.java]\nEngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,    resourceClass, transcodeClass, options);EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);if (active != null) &#123;  cb.onResourceReady(active, DataSource.MEMORY_CACHE);  ......  return null;&#125;EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);if (cached != null) &#123;  cb.onResourceReady(cached, DataSource.MEMORY_CACHE);  ......  return null;&#125;EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);if (current != null) &#123;  current.addCallback(cb);  ......  return new LoadStatus(cb, current);&#125;EngineJob&lt;R&gt; engineJob = engineJobFactory.build(key, isMemoryCacheable,        useUnlimitedSourceExecutorPool, useAnimationPool, onlyRetrieveFromCache);DecodeJob&lt;R&gt; decodeJob = decodeJobFactory.build(glideContext, model, key,        signature, width, height, resourceClass, transcodeClass, priority,        diskCacheStrategy, transformations, isTransformationRequired,        isScaleOnlyOrNoTransform, onlyRetrieveFromCache, options, engineJob);jobs.put(key, engineJob);engineJob.addCallback(cb);engineJob.start(decodeJob);......return new LoadStatus(cb, engineJob);\n\nEngine#load() 方法的逻辑是：\n\n首先构建出标识这个请求的 Key，这个 Key 用来标识一个请求，Key 相同的 Request 是等效的。可以看出这个 Key 有多个参数组成，只要其中一个参数不同，Key 就不同，那么这个 Request 也就是与众不同的；\n然后根据 Key 从 activy resource 中取出 EngineResource，EngineResource 是图片资源在内存中对应的对象，如果能找到，就调用 ResourceCallback#onResourceReady() 将获取的资源传回给 SingleRequest；\n如果上个步骤获取的 EngineResource 为 null，那么就从根据 Key 从 cache 中获取，如果能获取到，同样将结果回传；\n如果上个步骤获取的还是 null，那么在 jobs 中根据 Key 查找对应的 EngineJob。EngineJob 的作用文档中是这样说的：通过添加和移除回调、在加载任务完成时通知回调来管理一次加载。简单点说就是一次加载任务的回调管理器。如果能找到，便将 ResourceCallback 添加进去，然后返回一个 LoadStatus。这样做的目的就是避免重复请求，因为如果多个请求如果是等效的，没有必要为它们去加载多次，而只需要加载结果到来时逐个通知它们一遍就好。\n如果找不到对应的 EngineJob，没办法，只能开个的 EngineJob 了。通过 EngineJobFactory#build() 新建一个 EngineJob 紧接着又通过 DecodeJobFactory#build() 新建了一个 DecodeJob 并将 EngineJob 传进去。DecodeJob 对应的是一个加载任务，当完成加载后会通过 EngineJob 这个回调管理器将结果送回到 SingleRequest 中。\n\nDecodeJob 承包了真正的加载任务，现在我们就从 Engine#start() 开始来分析一下 DecodeJob：\n[-&gt;EngineJob.java]\npublic void start(DecodeJob&lt;R&gt; decodeJob) &#123;  this.decodeJob = decodeJob;  GlideExecutor executor = decodeJob.willDecodeFromCache()      ? diskCacheExecutor      : getActiveSourceExecutor();  executor.execute(decodeJob);&#125;\n\n根据需不需要从磁盘中获取资源，选择不同的线程池来执行资源加载任务。从这里可以看出 DecodeJob 实现了 Runnable 接口，因此资源加载逻辑应该全部在它的 run() 方法中：\n[-&gt;DecodeJob.java]\n@Overridepublic void run() &#123;  ......  DataFetcher&lt;?&gt; localFetcher = currentFetcher;  try &#123;    if (isCancelled) &#123;      notifyFailed();      return;    &#125;    runWrapped();  &#125; catch (Throwable t) &#123;    ......    // When we&#x27;re encoding we&#x27;ve already notified our callback and it isn&#x27;t safe to do so again.    if (stage != Stage.ENCODE) &#123;      throwables.add(t);      notifyFailed();    &#125;    if (!isCancelled) &#123;      throw t;    &#125;  &#125; finally &#123;    // Keeping track of the fetcher here and calling cleanup is excessively paranoid, we call    // close in all cases anyway.    if (localFetcher != null) &#123;      localFetcher.cleanup();    &#125;    TraceCompat.endSection();  &#125;&#125;\n\n\n其执行逻辑是：如果状态为 cancelled，或者任务执行时出现异常，那么就发出任务失败的通知；否则执行 runWrapper() 方法。\n[-&gt;DecodeJob.java]\nprivate void runWrapped() &#123;   switch (runReason) &#123;    case INITIALIZE:      stage = getNextStage(Stage.INITIALIZE);      currentGenerator = getNextGenerator();      runGenerators();      break;    case SWITCH_TO_SOURCE_SERVICE:      runGenerators();      break;    case DECODE_DATA:      decodeFromRetrievedData();      break;    default:      throw new IllegalStateException(&quot;Unrecognized run reason: &quot; + runReason);  &#125;&#125;\n\nrunWrapper() 方法会根据 runReason 的值执行不同的分支。runReason 的初始值是 INITIALIZE，INITIALIZE 这条分支做的事是：\n\n通过 getNextStage() 获取下一个 Stage，Stage 用来表明当前的工作阶段；\n通过 getNextGenerator() 获取下一个 DataFetcherGenerator，DataFetcherGenerator 顾名思义使用来产生 DataFethcer 的，关于 DataFetcher 及其作用之后会详细分析；\n执行 runGenerators()。\n\ngetNextStage() 的定义如下：\n[-&gt;DecodeJob.java]\nprivate Stage getNextStage(Stage current) &#123;  switch (current) &#123;    case INITIALIZE:      return diskCacheStrategy.decodeCachedResource()          ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);    case RESOURCE_CACHE:      return diskCacheStrategy.decodeCachedData()          ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);    case DATA_CACHE:      // Skip loading from source if the user opted to only retrieve the resource from cache.      return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;    case SOURCE:    case FINISHED:      return Stage.FINISHED;    default:      throw new IllegalArgumentException(&quot;Unrecognized stage: &quot; + current);  &#125;&#125;\n该方法根据当前的 Stage 返回下一个 Stage，它的状态变迁可以用下图来表示:\n\ngetNextGenerator() 的定义如下：\n[-&gt;DecodeJob.java]\nprivate DataFetcherGenerator getNextGenerator() &#123;  switch (stage) &#123;    case RESOURCE_CACHE:      return new ResourceCacheGenerator(decodeHelper, this);    case DATA_CACHE:      return new DataCacheGenerator(decodeHelper, this);    case SOURCE:      return new SourceGenerator(decodeHelper, this);    case FINISHED:      return null;    default:      throw new IllegalStateException(&quot;Unrecognized stage: &quot; + stage);  &#125;&#125;\n这个方法根据当期的 Stage 返回不同的 DataFetcherGenerator，DataFetcherGenerator 的作用是用注册的 ModelLoader 和 Model 产生 DataFetcher 来加载数据。读到这里大家可能有点难理解，因此，在继续深入下去之前，我们有必要了解下 DecodeJob 加载图片资源的整个过程以及 Model，ModelLoader，DataFetcher 等类的的角色和作用，这样有助于后面的分析和理解。\n首先我们了解一下 DecodeJob 加载资源的流程，DecodeJob 加载资源的过程中资源类型的变化可以这样来表示：\nModel &#x3D;&gt; Data &#x3D;&gt; Decoded Resource &#x3D;&gt; Transcoded Resource。 \n\nModel 一开始是通过 RequestManager#load() 穿过来的，它的类型可以有很多种，它可以是 String，Uri，Drawable，Bitmap，byte[]等。我们可以把它理解成图片加载过程的初始对象；\nData 是原始的数据流，它一般以二进制的形式存在，例如 InputStream，ByteBuffer，byte[]。但也不绝对是二进制流，它也可以是 Bitmap，Drawble 等资源对象，这样看 Model 传入的初始对象是什么；\nDecode Resource 是解码好的图片对象，例如 Bitmap，GitDrawable 等；\nTranscoded Resource 是最终期望的图片资源类型，它的类型和 RequestBuilder#as() 接受的类型以及 Target 可接受的类型是保持一致的，也就是说这个类型就是“目标类型”，它的类型可以有很多，比如 Bitmap，Drawable，byte[] 等。\n\n如果我们传入的 model 为一个 Uri，而我们的目标类型为 Bitmap 时，Glide 是如何处理的呢？首先，Glide 会将 String（Model） 转换成 InputStream（Data)，再将 InputStream（Data）转换成 Bitmap（Decoded Resource），最后再由 Bitmap（Decoded Resource）到 Bitmap（Transcoded Resource）。其实 Decode Resource 到 Transcoded Resource 资源的类型是一样的，因此 Glide 其实不会做任何事。\n同理，如果我们传入的 model 是一个 Bitmap，目标类型也是 Bitmap 类型时，由于资源类型至始至终都没有发生变化，那么 Data，Decoded Resource，Transocded Resource 的类型都是 Bitmap。你会说这有什么意义呢？我们知道整个加载流程发生变化的不仅仅是资源类型，还有资源的尺寸等。我们的确可以直接通过 ImageView#setImageBitmap() 方法将一张 Bitmap 设置给 ImageView，但是忽略 ImageView 的大小而将 Bitmap 以原始尺寸显示是很浪费内存的。通常我们会对 Bitmap 进行压缩，必要的话还需要将压缩后的图片进行缓存，如果不利用 Glide，这将是一件很麻烦的是事，而 Glide 使得这个过程的工作量大大减少。\n在加载过程中，资源的类型的变化是由 Glide 中特定的对象来完成的，例如 Model 到 Data 的转化就是 ModelLoader 来完成的，Data 到 Decoded Resource 的转换是由 ResourceDecoder 完成的，Decoded Resource 到 Transcoded Resource 的过程是由 ResourceTranscoder 来完成的。以上三者都只是接口，它们在 Glide 由许许多多的实现类，每个实现类都完成特定的两种资源类型的转换，比如 HttpUrlLoader 是一个 ModelLoader，它完成 Uri（Model） 到 InputStream（Data） 的转换过程。\n现在我们来看下 ModelLoader 的定义吧：\n[-&gt;ModelLoader.java]\npublic interface ModelLoader&lt;Model, Data&gt; &#123;  class LoadData&lt;Data&gt; &#123;    public final Key sourceKey;    public final List&lt;Key&gt; alternateKeys;    public final DataFetcher&lt;Data&gt; fetcher;    public LoadData(@NonNull Key sourceKey, @NonNull DataFetcher&lt;Data&gt; fetcher) &#123;      this(sourceKey, Collections.&lt;Key&gt;emptyList(), fetcher);    &#125;    public LoadData(@NonNull Key sourceKey, @NonNull List&lt;Key&gt; alternateKeys,        @NonNull DataFetcher&lt;Data&gt; fetcher) &#123;      this.sourceKey = Preconditions.checkNotNull(sourceKey);      this.alternateKeys = Preconditions.checkNotNull(alternateKeys);      this.fetcher = Preconditions.checkNotNull(fetcher);    &#125;  &#125;  // 构造一个 LoadData 对象  @Nullable  LoadData&lt;Data&gt; buildLoadData(@NonNull Model model, int width, int height,      @NonNull Options options);  // 该 ModelLoader 能否处理此 model  boolean handles(@NonNull Model model);&#125;\nModelLoader 有两个方法，它们的作用在代码中已经说明了。LoadData 是 ModelLaoder 的内部类，它的内部有一个 DataFetcher 对象，从名字就能知道它的作用是数据的携带者，它用来对数据实行懒加载。我们看下 DataFetcher 的定义：\n[-&gt;DataFetcher.java]\npublic interface DataFetcher&lt;T&gt; &#123;  interface DataCallback&lt;T&gt; &#123;    void onDataReady(@Nullable T data);    void onLoadFailed(@NonNull Exception e);  &#125;  void loadData(@NonNull Priority priority, @NonNull DataCallback&lt;? super T&gt; callback);  void cleanup();  void cancel();  @NonNull  Class&lt;T&gt; getDataClass();  @NonNull  DataSource getDataSource();&#125;\n\n容易知道，它的 loadData() 方法就是用来加载数据的，当数据加载完成后它通过 DataCallback 将结果返回给调用者。现在我们可以理解为什么它对数据的加载被称为懒加载了，因为 ModelLoader 构建出 LoadData 这个过程根本没有发生数据的加载，数据的真正加载是调用 DataFetcher#load() 实现的。\n现在我们回到 DecodeJob 中，我们接着分析它的 runGenerators() 方法：\n[-&gt;DecodeJob.java]\nprivate void runGenerators() &#123;  currentThread = Thread.currentThread();  startFetchTime = LogTime.getLogTime();  boolean isStarted = false;  while (!isCancelled &amp;&amp; currentGenerator != null      &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;    stage = getNextStage(stage);    currentGenerator = getNextGenerator();    if (stage == Stage.SOURCE) &#123;      reschedule();      return;    &#125;  &#125;  // We&#x27;ve run out of stages and generators, give up.  if ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;    notifyFailed();  &#125;  // Otherwise a generator started a new load and we expect to be called back in  // onDataFetcherReady.&#125;\n\n这个方法的核心逻辑是取出一个 Stage，根据该 Stage 返回相应的 DataFetcherGenerator 并执行其 startNext() 方法，然后再取出下一个 Stage……如此循环。\n其中 ResourceCacheGenerator 和 DataCacheGenerator 的资源获取方式都是从磁盘缓存中获取，不同的是，前者是从压缩和变换后的图片缓存中获取，后者是从原始图片数据缓存中获取。而 SourceGenerator 获取资源的方式则是从资源的原始位置获取，比如网络。这三者的工作原理大同小异，这里我们只分析 SourceGenerator#startNext() 方法：\n[-&gt;SourceGenerator.java]\n@Overridepublic boolean startNext() &#123;  ......  loadData = null;  boolean started = false;  while (!started &amp;&amp; hasNextModelLoader()) &#123;    loadData = helper.getLoadData().get(loadDataListIndex++);    if (loadData != null        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())        || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;      started = true;      loadData.fetcher.loadData(helper.getPriority(), this);    &#125;  &#125;  return started;&#125;\n\nhelper 是 DecodeHelper 对象，DecodeHelper 是一个帮助类，其实就是把原本属于 DecodeJob 的某些属性和方法抽离出去得到的类，估计是作者重构时新添的类，用来减轻 DecodeJob 的工作。它的 getLoadData() 是什么意思呢？我们根据代码来分析下：\n[-&gt;DecodeHelper.java]\nList&lt;LoadData&lt;?&gt;&gt; getLoadData() &#123;  if (!isLoadDataSet) &#123;    isLoadDataSet = true;    loadData.clear();    List&lt;ModelLoader&lt;Object, ?&gt;&gt; modelLoaders = glideContext.getRegistry().getModelLoaders(model);    //noinspection ForLoopReplaceableByForEach to improve perf    for (int i = 0, size = modelLoaders.size(); i &lt; size; i++) &#123;      ModelLoader&lt;Object, ?&gt; modelLoader = modelLoaders.get(i);      LoadData&lt;?&gt; current =          modelLoader.buildLoadData(model, width, height, options);      if (current != null) &#123;        loadData.add(current);      &#125;    &#125;  &#125;  return loadData;&#125;\n\n这个方法返回的是一个 LoadData 集合，这个集合是如何得到的呢？在 for 循环中，遍历上一步得到的 ModelLoader 列表，逐个调用其 buildLoadData() 方法，将得到的 LoadData 添加到结果中。这些 ModelLoader 是通过 Register#getModelLoader() 得到的，这个方法的内部实现虽然繁琐但是很简单：从 Register 中筛选所有能够处理该 Model 的 ModelLoader。筛选的依据就是 ModelLoader#handles() 的返回值，这点之前已经讲过了。Register 是一个注册中心，它会将所有的 ModelLoader，ResourceDecoder 和 ResourceTranscoder 在 Glide 初始化时注册进去。我们摘取部分代码来看：\n[-&gt;Glide.java]\nregistry        .append(ByteBuffer.class, new ByteBufferEncoder())        .append(InputStream.class, new StreamEncoder(arrayPool))        /* Bitmaps */        .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class, streamBitmapDecoder)        .append(Bitmap.class, Bitmap.class, UnitModelLoader.Factory.&lt;Bitmap&gt;getInstance())        .append(            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder())        /* BitmapDrawables */        .append(            Registry.BUCKET_BITMAP_DRAWABLE,            ByteBuffer.class,            BitmapDrawable.class,            new BitmapDrawableDecoder&lt;&gt;(resources, byteBufferBitmapDecoder))        .append(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, bitmapEncoder))        /* GIFs */        .append(            Registry.BUCKET_GIF,            InputStream.class,            GifDrawable.class,            new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool))        /* GIF Frames */        .append(            GifDecoder.class, GifDecoder.class, UnitModelLoader.Factory.&lt;GifDecoder&gt;getInstance())        /* Drawables */        .append(Uri.class, Drawable.class, resourceDrawableDecoder)        .append(            Uri.class, Bitmap.class, new ResourceBitmapDecoder(resourceDrawableDecoder, bitmapPool))        /* Files */        .append(File.class, InputStream.class, new FileLoader.StreamFactory())        .append(File.class, File.class, new FileDecoder())        .append(File.class, File.class, UnitModelLoader.Factory.&lt;File&gt;getInstance())        /* Models */        .register(new InputStreamRewinder.Factory(arrayPool))        .append(int.class, InputStream.class, resourceLoaderStreamFactory)        .append(int.class, Uri.class, resourceLoaderUriFactory)        .append(String.class, InputStream.class, new StringLoader.StreamFactory())        .append(Uri.class, InputStream.class, new HttpUriLoader.Factory())        .append(Uri.class, File.class, new MediaStoreFileLoader.Factory(context))        .append(byte[].class, ByteBuffer.class, new ByteArrayLoader.ByteBufferFactory())        .append(byte[].class, InputStream.class, new ByteArrayLoader.StreamFactory())        .append(Uri.class, Uri.class, UnitModelLoader.Factory.&lt;Uri&gt;getInstance())        .append(Drawable.class, Drawable.class, UnitModelLoader.Factory.&lt;Drawable&gt;getInstance())        .append(Drawable.class, Drawable.class, new UnitDrawableDecoder())        /* Transcoders */        .register(            Bitmap.class,            BitmapDrawable.class,            new BitmapDrawableTranscoder(resources))        .register(Bitmap.class, byte[].class, bitmapBytesTranscoder)        .register(            Drawable.class,            byte[].class,            new DrawableBytesTranscoder(                bitmapPool, bitmapBytesTranscoder, gifDrawableBytesTranscoder))        .register(GifDrawable.class, byte[].class, gifDrawableBytesTranscoder);\n\n由于代码太长，我只贴了部分注册内容。上面这些代码应该很容易看懂，几乎每个注册方法都会接受两个 Class 类型的对象和一个 ModelLoader 或者 ResourceDecoder 或者 ResourceTranscoder 对象，表示该 ModelLoader 或者 ResourceDecoder 或者 ResourceTranscoder 对象能够实现哪两种资源类型的转换。可以用下图来表示资源的类型变化过程：\n\n由上图可知，如果无法找到一组 (ModelLoader, ResourceDecoder, ResourceTranscoder)，使得资源类型由 Model 转换到 Transcoded Resource，那么加载便会失败。反之，可能有多组 (ModelLoader, ResourceDecoder, ResourceTranscoder) 能够实现 Model 到 Transcoded Resource 的转换。\n现在回到 SourceGenerator#startNext()：\n[-&gt;SourceGenerator.java]\n@Overridepublic boolean startNext() &#123;  ......  loadData = null;  boolean started = false;  while (!started &amp;&amp; hasNextModelLoader()) &#123;    loadData = helper.getLoadData().get(loadDataListIndex++);    if (loadData != null        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())        || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;      started = true;      loadData.fetcher.loadData(helper.getPriority(), this);    &#125;  &#125;  return started;&#125;\n\n通过前面的分析我们知道，DecodeHelper#getLoadData() 返回的是所有能够处理 Model 对象的 ModelLoader 构建出的 LoadData 的集合。循环体中做的事就是选择第一个满足条件的 LoadData，用它内部的 DataFetcher 对象来加载出 Data。之前在分析 DataFetcher 的时候讲过，它的 loadData() 方法会通过 DataCallback 将 Data 传回调用者。在这里调用者就是 SourceGenerator，它实现了 DataCallback 中的方法：\n[-&gt;SourceGenerator.java]\n@Overridepublic void onDataReady(Object data) &#123;  DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();  if (data != null &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;    dataToCache = data;    // We might be being called back on someone else&#x27;s thread. Before doing anything, we should    // reschedule to get back onto Glide&#x27;s thread.    cb.reschedule();  &#125; else &#123;    cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,        loadData.fetcher.getDataSource(), originalKey);  &#125;&#125;@Overridepublic void onLoadFailed(@NonNull Exception e) &#123;  cb.onDataFetcherFailed(originalKey, e, loadData.fetcher, loadData.fetcher.getDataSource());&#125;\n我们重点分析 onDataReady() 方法，这个方法会根据回调所在的线程选择不同的执行路径，这里我们假设走到了 else 块中，那么 FetcherReadyCallback#onDataFetcherReady() 会得到调用。FetcherReadyCallback 也是一个回调接口，它的是实现者是 DecodeJob。这样一来，Data 便从 SourceGenerator 传到了 DecodeJob 中，我们现在看看 DecodeJob#onDataFethcerReady()：\n[-&gt;DecodeJob.java]\n@Overridepublic void onDataFetcherReady(Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher,    DataSource dataSource, Key attemptedKey) &#123;  this.currentSourceKey = sourceKey;  this.currentData = data;  this.currentFetcher = fetcher;  this.currentDataSource = dataSource;  this.currentAttemptingKey = attemptedKey;  if (Thread.currentThread() != currentThread) &#123;    runReason = RunReason.DECODE_DATA;    callback.reschedule(this);  &#125; else &#123;    TraceCompat.beginSection(&quot;DecodeJob.decodeFromRetrievedData&quot;);    try &#123;      decodeFromRetrievedData();    &#125; finally &#123;      TraceCompat.endSection();    &#125;  &#125;&#125;\n\n这里同样会根据回调所在线程的不同执行不同的操作，但是最终都会调用到 decodeFromRetrievedData 方法：\nprivate void decodeFromRetrievedData() &#123;  if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;    logWithTimeAndKey(&quot;Retrieved data&quot;, startFetchTime,        &quot;data: &quot; + currentData        + &quot;, cache key: &quot; + currentSourceKey        + &quot;, fetcher: &quot; + currentFetcher);  &#125;  Resource&lt;R&gt; resource = null;  try &#123;    resource = decodeFromData(currentFetcher, currentData, currentDataSource);  &#125; catch (GlideException e) &#123;    e.setLoggingDetails(currentAttemptingKey, currentDataSource);    throwables.add(e);  &#125;  if (resource != null) &#123;    notifyEncodeAndRelease(resource, currentDataSource);  &#125; else &#123;    runGenerators();  &#125;&#125;\n\ndecodeFromData() 返回了 Transcoded Resource 类型的的图片资源。这个方法的内部细节即使不去分析我们也能略知一二，无非就是对 Data 使用合适的 ResourceDocoder 和 ResourceTranscoder 进行解码和转码。这个方法的最后调用了 notifyEncodeAndRelease()，这个方法最终会调用 DecodeJob.Callback#onResourceReady() 将最终的资源回传。EncodeJob 实现了该接口并且在构造 DecodeJob 时曾将自身作为参数传入，因此资源会被传入 EncodeJob#onResourceReady() 中。类似的 EncodeJob 又会通过回调将资源进一步传给 SingleRequest 中，SingleRequest 最后通过 Target#onResourceReady() 结果传给了 Target。\n补充前面我们仅仅是沿着加载这条主线讲解了 Glide 内部原理，为了不使逻辑混乱，很多细节我们都带过了。为了加深对 Glide 的理解，我觉得有些问题还是有必要分析一下。\nGlide 是如何暂停加载任务的我们知道 Glide 会借助 Activity 或者 Fragment 的生命周期来管理加载，那么具体它是如何再暂停和继续一个正在线程池中运行的加载任务呢？之前在分析 Engine#load() 的时候，对于它的返回值我暂时没讲，现在我们回到 Engine#load() 方法：\n[-&gt;Engine.java]\nEngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,    resourceClass, transcodeClass, options);EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);if (active != null) &#123;  cb.onResourceReady(active, DataSource.MEMORY_CACHE);  ......  return null;&#125;EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);if (cached != null) &#123;  cb.onResourceReady(cached, DataSource.MEMORY_CACHE);  ......  return null;&#125;EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);if (current != null) &#123;  current.addCallback(cb);  ......  return new LoadStatus(cb, current);&#125;EngineJob&lt;R&gt; engineJob = engineJobFactory.build(key, isMemoryCacheable,        useUnlimitedSourceExecutorPool, useAnimationPool, onlyRetrieveFromCache);DecodeJob&lt;R&gt; decodeJob = decodeJobFactory.build(glideContext, model, key,        signature, width, height, resourceClass, transcodeClass, priority,        diskCacheStrategy, transformations, isTransformationRequired,        isScaleOnlyOrNoTransform, onlyRetrieveFromCache, options, engineJob);jobs.put(key, engineJob);engineJob.addCallback(cb);engineJob.start(decodeJob);......return new LoadStatus(cb, engineJob);\n我们知道它的返回值是 LoadStatus 对象，这个类的定义如下：\n[-&gt;Engine.java]\npublic static class LoadStatus &#123;  private final EngineJob&lt;?&gt; engineJob;  private final ResourceCallback cb;  LoadStatus(ResourceCallback cb, EngineJob&lt;?&gt; engineJob) &#123;    this.cb = cb;    this.engineJob = engineJob;  &#125;  public void cancel() &#123;    engineJob.removeCallback(cb);  &#125;&#125;\n很简单，仅仅是封装了 EngineJob 和 ResourceCallback 两个对象。注意到他还有一个 cancel() 方法，这个方法的作用我想大家猜也能猜到，它是用来取消加载的。那么这个方法什么时候会调用呢？我们得回到 SingleRequest 中去寻找答案，因为 Engine#load() 是在 SingleRequest 中调用的，LoadStatus 对象肯定是要返回给 SingleRequest 的。\n[-&gt;SingleRequest.java]\nloadStatus = engine.load(...);\n\nSingleRequest 将返回的 LoadStatus 保存在了 loadStatus 中，现在我们看看 SingleRequest 的 pause() 方法，这个方法会在 RequestTracker#pauseRequests() 中调用，而 RequestTracker#pauseRequests() 会被 RequestManager#onStop() 触发：\n[-&gt;SingleRequest.java]\n@Overridepublic void pause() &#123;  clear();  status = Status.PAUSED;&#125;@Overridepublic void clear() &#123;  ......  if (status == Status.CLEARED) &#123;    return;  &#125;  cancel();  ......  status = Status.CLEARED;&#125;void cancel() &#123;  assertNotCallingCallbacks();  stateVerifier.throwIfRecycled();  target.removeCallback(this);  status = Status.CANCELLED;  if (loadStatus != null) &#123;    loadStatus.cancel();    loadStatus = null;  &#125;&#125;\n\npause() 方法最后会导致 loadStatus 的 cancel() 方法被调用，现在我们从 LoadStatus#cancel() 方法往下看，为什么 cancel() 就能将一个正在运行的加载任务给取消掉呢？LoadStatus#cancel() 只是简单调用了 EngineJob#removeCallback()：\n[-&gt;EngineJob.java]\nvoid removeCallback(ResourceCallback cb) &#123;  Util.assertMainThread();  stateVerifier.throwIfRecycled();  if (hasResource || hasLoadFailed) &#123;    addIgnoredCallback(cb);  &#125; else &#123;    cbs.remove(cb);    if (cbs.isEmpty()) &#123;      cancel();    &#125;  &#125;&#125;\n\n这个方法的意图很明了，假设加载还未完成的时候取消了加载，那么便会执行 else 中的代码块，从回调列表中删除该 ResourceCallback，但是移除还不够，因为移除回调仅仅是让 SingleRequest 接收不到最终的结果，我们还必须停止加载任务以节省资源。接下来会继续判断回调列表是否为空，如果为空就调用 cancel() 方法，这个方法就是用来取消加载任务的。这样看来，单单取消一个加载请求并不一定会导致这个加载任务的取消，这很容易理解，因为可能还有其他的请求依赖这个任务的执行。现在看看 EngineJob#cancel() 方法：\n[-&gt;Engine.java]\nvoid cancel() &#123;  if (hasLoadFailed || hasResource || isCancelled) &#123;    return;  &#125;  isCancelled = true;  decodeJob.cancel();  // TODO: Consider trying to remove jobs that have never been run before from executor queues.  // Removing jobs that have run before can break things. See #1996.  listener.onEngineJobCancelled(this, key);&#125;public void cancel() &#123;  isCancelled = true;  DataFetcherGenerator local = currentGenerator;  if (local != null) &#123;    local.cancel();  &#125;&#125;\n这个方法调用了 DecodeJob#cancel()，DecodeJob#cancel() 做了两件事，一是设置 isCancelled 为 true，二是停止当前 DataFetcherGenerator 中的任务。isCancelled 是一个标志，那么它对加载任务有什么影响呢？影响主要有两处，一个 DecodeJob#run()，另一个是 DecodeJob#runGenerators()。isCancelled&#x3D;&#x3D;true 会导致前者发出加载失败的通知，导致后者停止运行后续的 DataFetcherGenerator 并发出加载失败的通知。加载失败的通知最终会传到 EngineJob 中，使得 EngineJob 执行资源的释放工作。\n有一个细节不知大家发现没有，DecodeJob 是被投入线程中运行的，也就是说 SingleRequest 和 DecodeJob 是在不同的线程中运行的。isCancelled 的改变是在 SingleRequest 的线程中进行的，而 DecodeJob 读取 isCancelled 的值是在 DecodeJob 的线程中发生的。那么这很容易发生一个问题，就是线程感知问题。那么 Glide 是如何解决这一问题的呢？我们看看 isCancelled 在 DecodeJob 中的定义：\n[-&gt;DecodeJob.java]\nprivate volatile boolean isCancelled;\nGlide 给 isCancelled 加了 volatile 关键字，这样保证了，SingleRequest 线程对 isCancelled 的改变能够及时被 DecodeJob 线程感知。同样的，currentGenerator 在定义时也使用了这个关键字，目的都是一样的。如果大家对于 volatile 关键字还不理解，可以到网上查阅相关资料，因为一时半会儿是解释不清的，我当初为了理解这个关键字花了不少时间。\nModelLoader 的内部细节ModelLoader 的子类有很多，Glide 会根据 model 的类型决定使用哪种 ModelLoader。现假设 model 为 http 协议的 url 的话，Glide 最终就会用到 HttpGlideUrlLoader 实现 Model 到 Data 的转换。\n[-&gt;HttpGlideUrlLoader]\npublic class HttpGlideUrlLoader implements ModelLoader&lt;GlideUrl, InputStream&gt; &#123;  public static final Option&lt;Integer&gt; TIMEOUT = Option.memory(      &quot;com.bumptech.glide.load.model.stream.HttpGlideUrlLoader.Timeout&quot;, 2500);  @Nullable private final ModelCache&lt;GlideUrl, GlideUrl&gt; modelCache;  public HttpGlideUrlLoader() &#123;    this(null);  &#125;  public HttpGlideUrlLoader(@Nullable ModelCache&lt;GlideUrl, GlideUrl&gt; modelCache) &#123;    this.modelCache = modelCache;  &#125;  @Override  public LoadData&lt;InputStream&gt; buildLoadData(@NonNull GlideUrl model, int width, int height,      @NonNull Options options) &#123;    GlideUrl url = model;    if (modelCache != null) &#123;      url = modelCache.get(model, 0, 0);      if (url == null) &#123;        modelCache.put(model, 0, 0, model);        url = model;      &#125;    &#125;    int timeout = options.get(TIMEOUT);    return new LoadData&lt;&gt;(url, new HttpUrlFetcher(url, timeout));  &#125;  @Override  public boolean handles(@NonNull GlideUrl model) &#123;    return true;  &#125;    public static class Factory implements ModelLoaderFactory&lt;GlideUrl, InputStream&gt; &#123;    private final ModelCache&lt;GlideUrl, GlideUrl&gt; modelCache = new ModelCache&lt;&gt;(500);    @NonNull    @Override    public ModelLoader&lt;GlideUrl, InputStream&gt; build(MultiModelLoaderFactory multiFactory) &#123;      return new HttpGlideUrlLoader(modelCache);    &#125;    @Override    public void teardown() &#123;      // Do nothing.    &#125;  &#125;&#125;\n\n重点是 HttpUrlFethcer，它的 loadData() 方法会调用 loadDataWithRedirects()：\n[-&gt;HttpUrlFetcher.java]\nprivate InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,    Map&lt;String, String&gt; headers) throws IOException &#123;  .....  urlConnection = connectionFactory.build(url);  for (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) &#123;    urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());  &#125;  urlConnection.setConnectTimeout(timeout);  urlConnection.setReadTimeout(timeout);  urlConnection.setUseCaches(false);  urlConnection.setDoInput(true);  ......  urlConnection.setInstanceFollowRedirects(false);  // Connect explicitly to avoid errors in decoders if connection fails.  urlConnection.connect();  if (isCancelled) &#123;    return null;  &#125;  final int statusCode = urlConnection.getResponseCode();  if (statusCode / 100 == 2) &#123;    return getStreamForSuccessfulRequest(urlConnection);  &#125; else if (statusCode / 100 == 3) &#123;    String redirectUrlString = urlConnection.getHeaderField(&quot;Location&quot;);    if (TextUtils.isEmpty(redirectUrlString)) &#123;      throw new HttpException(&quot;Received empty or null redirect url&quot;);    &#125;    URL redirectUrl = new URL(url, redirectUrlString);    return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);  &#125; else if (statusCode == -1) &#123;    throw new HttpException(statusCode);  &#125; else &#123;    throw new HttpException(urlConnection.getResponseMessage(), statusCode);  &#125;&#125;\n这里就是 Glide 和网络交互的地方，Glide 通过 HttpUrlConnection 进行网络连接，并且对可能存在的重定向情况进行了处理，HttpUrlFetcher 最终会将获取到的 InputStream 作为 Data 返回。\n总结以上便是 Glide 的加载流程，它内部的运作实在是太复杂了，但正是这种复杂的内部实现使得 Glide 的可扩展型得到增强。比如我们可以自定义磁盘缓存策略，自定义 ModelLoader 以实现 Model 到 Data 的转换，也可以自定义 ResourceDecoder 和 ResourceTranscoder 来实现资源的解码和转码。最后，我们用一张图来总结整个加载过程：\n\n","tags":["Android","开源库","Glide"]},{"title":"移动魔百盒 CM201 CH(长虹代工) 破解方法分享","url":"/2022/11/04/2022-11-04-CM201-crack/","content":"前言这两天为了破解魔百盒费了好大劲，看了好多帖子，好在最后破解成功了。为了让大家少走弯路，我把破解方法分享出来，希望能帮助到大家。\n盒子型号我的盒子型号是 CM201-2 长虹代工 (CH)，具体信息见图片：\n\n板子上的硬件信息是：CPU 型号是 HI3890MV300，闪存是 emmc。机型编码和牌照方不同应该没太大关系，大家可以先尝试一下，不行再说。\n\n破解方法有两种破解方案，一种是保留原有系统，只解除无法安装软件的限制，另一种是是刷第三方系统。两种方式各有利弊：\n第一种：\n\n优点：步骤简单；\n缺点：\n如果按到遥控器上的主页，会跳到订阅关系失效的页面，只能重启，比较麻烦，特别是对于那些不会用机顶盒的老人家来说。\n原装系统有一堆用不到的应用在后台运行，占用内存，影响运行速度。\n\n\n\n第二种：\n\n优点：\n系统精简，第三方系统一般会把那些没用的系统应用去除掉，运行速度会有所提升；\n不用担心按到主页需要重启盒子，第三方系统一般没这个问题；\n\n\n缺点：刷机步骤略微复杂。\n\n两种破解模式都需要拆机连电脑，如果你想不拆机，那这篇帖子可能对你没啥参考价值。我在网上找的所有的免拆方法都没有试成功，包括使用 ZANTI 中间人攻击替换 apk 来安装当贝桌面，以及通过遥控按键开启 adb。拆机方法是：撕开盒子底部的两个垫子，取下螺丝，再用指甲、卡片等工具把盒子拆开。接下来是具体的破解步骤。\n第一种破解方案\n准备工具：\n\n\nU 盘 （大小最好为 8G，文件系统格式化为 fat32）；\nusb 转 ttl 模块，杜邦线（淘宝有售，我买的型号是 CH340G）；\n串口通信工具（windows 上的 putty，mac 上的“串口调试助手”，这里以 putty 为例）;\n\n\n破解步骤：将 usb 转 ttl 模块插入到电脑的 usb 口，然后打开 windows 设备管理器，在端口分类里查看这个模块是在哪个 COM 口，我的是在 COM4。\n用杜邦线把 CH340G 的 RXD、TXD 和 GND三个引脚接到板子上。板子上有四个孔，第一个孔没用，其他三个孔从左到右分别是 RXD、TXD、GND，分别和 CH340G 的 TXD、RXD、GND 相对应，顺序不能错，如下图所示。有的博主给那三个孔焊上了排插，然后用杜邦线直接插上去，如果和我一样没有工具，想办法让三根杜邦线和三个孔保持良好的接触也行。\n\n打开 putty ，如下图所示：\n\n把通信方式改成串口，Serial line 填写为上面查到的那个，我这里是 COM4，Speed 调整为 115200，Connection type 选择 Serial，其他的不用管，然后点击 右下角的 open，此时会出现一个控制台窗口，打开盒子电源，这时应该能看到窗口上有日志输出：\n\n等日志输出得差不多之后，按下回车键，这时候会显示命令提示符，这样我们就进入到 shell 中了（如果没有显示命令提示符，检查下那三根线是否接触良好，或者重新配置 putty 并打开窗口）。接下来把当贝桌面下载到 U 盘根目录，完后把 U 盘插到盒子靠近网口的 usb 口，执行如下命令：\n#进入 U 盘cd /mnt/sda/sda1#安装 U 盘里的当贝桌面pm install 当贝桌面apk文件名\n结果如图：\n\n然后启动当贝桌面：\nam start com.dangbei.tvlauncher\n\n如果当贝桌面没出来就重启一下盒子，不出意外的话，重启后就直接进入当贝桌面了，破解完成。当贝桌面里面可以下载当贝应用市场，然后就能安装任意 APP 了。\n\n\n第二种破解方案\n准备工具：\n\n\nU 盘（大小最好为 8G，文件系统格式化为 fat32）；\nusb 转 ttl 模块，杜邦线（淘宝有售，我买的型号是 CH340G）；\n串口通信工具（windows 上的 putty，mac 上的 “串口调试助手”，这里以 putty 为例）；\nhitool，搜关键字 “hitool 下载” 就能找到：https://ecoo.top/hitool.html。\n\n\n破解步骤：\n因为刷机风险比较大，建议刷机前先备份下系统，不要怕麻烦，万一失败了呢。备份方法如下：\n前面的步骤和上面一样，用 CH340G 连接好板子，打开 putty，等日志输出完毕之后，按下回车，进入 shell。然后输入以下命令先进入到分区目录：\ncd /dev/block/platform/soc/by-name\n\n接下来用以下命令对各个分区进行备份（除了 userdata 分区，其他分区都备份一下）。&#x2F;mnt&#x2F;sda&#x2F;sda1 对应的是 U 盘的根目录，system 是根目录下新建的子目录，这个目录需提前创建，否则可能会报错。时间可能会有点久，但是多花点时间也值得，万一刷成砖也有挽救的方法，免得到处求别人要原厂镜像。\ndd if=baseparam of=/mnt/sda/sda1/system/baseparam.imgdd if=bootargs of=/mnt/sda/sda1/system/bootargs.imgdd if=deviceinfo of=/mnt/sda/sda1/system/deviceinfo.imgdd if=fastboot of=/mnt/sda/sda1/system/fastboot.imgdd if=fastplay of=/mnt/sda/sda1/system/fastplay.imgdd if=kernel of=/mnt/sda/sda1/system/kernel.imgdd if=logo of=/mnt/sda/sda1/system/logo.imgdd if=misc of=/mnt/sda/sda1/system/misc.imgdd if=pqparam of=/mnt/sda/sda1/system/pqparam.imgdd if=private of=/mnt/sda/sda1/system/private.imgdd if=recovery of=/mnt/sda/sda1/system/recovery.imgdd if=securestore of=/mnt/sda/sda1/system/securestore.imgdd if=system of=/mnt/sda/sda1/system/system.imgdd if=trustedcore of=/mnt/sda/sda1/system/trustedcore.img\n\n现在轮到 hitool 上场了，用 hitool 的目的是把官方的 recovery 替换掉，这样刷第三方系统的时候就不会报校验失败的错误，这是很多人刷机失败的原因。\n保持盒子和电脑的连接，关闭 putty（会和 hitool 冲突）。打开 hitool，选择 HiBurn 视图，如图：\n\nPC 与板端配置如图所示：串口填 CH340G 所在端口，传输方式选串口，其他的不用管。（有的教程使用的是网口，速度会快点，但是需要网线连接，还需要配置 ip 地址，简单起见，我直接使用串口，速度慢一点也还好，反正 recovery 分区也不是很大）选择 烧写eMMC 页面，这里要填分区表，这个表我已经写好了，大家可以直接拿来用：\nCM201-2-CH4_HUNAN分区表文件.xml （访问码：1ift）\n这个分区表只适用于我这个型号的盒子，其他盒子可能会有差异。如果你的盒子型号和我的不一样，你可以先导入我的分区表，然后进行修改。还记得连接 putty 的时候会有一堆日志输出吗？这里面就有修改分区表所需的信息：\n\n红框中的日志描述了每个分区的大小，大家先导入上面的分区表文件，然后把各个分区的长度修改成日志所示。直接修改长度那一列就行，开始地址会自动更改。如果分区不一样，还需要添加或者删除分区，总之以你自己盒子的日志为准，注意分区顺序和日志中的保持一致。\n修改完分区表之后，可以点击保存，这样你就拥有了属于自己盒子的分区表了（备份好这个分区表，救砖的时候还有用）。接下来导入 recovery 分区：在 recovery 那一行的文件一列，将 recovery 文件导入进去。recovery 我这也准备好了：\nHi3798MV300H芯片强刷引导 （访问码：ts2l）\n你可能会感到困惑，我的芯片不是 Hi3789MV300 吗，板子上写的也是这个，为啥这里用的引导是 Hi3789MV300H 的？我最开始用的 recovery 也是 Hi3789MV300 的，结果刷机失败，后来才从日志里发现了问题：\n\n这是 HiBurn 烧写 Recovery 时的日志输出（putty 输出的日志里也有，但我之前忘记截图了，所以用了 HiBurn 里的日志），里面写着 CPU 型号是 Hi3789MV300H,不知道为啥会出现这种情况。如果你日志中的 CPU 型号是 Hi3789MV300，那你应该使用 Hi3789MV300 的引导：\nHi3798MV300芯片强刷引导  （访问码：bo1f）\n这个文件夹里有三个文件，实测只刷 recovery.img 文件就行，如果失败了，那把另外两个也刷一下吧。\n导入 recovery 后，把其他分区取消勾选，只保留 recovery 分区，因为我们只刷 recovery 分区。最后点击 烧写，将 recovery 刷到盒子里去：\n\n如果你的盒子通着电，就会出现上面的提示，我们按照提示重新给盒子通电，不出意外的话，就开始烧写了：\n\n左侧是日志，大概等个十几二十分钟就烧好了（网口应该更快）：\n\n刷完 recovery，就可以尝试刷各种第三方系统了。我这里准备了一个基于别人的包制作的精简包，去除了没用的 app，把巨丑的当贝影视桌面换成了当贝桌面，并且不会出现某些 rom 按主页时当贝桌面等半天或者无法响应的问题，还顺带还把开机动画改成了 Google TV，逼格一下子就上来了。\n自制精简版_当贝桌面_Google_tv_开机动画_文件名改成update.zip （访问码：4qxp）\n把文件改成 update.zip 后放到 U 盘根目录中，插到靠近网口的那个 usb 口。重启盒子电源，然后立刻快速交替按遥控器上的菜单键和音量减键，直到进入 recovery 界面（速度一定要快，失败就多试几次）：\n\n选择 本地USB升级，不出意外就开始刷机了，刷完后盒子重启，就能看到如下的开机画面：\n\n欢迎使用 Google TV！\n附一张当贝桌面的图：\n\n注意：刷机后的盒子通过 putty 进入 shell 时需要用户名和密码，用户名和密码分别是：root 、chcmccch。\n\n\n分享到此结束，祝大家刷机成功！如果有错误的地方，或者有其他更好的方法，欢迎大家留言指出，这样也能帮助其他人。\n","tags":["折腾"]},{"title":"vfork 的诡异输出","url":"/2023/09/16/2023-09-16-play-with-vfork/","content":"学习 vfork 的时候，看到这篇文章中的一个例子，觉得很有趣，就拷贝下来自己跑了一下，其中的例子差不多是这样的：\nvoid fun1() &#123;    vfork();    printf(&quot;%d\\n&quot;, getpid());&#125; void fun2() &#123;    _exit(0);&#125; int main() &#123;     fun1();    printf(&quot;%d goes 1\\n&quot;, getpid());    fun2();       printf(&quot;%d goes 2\\n&quot;, getpid());    return 0;&#125;\n\n输出： \n➜ ./vfork28464382846438 goes 128464372846437 goes 2\n结合文章的讲解，我的理解如下：因为 vfork 后，子进程共享父进程的地址空间，父进程会等待子进程先执行，所以，子进程执行完 后 fun2 退出后，父进程的指令依旧停留在 fun1 的 printf 函数处。会执行 fun1 中的 printf 函数。但是为什么父进程没有打印出 goes 1 呢？因为子进程执行完 fun1 的时候，已经把 fun1 的返回地址弹出栈，返回到了 goes 1 处，而执行到 fun2 的时候，并没有返回，而是通过 _exit 直接退出了，所以，栈上的返回地址还保留着，而这个返回地址就是输出 goes 2 的 printf 语句的地址，因为父子进程共享栈，所以当父进程从 fun1 返回时，返回的就是这个语句的地址。\n为了验证自己的理解是否到位，就把例子改成了下面这样，看看结果是否符合预期：\nvoid fun() &#123;    _exit(0);&#125; int main() &#123;    int pid = vfork();     if (pid == 0) &#123;        printf(&quot;%d goes 1\\n&quot;, getpid());        fun();           printf(&quot;after fun&quot;);        return 0;    &#125; else &#123;         printf(&quot;%d goes 2\\n&quot;, getpid());         return 0;    &#125;&#125;\n按照前面的理解，期望的输出应该是这样的：\n➜ ./vfork             2846933 goes 12846932 goes 2after fun\n我是这么分析的：首先，vfork 之后，子进程先执行，进入到 if 块中，打印了 goes 1，然后进入到 fun 中 _exit 了，这时候栈上 “残留” 着 fun 的返回地址。然后，父进程接着执行，进入到 else 块中， 打印出 goes 2，准备返回的时候发现栈上的地址是 fun 的返回地址，也就是打印 after fun 的那行代码，于是就接着输出 after fun。看起来一切都很合理对吧？但实际的输出却是：\n➜ ./vfork             2846933 goes 12846932 goes 2\nafter fun 没了！不知道你们想明白没，反正我是绞尽脑汁想了好久才豁然开朗。之前在分析函数返回的时候，分析得比较粗略，我们如果再细致一点，从汇编层面分析一下 return 的细节，真相就呼之欲出了。return 语句其实对应着两个汇编指令的调用，先是 leave，然后才是 return。leave 指令等价于让 rsp 恢复为 rbp 的值，并且 pop 出栈顶的 old rbp 给 rbp 寄存器。所以 leave 指令执行后，rsp 指向的就是栈顶的 rip 了，此时 return 一下，就返回到 rip 对应的地址处了。\n了解 return 的细节后，我们再来看看子进程将调用 _exit 退出时的情况，此时子进程 rbp 指向的是 fun 函数的栈帧底部，也就是 after fun 的 printf 语句处，但随着 _exit 的调用，子进程烟消云散。vfork 虽然会让父子进程共享地址空间，但是并不会共享寄存器，子进程 “生前” 对寄存器的改变并不会被父进程看见。子进程结束时虽然它的 rbp 指向的是 fun 的栈底，但父进程恢复执行后，父进程的 rbp 指向的是却依然是 vfork 调用时 main 函数的栈帧底部，所以父进程执行到 return 语句时，在执行了 leave 汇编指令后，栈顶的 rip 就是 main 函数的返回地址（这个地址在 libc 中），这之后再执行 return 指令就直接返回到 libc 里去了。\n那么问题来了，为什么第一个例子中，父进程从 fun1 返回的却是 fun2 的调用处呢？其实父进程恢复执行时，它的 rbp 确实本应该指向的 fun1 的栈帧底部。但是，子进程执行完 fun1 后，fun1 的栈帧就不在了，子进程执行 fun2 的时候，在原来 fun1 的栈帧所在处，建立了 fun2 的栈帧。导致父进程本来指向 fun1 栈帧底部的 rbp 此时指向的是 fun2 的栈帧底部，然后一 leave ，一 return，自然就返回到 fun2 调用处了。\n总结：\n\nvfork 出的父子进程共享地址空间，但是不会共享寄存器，寄存器在 vfork 那个时刻，是相同的，后面随着子进程的执行开始分化。这期间父进程挂起，等到调度上 cpu 时，会用之前保存的值恢复所有寄存器。\nreturn 返回到哪里，关键看 leave 指令执行前的那一刻，rbp 指向的是哪个函数的栈帧底部，如果是 a ，那就返回到 a 的调用处，如果是 b，那就返回到 b 的调用处，至于是从哪个函数进来的，那不重要，只不过通常情况下，进入和返回的都是同一个调用点。\n\n当然，如果遵循推荐的 vfork 使用指南，通常我们并不会遇到这种诡异现象。vfork 的推荐玩法是，子进程分裂出来后，赶紧执行 exec 函数和父进程分家，抛弃掉父进程的地址空间 mm_struct（主要就是抛弃掉父进程的页表和 vma），另起炉灶，建立自己的 mm_struct，然后各自安好，互不打扰。在 fork 引入了写时复制技术后，使用 fork + exec 性能其实也还 ok，然而，虽然不用急着拷贝内存了，依然需要立即拷贝 mm_struct。结合网上的一些讨论，我个人认为，究竟使用 fork + exec 还是 vfork + exec 看情况而定，如果 exec 执行前的准备工作比较多，会在各种函数间穿梭，怕影响父进程，那就别想太多，就用 fork；如果立马执行 exec，就使用 vfork，避免对 mm_struct 的无效拷贝。虽然很多声音都说不要用 vfork，已经被时代抛弃了，但我觉得反正就是多加一个字母的事，性能能省就省，苍蝇再小也是肉，而且 Linux 的宿主设备繁多，可能一个不起眼的小设备上，就跑着一个 Linux，你的一个举手之劳，对这个小家伙而言说不定也是莫大的恩赐 :)。\n","tags":["linux","unix"]},{"title":"《程序员的自我修养》读书笔记一","url":"/2023/09/29/2023-09-29-reading-notes-%209787121085116-1/","content":"P199： “默认情况下，如果可执行文件是动态连接的，那么 GCC 会使用 PIC 的方法来产生可执行文件的代码段部分，以便于不同的进程能够共享” 但我用 GCC 去编译 32 位可执行文件，加 -fPIC 和不加 -fPIC，编出的指令是有差别的：\n\n\n\n为了访问文件内定义的全局变量，前者生成的代码是走了 GOT 的（实际结果是，形式上是走了，但貌似链接器发现最后生成的是非 PIE (位置无关可执行文件，需要加 -pie 才能生成) ，所以优化了下，导致实际上也是走绝对调用，四条指令只有后两条有用，这个先不管），后者并没有走，而是用绝对地址访问。\n通过实践我发现，默认情况下，可执行文件对外部变量和函数（存在于共享库中）的访问，借助了 GOT，应该是为了避免对代码段重定位；而对文件内部函数和变量的访问，走的是绝对地址的方式，应该是为了提升访问效率。虽然可执行文件通过绝对地址访问了内部函数和变量，致使其必须在装载到指定的地址处，失去了地址无关的特性，但也正因为其装载的地址是固定的，所以那些绝对地址并不需要重定位，进程并不需要在装载后对代码段进行修改，因此可执行文件的代码段是能够共享的。可执行文件的这种特点说明，共享和位置无关并非绑定的关系，能做到地址无关也能做到共享，但能共享并不一定能做到地址无关。\n虽然作者的意思不一定是说 GCC 默认会加 -fPIC 来生成可执行文件，但如上所述，生成出的可执行文件也并不是位置无关的，所以说 “使用 PIC 的方法来产生可执行文件的代码段部分” 这种表述容易产生误解。PIC 机制主要确保两点，一是对不确定的函数和变量的访问走 GOT，二是对能确定的函数和变量的访问使用相对地址。可执行文件默认只做到了第一点，而对于能确定的变量，比如图中的 a，可执行文件能够确定自己访问的变量就是它（共享库则不同，运行时由于全局符号介入可能访问的是其他模块的同名变量），所以就用绝对地址访问。我觉得这里说成是 “默认情况下，如果可执行文件是动态连接的，那么 GCC 产生的可执行文件代码段部分会使用 GOT 来访问外部函数和变量，以便于不同的进程能够共享” 会更好一点。\n其实 P197 的这段话： “由于程序主模块的代码并不是地址无关代码，也就是说代码不会使用这种类似于 PIC 的机制” 的前半句也强调了可执行文件并不是地址无代码，但这句话的后半句又容易产生新的误解，说它 “不会使用类似于 PIC 的机制” ，容易让读者误认为连 GOT 也不会使用。\n我当时在这两个地方困惑了很久，如果有人有类似的困惑，希望这篇笔记能有所帮助。如果有不对的地方，希望大家不吝赐教。\n","tags":["程序员的自我修养","读书笔记"]},{"title":"树莓派 3B+ 刷 OpenWrt 并安装 OpenClash","url":"/2024/03/29/2024-03-29-install-openwrt-with-openclash-on-raspi-3bplus/","content":"\n\n前言心血来潮打开了尘封已久的 switch，发现软件更新实在太慢，上网找了几种常用的加速方法，各有优劣，但最终都被 pass：\n\n更改 DNS 服务器，缺点是网速提升有限，大概在 34 Mbps 左右，大概提升 1 ~ 2 Mbps 左右 ，相对 switch 几百 M 几个 G 的游戏来说，依然是龟速。唯一的好处是不用借助其他设备。\n买加速器。对于喜欢折腾的人来说，花钱永远是最后的选择，况且我自己有梯子，干嘛花这个冤枉钱。\n把电脑上的代理通过局域网分享给 switch，然而发现网速的提升依然不高，虽然后来发现是 USB 无线网卡的问题，但不管怎样，电脑一直保持开机状态，就是为了给 swtich 做代理，总感觉不太优雅。\n\n我心想要是能在路由器上跑代理就好了，不过现在的路由器不支持装插件，而且是公用的，不太适合去折腾。这时候突然想起了我还有个同样在吃灰的树莓派，如果能把这台树莓派变成一台软路由，再在这个软路由上跑代理，岂不美哉？于是上网搜索 “如何在树莓派上装软路由”，不出所料，搜出了一堆教程。一番学习后，最后选择了 OpenWrt 这款软路由固件，一是因为它插件比较多，有更多可玩性，二是用户量大，教程多，遇到问题容易找到解决方案。\n话不多说，开干。\n\n\n如果你的设备也是树莓派 3B+ 且不想折腾的话，我这里准备了一个开箱即用的 OpenWrt 镜像，自带 OpenClash，分区扩容到了 1G，路由器管理密码和 WiFi 密码都是 12345678，WiFi 名为 OpenWrt，路由器地址为 192.168.110.1。烧录运行后，只需要改下密码和 OpenClash 节点信息就行了。  \n天翼云盘（访问码：ba8p） 或者 OneDrive\n\n安装 OpenWrt准备工具\n1G  以上 micro SD 卡，树莓派 3B+，网线\n镜像烧录工具 balenaEtcher\n\n下载镜像首先是去 OpenWRT 官网找自己的设备对应的固件，去到官网下载页：\n\n点击 Table of Hardware，进入到硬件列表页面：\n\n在输入框里输入关键字筛选，然后在列表中找到自己的型号。我的板子型号是 3B+，因此选择下载 3B+ 对应的固件。一共有四种固件可供选择，分别是 release 和 snapshot 版本的完整镜像及其升级包。由于我是全新安装，因此选择完整镜像就行了，这里我选择的是 release 版本的完整镜像 Factory image。注意，如果你选择 snapshot 版本的镜像，可能会遇到一些坑，因为 snapshot 固件的软件仓库没有进行版本隔离，软件仓库中的软件永远是适配最新版固件的，因此后面你安装软件的时候，可能会出现兼容性问题。当然，你可以手动更换到固定版本的软件仓库来解决这个问题，如何更换后面会提到。\n烧录镜像下载好镜像后解压得到 openwrt-23.05.0-bcm27xx-bcm2710-rpi-3-ext4-factory.img，然后使用 balenaEtcher 镜像烧录工具，把固件烧录到我们的存储卡中，存储卡不用很大，1G 足够了：烧录完成之后，把 SD 卡插入树莓派，通上电，就可以开始配置了。\n配置 OpenWrt\n登录路由器管理后台\n OpenWrt 无线网卡默认是未启用状态，因此没法通过 WiFi 连接并登录路由器管理界面。我们把树莓派通过网线连接到电脑，然后去电脑的设置里查看有线网络的网关 IP，一般都是 192.168.1.1，在浏览器中输入这个 IP 就可以看到 OpenWrt 的管理界面了：\n \n\n修改密码，添加 SSH 公钥\n 我们还没有设置过密码，直接点击 Login 就行。登录之后会提示你设置路由器后台密码，点击 Go to password configuration...。你还可以添加电脑的 SSH 公钥，方便后续 SSH 登录。\n \n\n研究一下初始配置\n 去到 Network -&gt; Interface 界面，可以看到只有一个 lan 接口：\n \n 点击编辑先研究下配置：\n \n 可以看到这个接口 IP 地址是手动设置的，接口对应的设备是 br-lan 网桥，在这个接口上跑了一个 DHCP 服务器。点击 Dismiss ，切换到 Devices 选项卡，研究下 br-lan 网桥的配置。可以看到 br-lan上附加了一个 eth0，eth0 正是我们的有线网卡。这就是为什么电脑连接树莓派后，不需要任何配置就能获取 IP 和网关，访问路由器后台。\n \n 然而现在也只能访问路由器后台，没法联网。为了能联网，我们需要完成以下配置：\n\n创建 wan 接口，并让其作为 DCHP 客户端去连接上层路由器；\n修改现在的 lan 接口，让其底层的设备关联的是无线网卡而非现在的有线网卡；\n激活无线网卡，开启无线网络，让局域网的无线设备能够连接进来；\n\n 以上是配置思路，接下来说下具体方法。\n\n创建 wan 接口。\n 在 Network -&gt; Interface 页面，点击 Add new interface... ：\n \n 填入下图所示配置，然后点击 Create interface：\n  Device 选择 br-lan 网桥也行，但网桥上只附加了一个 eth0，就没有使用的必要了，直接用 eth0 就行，br-lan 后面可以直接删了。\n \n 在新弹出的窗口中，点击 Save：\n \n\n开启无线网络，创建无线局域网。\n 点击 lan 接口的 Edit 按钮，修改其配置：\n \n 如下图所示，将 Device 改成 Wireless Network: Master &quot;OpenWrt&quot; (lan)，Device 展示的名称和选项列表中的名称不一样，这个不用管。IPv4 address 改成 192.168.110.1。然后点击  Save 保存。\n 如果你上级路由器的网段不是 192.168.1.0/24，这里 IPv4 address 其实可以不改，我这里之所以改成 192.168.110.1 是避免上级路由器网段冲突。如果你的上级路由器网段刚好也是这个，你可以去买彩票了 😃。\n\n \n 然后我们去到 Network -&gt; Wireless ，点击 Edit 按钮配置一下无线网络：\n \n 如下图所示，把 Channel 改成 44（最开始我用的是 auto，发现 switch 死活连不上，最后按照网上的方法改成 44 就好了），加密方式我选择的是 WPA-PSK/WPA2-PSK Mixed Mode，兼容性好一点。 Key 自己看着填就行。最后点击 Save。\n 不要在这个配置页面点击 Enable ，Enable 不仅会开启无线网络，还是把之前所有的更改自动应用了，这可能会导致无法再连接上路由器。\n\n \n 退出配置后，回到上级界面，点击 Enable： \n 这一步会不仅会激活无线网卡并开启其无线 AP 功能，还有将之前所有的配置都应用。页面上会显示 Applying configuration changes 的 90s 倒计时，你需要在 90s 之内连接到 OpenWrt ，否则配置就会回滚。\n \n 找到名为 OpenWrt 的无线网络，连接成功以后页面会自动刷新，配置应用成功。现在可以断开树莓派和电脑的连接，把树莓派连到路由器的 lan 口上。不出意外的话，就能愉快地上网了。\n\n\n安装 OpenClash软路由配置好了，接下来可以装代理软件了，我选择的是 OpenClash，原因也是一样，可玩性还行，并且有一定的用户量。就是配置稍微麻烦点。\n更换 OpenWrt 软件源在搭 OpenClash 之前我们需要更换一下 OpenWrt 的软件源，否则软件包的下载可能会很慢。去到 System -&gt; Software，点击 Configure opkg...，如下图所示：\n\n然后把下面的文本复制到红框中，取代官方的源，点击 Save。我这里用的是清华的源，速度还可以。\n 确认一下版本和 CPU 架构是否能和你的设备对上，否则需要修改\n\nsrc/gz openwrt_core https://mirrors.tuna.tsinghua.edu.cn/openwrt/releases/23.05.0/targets/bcm27xx/bcm2710/packagessrc/gz openwrt_base https://mirrors.tuna.tsinghua.edu.cn/openwrt/releases/23.05.0/packages/aarch64_cortex-a53/basesrc/gz openwrt_luci https://mirrors.tuna.tsinghua.edu.cn/openwrt/releases/23.05.0/packages/aarch64_cortex-a53/lucisrc/gz openwrt_packages https://mirrors.tuna.tsinghua.edu.cn/openwrt/releases/23.05.0/packages/aarch64_cortex-a53/packagessrc/gz openwrt_routing https://mirrors.tuna.tsinghua.edu.cn/openwrt/releases/23.05.0/packages/aarch64_cortex-a53/routingsrc/gz openwrt_telephony https://mirrors.tuna.tsinghua.edu.cn/openwrt/releases/23.05.0/packages/aarch64_cortex-a53/telephony\n\n安装 OpenClash因为 OpenWrt 软件仓库里并没有提供 OpenClash，我们需要去 OpenClash Github Release 页下载最新的 ipk 包：\n\n然后按照 Release 页的说明，先通过 ssh 登录软路由（密码是你一开始设置的路由器管理密码）：\n➜  ssh root@192.168.1.1\n\n再执行 opkg update 命令以获取最新的软件包列表：\nroot@OpenWrt:~# opkg update\n\n接着安装 OpenClash 依赖，根据所使用的防火墙，选择不同的依赖，我用的是 nftables：\nroot@OpenWrt:~# opkg install coreutils-nohup bash dnsmasq-full curl ca-certificates ipset ip-full libcap libcap-bin ruby ruby-yaml kmod-tun kmod-inet-diag unzip kmod-nft-tproxy luci-compat luci luci-base\n\n不出意外的话，两三分钟的时间就装好了，你可以先去撒泡尿，喝口水。\n依赖安装好后，就可以安装 OpenClash 了。去到 System -&gt; Software，点击 Upload Package...：\n\n点击Browse... 选择之前下载的 ipk 包，点击 Upload，然后点击 Install：\n\n\n这个时候可能会失败：\n\n看错误信息貌似是 dnsmasq-full 和已经安装的 dnsmasq 有冲突，看名字 dnsmasq-full 应该是比 dnsmasq 功能更全面的包，所以我们可以把 dnsmasq 卸载了。我们在 Installed 标签页筛出这个包来，点击 Remove。（直接在 ssh 里执行 opkg remove dnsmasq 也行）\n\n再次安装 OpenClash ipk 包，不出意外的话就装好了。可能会弹出 XHR 错误，忽略它。重启路由器，会发现顶部菜单栏多出了一个 Service，OpenClash 入口就在这个菜单下。点击进到 OpenClash 页，这时候 OpenClash 会提示你安装内核，点击 Install 进行安装。然后会自动跳转到日志页展示内核的安装日志，我这里的日志显示是安装成功了，如果你安装失败了，就得手动下载内核放到指定目录，可以去网上搜一下，很简单。\n\n编辑 OpenClash 配置回到 OpenClash，切换到 Config Manage 选项卡，滑到下面的 Config File Edit 编辑你的配置。左边是编辑区，右边的是运行时配置预览区。如果你手里已经有配置文件，只需要把它粘贴到左边就行了：\n\n这里附上一个我自用的模板，有两个留空的 SS 节点，替换一下就行：\nhttps://cloud.189.cn/t/RnyYvymuQzYz（访问码：7iv6）\n编辑完成后，点击下面的 Apply Settings ，这时候 OpenClash 会重启，重启完之后，不出意外的话，这时候再让你的 switch 连上 OpenWrt，下载速度应该快到飞起。当然，前提是你的线路本身足够快 : ) 。\n现在 OpenWrt 和 OpenClash 都安装好了，双喜临门。OpenWrt 还有很多可以折腾的地方，可以换语言，换主题，装插件。这个我就不再细说了，大家可以去网上搜索教程。我反正是折腾了一圈，最后还用回了官方的主题。还是官方主题用起来顺手，特别是顶部菜单的设计，鼠标悬浮就能展开二级菜单，有些主题菜单在侧边栏，需要点击一级菜单才能展开二级菜单，要是来回切换一级菜单的话，就有点麻烦。\n如果你还是想继续折腾，折腾之前不妨先接着往下看。\n扩容和备份扩容不管你的 SD 卡有多大，烧完 OpenWrt 后，rootfs 分区也只剩下几十 M 的空间，折腾的时候极有可能会遇到磁盘空间不足的情况。因此我们先对 OpenWrt 做一下扩容，先把它扩到 1G。\n当然，你也可以扩容到更大，但因为后面要对分区进行备份，分区太大备份要花较长时间，建议折腾完后再扩容到最大。\n\n我用的分区工具是 Linux 平台的 Gparted，Windows 的傲梅分区助手应该也行。打开 Gparted，右上角选择 SD 卡，然后右键 rootfs 分区调出上下文菜单，点击 调整大小/移动。\n\n输入分区的新大小（也可以用上面的滑块来调整），然后点击 调整大小/移动，最后点击  ✔ 提交。\n\nOK，分区现在有 1G 了，你可以尽情去折腾了。\n备份折腾的过程中软路由可能会变砖，因此我们要养成一个好习惯，经常做下备份，留个检查点，不至于前功尽弃。其实 OpenWrt 自己就有备份的功能，但它备份的是 &#x2F;etc 目录，假如某个软件的配置文件存在其他地方，恢复的时候就可能出现一些奇奇怪怪的问题。更稳妥的备份方法当然是把分区给备份下来，扩容后分区的总大小也只有 1G 左右，完整备份也不费事。我这里用来备份的工具是 Windows 平台的 Win32DiskImager，Mac 平台和 Linux 平台应该也有类似的工具，大家可以去找一下。\n我们先创建一个名为 openwrt_backup.img 的空文件，然后打开 Win32DiskImager，映像文件选择我们刚创建的 openwrt_backup.img，设备选择 SD 卡对应的盘符，勾选 仅读取已分配分区，然后点击读取，接着 SD 卡中的内容就会读入到 openwrt_back.img 中了。备份过程中可能会出现 “剩余空间错误” 的弹窗，直接忽略。\n\n恢复的方法和前面烧录镜像的方法一样。\n 其实 Win32DiskImager 也能实现烧录，步骤和上面一样，只是把 读取 改成 写入。\n\n结语OK，分享到此结束。祝大家玩得开心！\n‍\n","tags":["折腾"]},{"title":"理解跨源资源共享（CORS）","url":"/2024/04/04/2024-04-04-understand-cross-origin/","content":"什么是跨源请求先看同源 URL 定义：\n\n如果两个 URL 的协议、端口（如果有指定的话）和主机都相同的话，则这两个 URL 是同源的。这个方案也被称为“协议&#x2F;主机&#x2F;端口元组”，或者直接是“元组”。（“元组”是指一组项目构成的整体，具有双重&#x2F;三重&#x2F;四重&#x2F;五重等通用形式。）\n\n当网页发出请求的 URL 和网页的 URL 是非同源的，我们便说这个请求是跨源请求。安全起见，浏览器会对跨源请求做出限制。\n为什么要对跨源请求进行限制假如你曾经登录过银行网站 A，该网站会将 token 保存在你浏览器的 Cookies 中。某天你收到了一封来自钓鱼网站 B 的邮件，你点开链接打开了 B 网站，B 网站调用 A 网站的转账接口，企图将你在这家银行的钱转进他的帐户里。如果浏览器不对跨源请求做任何限制，A 网站的 Cookies 便会附带到转账请求中，请求就能顺利通过 A 网站服务器的身份验证，你的钱就被转走了。\n为了解决这个问题，浏览器引入了 同源策略。\n\n\n什么是同源策略同源策略(Same-Origin Policy)是浏览器的一个重要安全机制，用于限制不同源之间的资源访问，同源策略包含以下内容：\n\n不允许网页发送非同源的 Ajax 请求，否则浏览器拒绝发送请求，直接返回失败。\n允许 img、script 、link 这类资源标签触发的跨源请求，且请求会附带 Cookies，但对响应数据的访问加以限制。举个例子，如果开发者将跨源 img 绘制到 canvas 上，浏览器会将这张 canvas 标记为 “已污染”，后续开发者无法将 canvas 转储为图片文件（toBlob()）或者 data url （toDataUrl()）导出，这是为了防止恶意网站借助 canvas 获取用户在其他网站上的图片。对于跨源 script 资源，只允许执行，不允许读取源代码，且语法错误无法被非同源的 script 捕获。其他标签也都有类似的限制，这里就不展开说了。\nform 表单可以发送携带 Cookies 的跨域请求。\n\n同源策略一定程度上保护了用户的安全，但其引入的诸多限制对开发者很不友好，考虑以下几种场景：\n\n网页需要通过 Ajax 获取在 CDN 服务器上托管的资源。\n获取自己另一个域名下的 &lt;img&gt; 并将其绘制在 canvas 上，随后需要将其转储为图片。\n\n上面两种场景中，虽然存在跨源请求，但是两个 “源” 归属同一所有者，它们是可以互相信任的。然而同源策略不分敌友的一刀切政策，使得看上去很简单的需求难以实现。为了绕过这种限制，程序员摸索出了很多奇技淫巧，比较常见的就是 Jsonp，它利用的是 script 可以跨源的特性。我们看看它是如何让跨源请求 “绝处逢生” 的。\n使用 JSONP 突破同源策略JSONP 把跨源 Ajax 请求伪装成一个外部 script 资源，这是网页和目标网站之间的“秘密”，浏览器并不知情，因此浏览器会正常发送请求获取该外部脚本。重点来了，目标网站服务器返回的脚本并非普通的静态资源，而是根据请求动态生成的。这段脚本会将响应数据作为参数去调用发送请求时指定的回调函数，从而让客户端收到请求结果。这么说可能有点难理解，我们通过具体例子来说明。\n网站 A (https://a.com) 想要发送 https://api.b.com/get-user-info 这样一个请求给服务器 B。由于跨源，请求无法以 Ajax 的形式发送，于是网站 A 的脚本动态地添加了一个 script 标签：\nfunction onGetUserInfoSuccess(data) &#123;  console.log(data);&#125;function onGetUserInfoError(e) &#123;  console.log(e);&#125;const script = document.createElement(&#x27;script&#x27;);script.src = &#x27;https://api.b.com/get-user-info?onsuccess=onGetUserInfoSuccess&amp;onerror=onGetUserInfoError&#x27;;document.head.appendChild(script);\n\n浏览器正常发送了这个外部脚本请求，服务器 B 返回的是：\nonGetUserInfoSuccess(&#123;&quot;Name&quot;: &quot;小明&quot;, &quot;Id&quot;: 1823, &quot;Rank&quot;: 7&#125;);\n\n浏览器执行上述脚本，将响应数据传给了网页 A 的回调函数 onGetUserInfoSuccess。实际 JSONP 的做法和上述例子有点差异，但原理是一样的。这种跨院请求方案虽然绕过了浏览器的限制，但存在安全隐患，需要目标服务器做好防范措施。\n奇技淫巧也只是权宜之计，大家还是希望能浏览器能原生支持受信任的跨源请求。千呼万唤之下，跨源资源共享（CORS）出现了。\n迎接 CORSCORS（跨源资源共享）是对同源策略下敌友不分的一刀切机制的改进。同源策略的问题在于，它假设所有网站都不被域名之外的服务器所信任，这种假设过于简单粗暴。防止敌人混入城堡的正确方式是在城门口配上守卫，对进城的人进行身份验证，而不是把城门焊死。CORS 是如何尽好守卫职责的呢？我们还是将跨源请求分为 Ajax 请求、标签资源请求和表单请求，逐个分析。\nAjax 请求出于对安全性和兼容性的考量，浏览器将 Ajax 请求分为简单请求和非简单请求。简单请求的定义见 MDN 对简单请求的定义 ，不满足简单请求定义的便是非简单请求。我们先看非简单请求。\n非简单请求如果一个请求被判定为非简单请求，浏览器会在发送正式的跨源请求之前，先发送一个 method 为 OPTION 的 预检请求 给目标服务器，询问目标服务器是否允许该网页给它发送跨源请求，若允许，目标服务器便可在响应中表明该许可，浏览器收到后会将正式请求发出，并将请求结果给到网页；若不允许或者干脆不响应，浏览器则不会发送正式请求，跨源请求宣告失败。与此同时，浏览器会在控制台打印 CORS 错误日志，便于开发者排查跨源请求失败的具体原因。\n所谓询问服务器，其实就是在预检请求的请求中添加 Origin 头和 Access-Control-Request-* 头。其中：\n\nOrigin 表示请求发起者的源，例如，https://foo.com/index.html 向 bar.com 发起请求，那么 Origin 就是 https://foo.com。\n\nAccess-Control-Request-* 包括 Access-Control-Request-Headers，Access-Control-Request-Method 等，用来描述正式请求的那些不满足简单请求定义的特征，假如某个请求的 method 为 DELETE，Content-Type为 application/json，那么 Access-Control-Request-Method 就是 DELETE，Access-Control-Request-Headers 就是 Content-Type。\n\n\n所谓表明许可，其实就是服务器在预检请求的响应中添加 Access-Control-Allow-* 头，用来答复请求头中的 Access-Control-Request-*。如果 Access-Control-Allow-* 的值包含了 Access-Control-Request-* 的值，表明该跨源请求被允许，反之不被允许。对于携带了 Cookies 的请求（如 fetch API 的 credentials: &#39;include&#39; 和 XMLHttpRequest 的 withCredentials=true ），服务器需要在响应中额外添加 Access-Control-Allow-Credentails: true 头，且此时 Access-Control-Request-Origin、Access-Control-Request-Headers 的值不允许使用通配符 *，必须为具体值的列表，上述条件任何一个不满足，浏览器都不会发送正式请求。\n简单请求对于简单的 Ajax 请求，浏览器不发送预检请求，而是直接发送正式请求，但服务器必须和响应非简单请求的预检请求一样，在这个正式请求的响应中包含 Access-Control-Allow-* 头，从而表明网页是否被允许读取响应数据，如果允许，浏览器便将响应数据返回给网页，否则丢弃，告诉网页请求失败（实际是请求成功了，只是给网页返回失败结果）。同样地，对于携带了 Cookies 的请求（如 fetch API 的 credentials: &#39;include&#39; 和 XMLHttpRequest 的 withCredentials=true ），服务器需要在响应中额外添加 Access-Control-Allow-Credentails: true 头，且此时 Access-Control-Request-Origin、Access-Control-Request-Headers 等字段的值不允许使用通配符 *，必须为具体值的列表，上述条件任何一个不满足，浏览器都会丢弃响应数据，给网页返回请求失败的结果。\n有几个问题值得探讨：\n\n浏览器为什么要违背同源策略的限制，不加任何限制就将简单请求发送给服务器？没有安全风险吗？\n 简单请求是按照表单请求的特征来定义的，换句话说，简单请求是从 Ajax 中抽出来的、符合表单请求特征的那一类请求。我们知道，在 CORS 出现之前，同源策略就允许发送跨源表单请求，基于这个事实，浏览器假定服务器对于跨源表单请求存在的 CSRF 攻击早有防范，因此对于那些还没准备好迎接 CORS 的服务器而言，不加任何修改便能应对简单请求存在的 CSRF 攻击。从服务器的角度看，两者没有区别，服务器要是防不了简单请求的 CSRF 攻击，它同样防不了表单请求的 CSRF 攻击。简单请求没有引入额外的风险，但简单请求带来的额外的好处是，开发者被允许发送这类 Ajax 请求了，这在同源策略统治时期是不可能的。\n\n为什么服务器不在响应中添加 Access-Control-Allow-* ，浏览器就不把响应数据返回给网页呢？\n 同源策略下，表单请求虽然能够发送请求，但拿不到结果，因为请求提交后浏览器就会刷新。在 CORS 出现之前，也许存在某些服务器，有意无意中依赖这种行为实现一定程度的安全性。引入 CORS 后，浏览器既然把简单请求作为表单请求的变体，就应当让两者行为及影响保持一致，从而不破坏现有服务器的安全性。于是浏览器就模仿表单请求，阻止网页拿到简单请求的响应，只有在服务器明确表示允许前提下，才将响应返回给网页。\n\n简单请求为什么不发送预检请求？\n 简单请求作为表单请求的变体，直接发送并不会破坏同源策略，发送预检请求只会增加请求延迟。非简单请求就从来没被允许发送过，为了保持兼容，必须先通过预检请求征得服务器的同意才可发送正式请求。\n\n\n标签资源请求除了 Ajax，CORS 也对标签触发的跨源请求放开了限制。同源策略下，标签是被允许发送携带 Cookies 的跨源请求的，只是无法读取资源的内容，因此这里所说的限制是指对请求资源的读取限制。放开限制意味着破坏了同源策略，这当然是不行的，安全起见，支持 CORS 的浏览器必须对资源的 “读许可” 附加额外的条件，浏览器给开发者提供了两个选择：\n\n添加 crossorigin=&quot;anonymous&quot; 属性，告诉浏览器请求资源时不需要附带任何代表用户身份的凭证 ，包括 Cookies 、 Authorization 和客户端证书，这样一来，浏览器请求到的就是非敏感数据，允许非敏感数据的读取不会有安全隐患。\n添加 crossorigin=&quot;use-credentials&quot; 属性，告诉浏览器该请求需要携带代表用户身份的凭证，包括 Cookies 、 Authorization 和客户端证书。和简单的 Ajax 请求一样，包含 crossorigin=&quot;use-credentials&quot; 属性的标签不会发送单独的预检请求来询问服务器的许可，而是将请求直接发送出去。服务器同样需要在响应头中通过 Access-Control-Allow-* 来表明许可。和前面那些附带 cookies 的请求一样，服务器必须在响应头中添加 Access-Control-Allow-Credentails: true ，且此时 Access-Control-Request-Origin、Access-Control-Request-Headers 等字段的值不允许使用通配符 *，必须为具体值的列表，上述条件任何一个不满足，浏览器都会回退到同源策略，限制网页对资源的读取，但资源仍可用于展示或执行，这样做同样是为了和同源策略保持兼容从而不破坏既有服务器的安全性。\n\n表单请求表单请求还是继续保持同源策略下的限制不变。我觉得这么做的原因可能是开发者很容易将表单请求迁移到 Ajax 请求来实现跨域资源共享，所以没有必要对表单请求制定一套 CORS 规则。\n结语关于 CORS 的更多玩法，大家感兴趣的话可以继续阅读 MDN 的相关文档。本文很多地方是我自己的理解，有不对的地方还请不吝赐教。\n","tags":["前端"]},{"title":"探究 Kotlin 协程","url":"/2024/04/08/2024-04-08-kotlin-coroutine-state-machine/","content":"前言Kotlin 中的协程是无栈协程（话说 Kotlin 能实现有栈线程吗🤔），网上很多文章都说无栈协程一般都是通过状态机实现的，刚开始听到这个状态机的时候觉得有点玄乎，今天打算利用反编译工具并结合协程库源码，来探究一下 Kotlin 协程实现原理。\n从一个简单的示例开始fun main() &#123;    runBlocking &#123;        val result = fun1()        println(result)    &#125;&#125;suspend fun fun1(): Int &#123;    var localInt = 0    localInt += fun2()    localInt += fun3()    return localInt&#125;suspend fun fun2(): Int = 1suspend fun fun3(): Int &#123;    delay(1000)    return 1&#125;\n\n\n\n以上代码通过 runBlocking()​ 开启协程，协程调用 fun1()​ ，然后打印结果。fun1()​ 是一个 suspend​ 方法，它定义了一个局部变量 localInt​，然后依次执行了 fun2()​ 和 fun3()​ 并将二者结果累加到 localInt​ 中，最后将 localInt​ 返回。fun2()​ 是一个普通方法,fun3()​ 内调用了 delay()​，delay()​ 是协程库提供的 suspend​方法。\n下面我们将会从 runBlocking()​ 开始，揭开 Kotlin 协程的神秘面纱。\nBuilders#runBlockingpublic actual fun &lt;T&gt; runBlocking(context: CoroutineContext, block: suspend CoroutineScope.() -&gt; T): T &#123;    contract &#123;        callsInPlace(block, InvocationKind.EXACTLY_ONCE)    &#125;    val currentThread = Thread.currentThread()    val contextInterceptor = context[ContinuationInterceptor]    val eventLoop: EventLoop?    val newContext: CoroutineContext    if (contextInterceptor == null) &#123;        // create or use private event loop if no dispatcher is specified        eventLoop = ThreadLocalEventLoop.eventLoop        newContext = GlobalScope.newCoroutineContext(context + eventLoop)    &#125; else &#123;        // See if context&#x27;s interceptor is an event loop that we shall use (to support TestContext)        // or take an existing thread-local event loop if present to avoid blocking it (but don&#x27;t create one)        eventLoop = (contextInterceptor as? EventLoop)?.takeIf &#123; it.shouldBeProcessedFromContext() &#125;            ?: ThreadLocalEventLoop.currentOrNull()        newContext = GlobalScope.newCoroutineContext(context)    &#125;    val coroutine = BlockingCoroutine&lt;T&gt;(newContext, currentThread, eventLoop)    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)    return coroutine.joinBlocking()&#125;\n\n这个方法的逻辑非常清晰：\n\n5 ~ 19 行用来构建协程的上下文，协程上下文是一些元素的集合，包括拦截器，代表协程的任务，异常处理器，协程名称等。\n20 行 BlockingCoroutine&lt;T&gt;(newContext, currentThread, eventLoop)​构建协程对象\n21 行 coroutine#start()​ 启动协程\n22 行阻塞当前线程，直到协程结束。\n\n只要搞懂了 BlockingCotoutine​ 和 coroutine#start()​，就能对 Kotlin 协程的实现原理有一个大致的了解。为了便于理解，我们先从  Coroutine#Start()​ 着手。\nCoroutine#Start省略一些中间过程，Coroutine#Start​ 最后会调用到下面这个方法：\nCoroutineStarter#invokepublic operator fun &lt;R, T&gt; invoke(block: suspend R.() -&gt; T, receiver: R, completion: Continuation&lt;T&gt;): Unit =        when (this) &#123;            DEFAULT -&gt; block.startCoroutineCancellable(receiver, completion)            ATOMIC -&gt; block.startCoroutine(receiver, completion)            UNDISPATCHED -&gt; block.startCoroutineUndispatched(receiver, completion)            LAZY -&gt; Unit // will start lazily        &#125;\n\n协程有多种启动模式，简单起见，我们只研究 DEFAULT​ 模式，其他分支原理大同小异。block.startCoroutineCancellable()​ 源码如下：\nCancellable#startCoroutineCancellable/** * Use this function to start coroutine in a cancellable way, so that it can be cancelled * while waiting to be dispatched. */internal fun &lt;R, T&gt; (suspend (R) -&gt; T).startCoroutineCancellable(    receiver: R, completion: Continuation&lt;T&gt;,    onCancellation: ((cause: Throwable) -&gt; Unit)? = null) =    runSafely(completion) &#123;        createCoroutineUnintercepted(receiver, completion).intercepted().resumeCancellableWith(Result.success(Unit), onCancellation)    &#125;\n\n重点是 createCoroutineUnintercepted()​：\nIntrinsicsJvm#createCoroutineUnintercepted@SinceKotlin(&quot;1.3&quot;)public actual fun &lt;R, T&gt; (suspend R.() -&gt; T).createCoroutineUnintercepted(    receiver: R,    completion: Continuation&lt;T&gt;): Continuation&lt;Unit&gt; &#123;    val probeCompletion = probeCoroutineCreated(completion)    return if (this is BaseContinuationImpl)        create(receiver, probeCompletion)    else &#123;        createCoroutineFromSuspendFunction(probeCompletion) &#123;            (this as Function2&lt;R, Continuation&lt;T&gt;, Any?&gt;).invoke(receiver, it)        &#125;    &#125;&#125;\n\n一般来说代码会走到 if 分支。if 分支调用了 suspend block 的 create()​ 方法。这个方法是编译器为 suspend lambda 生成的。接下来我们需要反编译示例代码来进一步探究。\n反编译 Kotlin 代码是没法使用传统的反编译工具来完成的，需要在 IDEA 中打开 Kotlin 字节码文件，然后点击 工具 -> Kotlin -> 反编译为  Java 来完成。\n\nmain先看 main​ 方法的反编译结果：\npublic static final void main() &#123;      BuildersKt.runBlocking$default((CoroutineContext)null, (Function2)(new Function2((Continuation)null) &#123;         int label;         @Nullable         public final Object invokeSuspend(@NotNull Object $result) &#123;            Object var3 = IntrinsicsKt.getCOROUTINE_SUSPENDED();            Object var10000;            switch (this.label) &#123;               case 0:                  ResultKt.throwOnFailure($result);                  Continuation var4 = (Continuation)this;                  this.label = 1;                  var10000 = TestKt.fun1(var4);          // fun1()                  if (var10000 == var3) &#123;                     return var3;                  &#125;                  break;               case 1:                  ResultKt.throwOnFailure($result);                  var10000 = $result;                  break;               default:                  throw new IllegalStateException(&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;);            &#125;            int result = ((Number)var10000).intValue();            System.out.println(result);            return Unit.INSTANCE;         &#125;         @NotNull         public final Continuation create(@Nullable Object value, @NotNull Continuation $completion) &#123;            return (Continuation)(new &lt;anonymous constructor&gt;($completion));         &#125;         @Nullable         public final Object invoke(@NotNull CoroutineScope p1, @Nullable Continuation p2) &#123;            return ((&lt;undefinedtype&gt;)this.create(p1, p2)).invokeSuspend(Unit.INSTANCE);         &#125;         // $FF: synthetic method         // $FF: bridge method         public Object invoke(Object p1, Object p2) &#123;            return this.invoke((CoroutineScope)p1, (Continuation)p2);         &#125;      &#125;), 1, (Object)null);   &#125;\n\n​runBlocking$default()​ 是 runBlocking()​ 的反编译后的名字。反编译后的代码中，它接收四个参数，后面两个参数暂时不用理会。第一个参数类型为 CoroutineContext​，传入的是 null​。第二个参数是一个 Function2​ 对象，Function2​ 是 Kotlin 库中的一个接口，定义如下：\npublic interface Function2&lt;in P1, in P2, out R&gt; : Function&lt;R&gt; &#123;    /** Invokes the function with the specified arguments. */    public operator fun invoke(p1: P1, p2: P2): R&#125;\n\nKotlin 编译器用 Function1​，Function2​ … FuncitonX​  接口来实现 lambda 表达式，Function 后面的数字表示 lambda 参数的数量。如果 lambda 有 receiver，receiver 会被视为其第一个参数，则 invoke()​ 的第一个参数为 receiver，后续参数为 lambda 的实际参数。例如，lambda 表达式  val a: Int.(Int, Int) -&gt; Int = &#123; x: Int, y: Int -&gt; this + x + y &#125;​ 会用以下代码来实现：\nFunction3 a =  new Function3&lt;Integer, Integer, Integer, Object&gt; &#123;    /** Invokes the function with the specified arguments. */    public final Object invoke(Integer p1, Integer p2, Integer p3) &#123;\t\treturn p1 + p2 + p3;\t&#125;&#125;\n\n对于 suspend lambda，实现则略有不同，例如对于一个空的 lambda： val a: suspend () -&gt; Unit = &#123;&#125;​，实际上生成的对象通常长这样的：\nclass _SuspendLambda extends SuspendLambda implements Function1&lt;Object&gt; &#123;    public final Object invokeSuspend(Object result) &#123;\t\t /* lambda 函数体逻辑，省略 */    &#125;    public _SuspendLambda(Continuation completion) &#123;\t\tsuper(0 /* 这个值具体是多少不知道，也不重要，我这里是乱写的 */, completion):\t&#125;    /** Invokes the function with the specified arguments. */    public final Object invoke(Continuation completion) &#123;\t\treturn this.create(completion).invokeSuspend(completion)\t&#125;    public Object invoke(Object p1) &#123;        return this.invoke((Continuation)p2);    &#125;\t\t    public final Continuation create(completion: Continuation) &#123;         return AnnoymousClass(completion));    &#125; &#125;\n\nKotlin 会为每一个 suspend lambda 生成一个继承 SuspendLambda​ 并实现 FunctionX​ 接口的匿名类，并且还给它添加了一个 Cotinuation​ 类型的参数（这个参数具体什么含义，我们后面会讲）。此外，编译器还会为它额外生成 invokeSuspend()​ ，create()​ 和 invoke()​ 这三个方法。invokeSuspend()​ 中包含的是 lambda 函数体的逻辑，create()​ 则是用来创建该类的一个新实例，invoke()​ 重载方法貌似有点多余，只是对参数类型具体化了一下而已。\n我们现在回过头来看 runBlocking​ 的 suspned lambda 参数反编译后的代码：\nnew Function2((Continuation)null) &#123;         int label;         @Nullable         public final Object invokeSuspend(@NotNull Object $result) &#123;            Object var3 = IntrinsicsKt.getCOROUTINE_SUSPENDED();            Object var10000;            switch (this.label) &#123;               case 0:                  ResultKt.throwOnFailure($result);                  Continuation var4 = (Continuation)this;                  this.label = 1;                  var10000 = TestKt.fun1(var4);          // fun1()                  if (var10000 == var3) &#123;                     return var3;                  &#125;                  break;               case 1:                  ResultKt.throwOnFailure($result);                  var10000 = $result;                  break;               default:                  throw new IllegalStateException(&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;);            &#125;            int result = ((Number)var10000).intValue();            System.out.println(result);            return Unit.INSTANCE;         &#125;         @NotNull         public final Continuation create(@Nullable Object value, @NotNull Continuation $completion) &#123;            return (Continuation)(new &lt;anonymous constructor&gt;($completion));         &#125;         @Nullable         public final Object invoke(@NotNull CoroutineScope p1, @Nullable Continuation p2) &#123;            return ((&lt;undefinedtype&gt;)this.create(p1, p2)).invokeSuspend(Unit.INSTANCE);         &#125;         // $FF: synthetic method         // $FF: bridge method         public Object invoke(Object p1, Object p2) &#123;            return this.invoke((CoroutineScope)p1, (Continuation)p2);         &#125;   &#125;\n\n它便是编译器为我们生成的 SuspendLambda 匿名子类对象，后续我会用 _SuspendLambda​ 表示这个匿名子类。\n反编译器没能展示出这个匿名类和 SuspendLambda 的继承关系，但可以通过在 runBlocking() 添加断点得知 suspend lambda 最终确实被编译成了 SuspendLambda 的一个匿名子类。\n\n细心的你会发现不一样的地方，就是 invoke()​ 多了一个类型为 CoroutineScope​ 的参数。这是因为 runBlocking()​ 的 suspend lambda 参数有 receiver，前面讲过，如果 lambda 有 receiver， receiver 会被视为 lambda 的第一个参数。\n回过头看看 createCoroutineUnintercepted​：\n@SinceKotlin(&quot;1.3&quot;)public actual fun &lt;R, T&gt; (suspend R.() -&gt; T).createCoroutineUnintercepted(    receiver: R,    completion: Continuation&lt;T&gt;): Continuation&lt;Unit&gt; &#123;    val probeCompletion = probeCoroutineCreated(completion)    return if (this is BaseContinuationImpl)        create(receiver, probeCompletion)    else &#123;        createCoroutineFromSuspendFunction(probeCompletion) &#123;            (this as Function2&lt;R, Continuation&lt;T&gt;, Any?&gt;).invoke(receiver, it)        &#125;    &#125;&#125;\n\n​this​ 是 suspend lambda，前面说了，它是一个 _SuspendLambda​ 对象，而 _SuspendLambda​ 的继承链是：_SuspendLambda​ -&gt; SuspendLambda -&gt; ContinuationImpl​ -&gt; BaseContinuationImpl​ -&gt; Continuation​，因此代码会进入 if​ 分支。if​ 分支很简单，就是调用 _SuspendLambda 的 create()​ 方法来生成该类的一个新实例，前面说过，create() 方法是编译器为 _SuspendLambda 生成的。\nelse​ 分支的逻辑是： 当编译器为 suspend lambda 生成的对象实现了 Function2​ 接口并非继承自 BaseContinuationImpl ​时，将其包装成 Continuation ​再返回。什么时候会走到 else 分支目前我并不清楚，因为目前为止我发现 suspend lambda 都是继承自 BaseContinuationImpl。​\n\n\n往前看 startCoroutineCancellable()​：\ninternal fun &lt;R, T&gt; (suspend (R) -&gt; T).startCoroutineCancellable(    receiver: R, completion: Continuation&lt;T&gt;,    onCancellation: ((cause: Throwable) -&gt; Unit)? = null) =    runSafely(completion) &#123;        createCoroutineUnintercepted(receiver, completion).intercepted().resumeCancellableWith(Result.success(Unit), onCancellation)    &#125;\n\n​intercepted()​ 是 Kotlin 用来实现上下文切换的，这个我们先不管，因为我们的示例并未涉及协程的上下文切换，可以认为这个方法不包含任何逻辑，只是简单地返回对象本身。重点是 resumeCancellableWith()​ ：\npublic fun &lt;T&gt; Continuation&lt;T&gt;.resumeCancellableWith(    result: Result&lt;T&gt;,    onCancellation: ((cause: Throwable) -&gt; Unit)? = null): Unit = when (this) &#123;    is DispatchedContinuation -&gt; resumeCancellableWith(result, onCancellation)    else -&gt; resumeWith(result)&#125;\n\n涉及上下文切换时才会走到 is DispatchedContinuation​分支，因此程序会进入 else​ 分支，else​ 分支调用的是 Continuation​ 的 resumeWith()​，这个方法在 Continuation​ 接口定义：\npublic interface Continuation&lt;in T&gt; &#123;    /**     * The context of the coroutine that corresponds to this continuation.     */    public val context: CoroutineContext    /**     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the     * return value of the last suspension point.     */    public fun resumeWith(result: Result&lt;T&gt;)&#125;\n\n再进一步探索之前，我们先得了解一下协程中的 Continuation ​是什么东西。看下维基百科对协程的定义：\n\n协程（英语：coroutine）是计算机程序的一类组件，推广了协作式多任务的子例程，允许执行被挂起与被恢复\n\n​Continuation​ 正是 Kotlin 用来实现协程 允许执行被挂起与被恢复 这一语义的。Continuation​ 逻辑上是一个栈式结构，它用来模拟 suspend 方法（包括 suspend lambda）的调用栈，为什么需要模拟 suspend 方法的调用栈？我们知道，非 suspend 方法的调用栈是由虚拟机维护的，也就是我们所熟悉的栈帧，但是虚拟机并不会为 suspend 方法生成栈帧，这是因为 suspend 方法的调用是异步的，虚拟机的世界中，并没有异步方法调用的概念，它属于 Kotlin 语言自己的语义范畴，Kotlin 编译器必须自己负责实现这个语义。\nKotlin 实现这个语义的方案是，编译时为每一个 suspend 方法生成一个对应的 Continuation​ 对象（一般是 BaseContinuationImpl 的子类对象），由这个对象负责保存 suspend 方法的上下文，同时会为其生成一个 invokeSuspend() 方法，然后把 suspend 方法体的逻辑塞进这个 invokeSuspend() 方法中。编译器逻辑上会把一个 suspend 方法分割成多段分步执行，具体来说是：每当遇到对其他 suspend 方法的调用点时，当前 suspend 方法便会被挂起（暂停执行），其上下文会保存到对应的Continuation​对象中，后续可调用其 resumeWith()​ 方法（通常由下游 suspend 方法对应的 Continuation​ 对象调用）恢复该 suspend 方法的上下文，让它从挂起点接着执行，就这样 “断断续续” 地执行直到当前 suspend 方法执行完毕。当前 suspend 方法执行完毕后，会调用调用栈上游的 suspend 方法对应的Continuation​对象的 resumeWith()​方法，从而让上游的 suspend 方法接着执行。上游方法重复这个过程，直到最顶层的 suspend 方法执行完毕。\n现在听上去可能会有点抽象，接下来我们看具体实现就明白了。\n\nresumeWith() ​是 Continiuation ​接口的唯一方法，它在子类 BaseContinuationImpl ​中有个 final ​实现：\nBaseContinuationImplinternal abstract class BaseContinuationImpl(    // completion 便是上游 suspend 方法对应的 Continuation 对象    public val completion: Continuation&lt;Any?&gt;?) : Continuation&lt;Any?&gt;, CoroutineStackFrame, Serializable &#123;    public final override fun resumeWith(result: Result&lt;Any?&gt;) &#123;        var current = this        var param = result        while (true) &#123;            probeCoroutineResumed(current)            with(current) &#123;                val completion = completion!! // fail fast when trying to resume continuation without completion                val outcome: Result&lt;Any?&gt; =                    try &#123;                        val outcome = invokeSuspend(param)                        if (outcome === COROUTINE_SUSPENDED) return                        Result.success(outcome)                    &#125; catch (exception: Throwable) &#123;                        Result.failure(exception)                    &#125;                releaseIntercepted() // this state machine instance is terminating                if (completion is BaseContinuationImpl) &#123;                    // unrolling recursion via loop                    current = completion                    param = outcome                &#125; else &#123;                    // top-level completion reached -- invoke and return                    completion.resumeWith(outcome)                    return                &#125;            &#125;        &#125;    &#125;    // 此方法的实现由编译器生成    protected abstract fun invokeSuspend(result: Result&lt;Any?&gt;): Any?    ......&#125;\n\n这是一个典型的用循环展开尾递归的的例子，目的是避免因过深的调用栈造成栈溢出，同时生成更简洁的调用栈信息。为了便于理解，将其还原成递归：\npublic final override fun resumeWith(result: Result&lt;Any?&gt;) &#123;    probeCoroutineResumed(this)    val completion = completion ?: error(&quot;Completion should not be null&quot;)    val outcome: Result&lt;Any?&gt; = try &#123;        val outcome = invokeSuspend(result)        if (outcome === COROUTINE_SUSPENDED) return        Result.success(outcome)    &#125; catch (e: Throwable) &#123;        Result.failure(e)    &#125;    releaseIntercepted()    if (completion is BaseContinuationImpl) &#123;        // 递归调用上游 Continuation        completion.resumeWith(outcome)    &#125; else &#123;        // 调用到最顶层 Continuation        completion.resumeWith(outcome)    &#125;&#125;\n\n前面提到过，第 6 行的 invokeSuspend() 是编译器为 suspend lambda（或 suspend 方法）生成的 Continuaion 对象中的方法，其中包含了 suspend lambda（或 suspend 方法）方法体的逻辑。如果 invokeSuspend() 返回的是 COROUTINE_SUSPENDED​，则会导致resumeWith()​ 返回，这表示该Continuation​对应的 suspend 方法挂起。否则说明 suspend 方法执行完毕，接着会递归调用上游 suspend 方法的 Continuation​ 对象的 resumeWith​ 方法来恢复上游 suspend 方法的执行。\nKotlin 将上游 suspend 方法的 Continuation​ 对象命名为 completion​ ，可以说是非常贴切了。\n\n我们回顾一下 _SuspendLambda 的 invokeSuspend() 方法，为便于理解我将其写成 Kotlin 并进行简化：\n_SuspendLambdaclass _SuspendLambda : SuspendLambda, Function1&lt;Object&gt; &#123;\tval label = 0    public final fun invokeSuspend(result: Object): Object &#123;\t\tvar fun1Result: Object?        when (this.label) &#123;            0 -&gt; &#123;                Result.throwOnFailure(result)                this.label = 1                fun1Result = fun1(this as Continuation)         // fun1()                if (fun1Result == COROUTINE_SUSPENDED) &#123;                    return COROUTINE_SUSPENDED                &#125;            &#125;            1 -&gt; &#123;                Result.throwOnFailure(result)                fun1Result = result            &#125;            else -&gt;                throw IllegalStateException(&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;)        &#125;        val finalResult = fun1Result as Int        println(finalResult)        return Unit.INSTANCE    &#125;    fun _SuspendLambda(Continuation completion) &#123;\t\tsuper(0 /* 这个值具体是多少不知道，也不重要，我这里是乱写的 */, completion):\t&#125;    /** Invokes the function with the specified arguments. */    final fun invoke(value: CoroutineScope, completion: Continuation): Object &#123;\t\treturn this.create(value, completion).invokeSuspend(completion)\t&#125;   fun invoke(Object p1, Object p2): Object &#123;        return this.invoke((CoroutineScope)p1, (Continuation)p2)    &#125;\t\t    final fun create(value: CoroutineScope, completion: Continuation): Continuation &#123;         return _SuspendLambda(completion)    &#125; &#125;\n\ninvokeSuspend() 中的代码就是 Continuation​ 将 suspend 方法 “分割成多段” 的直观展现。在我们的例子中，Kotlin 编译器将 suspend lambda 分割成了两段，一段是调用 fun1()​ 获取结果，另一段是打印结果。接下来我们就来分析一下，Kotlin 是如何对 suspned lambda 分段执行的。\n第一次调用_SuspendLambda​的 resumeWith()​ 方法时，label​ 为 0​，会走到 0 -&gt; ​这个分支。这个分支的逻辑如下：\n\n将 label​ 置位 1，这样下次就会从 1 -&gt;​这个分支执行。\n调用 fun1()​ 获取结果，因为fun1() ​返回的是 COROUTINE_SUSPENDED​ （因为 fun1()​ 是 suspend 方法，所以此处返回的就是 COROUTINE_SUSPENDED​，原因后面分析 fun1()​ 的时候就知道了）， 所以invokeSuspend()​ 会从第 13 行返回，resumeWith()​拿到这个结果后，suspend lambda 的执行则会终止。\n\n你可能会有疑问，示例代码中的fun1()​ 没有参数，为什么这里会传参数？前面说过，当一个 suspend 方法执行完毕后，它会调用上游 suspend 方法对应的 Continuation​ 对象的 resumeWith()​ 方法来恢复上游方法的执行，因此下游方法必须拿到上游方法的 Continuation​ 对象才行。和 suspend lambda 一样，Kotlin 编译器也会为每一个 suspend 方法自动添加一个 Continuation​ 类型的参数，目的就是为了让下游方法持有上游方法的 Continuation​ 对象。\n实际上这个参数有多重含义，这个后面会说\n\n现在来看看 fun1()​ 的逻辑，其反编译结果如下：\n@Nullablepublic static final Object fun1(@NotNull Continuation var0) &#123;   Object $continuation;   label27: &#123;      if (var0 instanceof &lt;undefinedtype&gt;) &#123;         $continuation = (&lt;undefinedtype&gt;)var0;         if ((((&lt;undefinedtype&gt;)$continuation).label &amp; Integer.MIN_VALUE) != 0) &#123;            ((&lt;undefinedtype&gt;)$continuation).label -= Integer.MIN_VALUE;            break label27;         &#125;      &#125;      $continuation = new ContinuationImpl(var0) &#123;         int I$0;         // $FF: synthetic field         Object result;         int label;         @Nullable         public final Object invokeSuspend(@NotNull Object $result) &#123;            this.result = $result;            this.label |= Integer.MIN_VALUE;            return TestKt.fun1((Continuation)this);         &#125;      &#125;;   &#125;   Object var10000;   int localInt;   int var2;   Object var3;   label22: &#123;      Object $result = ((&lt;undefinedtype&gt;)$continuation).result;      Object var6 = IntrinsicsKt.getCOROUTINE_SUSPENDED();      switch (((&lt;undefinedtype&gt;)$continuation).label) &#123;         case 0:            ResultKt.throwOnFailure($result);            localInt = 0;            var2 = localInt;            ((&lt;undefinedtype&gt;)$continuation).I$0 = localInt;            ((&lt;undefinedtype&gt;)$continuation).label = 1;            var10000 = fun2((Continuation)$continuation);            if (var10000 == var6) &#123;               return var6;            &#125;            break;         case 1:            var2 = ((&lt;undefinedtype&gt;)$continuation).I$0;            ResultKt.throwOnFailure($result);            var10000 = $result;            break;         case 2:            var2 = ((&lt;undefinedtype&gt;)$continuation).I$0;            ResultKt.throwOnFailure($result);            var10000 = $result;            break label22;         default:            throw new IllegalStateException(&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;);      &#125;      var3 = var10000;      localInt = var2 + ((Number)var3).intValue();      var2 = localInt;      ((&lt;undefinedtype&gt;)$continuation).I$0 = localInt;      ((&lt;undefinedtype&gt;)$continuation).label = 2;      var10000 = fun3((Continuation)$continuation);      if (var10000 == var6) &#123;         return var6;      &#125;   &#125;   var3 = var10000;   localInt = var2 + ((Number)var3).intValue();   return Boxing.boxInt(localInt);&#125;\n\n为了便于理解同样改写成 Kotlin 代码。代码太多，我使用了 ChatGPT 来辅助完成：\nfun1private class Fun1Continuation(    val completion: Continuation&lt;Any?&gt;) : ContinuationImpl&lt;Any?&gt;(completion) &#123;    var label = 0    var result: Any? = null    var I$0: Int = 0    override fun invokeSuspend(result: Result&lt;Any?&gt;) &#123;        this.result = result.getOrNull()        this.label = this.label or 0x80000000        return fun1(this)    &#125;&#125;fun fun1(continuation: Continuation&lt;Any?&gt;): Any? &#123;    // 如果 continuation 是之前包装过的，直接使用；否则将 continuation 包装成一个 Fun1Continuation，将其作为上游 Continuation 持有    val cont = if (continuation is Fun1Continuation) &#123;        if ((continuation.label and 0x80000000) != 0) &#123;            continuation.label = continuation.label and 0x7fffffff            continuation        &#125; else &#123;            Fun1Continuation(continuation)        &#125;    &#125; else &#123;        Fun1Continuation(continuation)    &#125;    var result = cont.result    run handleAfterFun3@&#123;        run handleAfterFun2@&#123;            when (cont.label) &#123;                0 -&gt; &#123;                    // 初始状态                    Result.throwOnFailure(result)                    val localInt = 0                    cont.I$0 = localInt                    cont.label = 1                    val res = fun2(cont)                    if (res === COROUTINE_SUSPENDED) return COROUTINE_SUSPENDED                    result = res                &#125;                1 -&gt; &#123;                    // 如果 fun2 是异步，那么从 fun2 恢复时会进入到这个分支                    Result.throwOnFailure(result)                    return@handleAfterFun2                 &#125;                2 -&gt; &#123;                    // 如果 fun3 是异步，那么从 fun3 恢复时会进入到这个分支                    Result.throwOnFailure(result)                    return@handleAfterFun3                &#125;                else -&gt; throw IllegalStateException(&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;)            &#125;        &#125;        // fun2 执行完毕后的逻辑，无论同步异步都会走到这        val localInt = cont.I$0        cont.I$0 = localInt + result        cont.label = 2        val res = fun3(cont)        if (res === COROUTINE_SUSPENDED) return COROUTINE_SUSPENDED        result = res    &#125;    // fun3 执行完毕后的逻辑，无论同步异步都会走到这    val localInt = cont.I$0    val finalResult = localInt + result    return finalResult&#125;\n\n改写后的代码逻辑清晰多了，我们来分析一下 fun1() 中的逻辑：\n\n首先是为 fun1()​ 构造对应的 Continuation​。如果传入的 Continuation​ 对象是 Fun1Continuation​ 类型，说明已经包装过了，就不做处理，否则，使用 Fun1Continuation​ 对 continuation​ 进行包装，将其作为上游 Continuation​ 持有。最后得到的 cont​ 便是 fun1()​ 所对应的 Continuation​。前面说过了，Continuation​ 中包含了函数的上下文，从 Fun1Continuation 的定义能看出，这个上下文包含以下几个部分：\n\n执行进度，即 cont.label​；\n上游 suspend​ 方法的 Continuation​ 对象，即 Fun1Continuation 构造方法传入的 completion​\n局部变量，即 cont.I$0​，对应示例中的 localInt​；\n上一次调用 suspend 方法的结果，即 cont.result​；\n\n\n\n接着往下看，有三个分支。\n首先是  0-&gt;​ 分支，fun1()​ 首次调用时会进入这个分支。这个分支做了以下几件事：\n\n将 label​ 置为 1，将 fun1()​ 执行进度往下推进，下次调用时就会从 1-&gt;​ 这个分支执行。\n调用 fun2()​ 获取其结果，如果结果为 COROUTINE_SUSPENDED​ ，说明 fun2()​ 挂起，fun1()​ 也返回COROUTINE_SUSPENDED，​表示自己因为 fun2()​ 的挂起而挂起。然而实际上fun2()​ 是一个披着 suspend 外衣的普通方法，Kotlin 并不会将它当做 suspend 方法看待，这个方法编译后是一个普通的同步方法，所以此处 fun2()​ 返回的是 1，fun1()​ 会跳转到 61 行继续执行。\n将 fun2()​ 返回值累加到 localInt​ 上；\n将 label​ 置为 2​，将 fun1()​ 执行往下推进。下次执行时就会从 2-&gt;​ 这个分支执行。由此可见，1-&gt;​ 分支实际上并不会被执行，这是 fun2()​ 为同步方法造成的；\n调用 fun3()​ ，fun3()​ 是一个 suspend 方法，它会返回 COROUTINE_SUSPENDED​，故fun1()​ 会从第  65 行返回，fun1()​ 的执行告一段落。\n\n​fun1()​ 此次调用结束后返回 suspend lambda 的第 11 行处：fun1Result = fun1(this as Continuation)​，前面我们说 fun1()​ 返回的是 COROUTINE_SUSPENDED​，这个结论在此处得到了印证。\n接下来我们分析 fun3()​，fun3()​ 的反编译代码我就不放了，我们直接看用 Kotlin 改写后的简化版：\nfun3private class Fun3Continuation(    val completion: Continuation&lt;Any?&gt;) : ContinuationImpl&lt;Any?&gt;(completion) &#123;    var label = 0    var result: Any? = null    override val context = completion.context    override fun invokeSuspend(result: Result&lt;Any?&gt;) &#123;\t\tthis.result = result.getOrNull()\t\tthis.label = this.label or 0x80000000\t\treturn fun3(this)    &#125;&#125;fun fun3(continuation: Continuation&lt;Any?&gt;): Any? &#123;    val cont = if (continuation is Fun3Continuation) &#123;        if ((continuation.label and 0x80000000) != 0) &#123;            continuation.label = continuation.label and 0x7fffffff            continuation        &#125; else &#123;            Fun3Continuation(continuation)        &#125;    &#125; else &#123;        Fun3Continuation(continuation)    &#125;    var result = cont.result\twhen (cont.label) &#123;        0 -&gt; &#123;            Result.throwOnFailure(result)            cont.label = 1            val res = delay(1000L, cont)            if (res === COROUTINE_SUSPENDED) return COROUTINE_SUSPENDED        &#125;        1 -&gt; &#123;            Result.throwOnFailure(result)        &#125;        else -&gt; throw IllegalStateException(&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;)     &#125;     return 1&#125;\n\n逻辑和 fun1()​ 是大同小异的，前面的就不赘述了，进入到 0-&gt; ​分支后，调用了 delay()​ 方法，这是 Kotlin 提供的延时函数，它也是一个 suspend 方法，因此它会返回 COROUTINE_SUSPENDED​给 fun1()​，这和前面的分析是一致的。\n继续深入下去会发现，delay()​ 会将一个延时任务插入到事件循环中，1000ms​ 延时后延时任务会调用 Fun3Continuation​ 的 resumeWith()​ 方法，这个方法会调到第 9 行的 invokeSuspend()​ 方法，fun3()​ 会再次执行。再次执行时，cont.label ​的值为 1​，进入 1-&gt;​ 分支，检查无异常后代码走到 45 行返回 1​，fun3()​ 执行完毕。\n​fun3​ 执行完成后，Fun3Continuation​会用 fun3​ 的执行结果 1​ 作为参数调用其 completion​ 也就是 Fun1Continuation​ 的 resumeWith()​ 方法，这个方法会调到第 8 行的 invokeSuspend()​ 方法，这会导致 fun1()​ 再次执行，再次执行时 cont.label​ 的值为 2​，会走到 2-&gt;​ 分支，检查无异常后代码走到第 69 行，将 fun3()​ 的执行结果 1​ 累加到 localInt​ 后将其作为最终结果返回，fun1()​ 执行完毕。\n​fun1()​ 执行完成后，Fun1Continuation​会用 fun1​ 的执行结果 localInt​ 作为参数调用其 completion​也就是 _SuspendLambda​ 的 resumeWith()​ 方法，这个方法会调到第 5 行的 invokeSuspend()​ 方法，会导致 suspend lambda 再次执行，再次执行时  label​ 值为 1​， 会走到 1 -&gt;​分支处，检查无异常后代码走到第 26 行，将 fun1()​ 的执行结果 localInt​ 打印出来，suspend lambda 执行完毕。\nBlockingCoroutine前面说过，当一个 suspend 方法结束后，它的上游 suspend 方法的 Continuation​ 的 resumeWith()​ 会被调用。那么问题来了，当顶层的 suspend lambda 结束后呢？答案是 BlockingCoroutine​ 的 resumeWith()​ 会被调用。虽然 suspend lambda 没有上游 suspend 方法，但是它有上游  Continuation​，BlockingCoroutine​ 就是这个上游 Continuation​，它是 _SuspendLambda#create() ​调用时传进去的。BlockingCoroutine​ 定义如下：\nprivate class BlockingCoroutine&lt;T&gt;(    parentContext: CoroutineContext,    private val blockedThread: Thread,    private val eventLoop: EventLoop?) : AbstractCoroutine&lt;T&gt;(parentContext, true, true) &#123;     ...... &#125;\n\n它继承自 AbstractCoroutine​：\nAbstractCoroutinepublic abstract class AbstractCoroutine&lt;in T&gt;(    parentContext: CoroutineContext,    initParentJob: Boolean,    active: Boolean) : JobSupport(active), Job, Continuation&lt;T&gt;, CoroutineScope &#123;   ……    protected open fun onCompleted(value: T) &#123;&#125;    protected open fun onCancelled(cause: Throwable, handled: Boolean) &#123;&#125;   ……    /**     * Completes execution of this with coroutine with the specified result.     */    public final override fun resumeWith(result: Result&lt;T&gt;) &#123;        val state = makeCompletingOnce(result.toState())        if (state === COMPLETING_WAITING_CHILDREN) return        afterResume(state)    &#125;    protected open fun afterResume(state: Any?): Unit = afterCompletion(state)    ……&#125;\n\n​AbstractCoroutine#resumeWith​最终会调到JobSupport#afterCompletion()​，它在 BlockingCoroutine​有实现：\nprivate class BlockingCoroutine&lt;T&gt;(    parentContext: CoroutineContext,    private val blockedThread: Thread,    private val eventLoop: EventLoop?) : AbstractCoroutine&lt;T&gt;(parentContext, true, true) &#123;    override val isScopedCoroutine: Boolean get() = true    override fun afterCompletion(state: Any?) &#123;        // wake up blocked thread        if (Thread.currentThread() != blockedThread)            unpark(blockedThread)    &#125;    @Suppress(&quot;UNCHECKED_CAST&quot;)    fun joinBlocking(): T &#123;        registerTimeLoopThread()        try &#123;            eventLoop?.incrementUseCount()            try &#123;                while (true) &#123;                    @Suppress(&quot;DEPRECATION&quot;)                    if (Thread.interrupted()) throw InterruptedException().also &#123; cancelCoroutine(it) &#125;                    val parkNanos = eventLoop?.processNextEvent() ?: Long.MAX_VALUE                    // note: process next even may loose unpark flag, so check if completed before parking                    if (isCompleted) break                    parkNanos(this, parkNanos)                &#125;            &#125; finally &#123; // paranoia                eventLoop?.decrementUseCount()            &#125;        &#125; finally &#123; // paranoia            unregisterTimeLoopThread()        &#125;        // now return result        val state = this.state.unboxState()        (state as? CompletedExceptionally)?.let &#123; throw it.cause &#125;        return state as T    &#125;&#125;\n\n​afterCompletion ​会将 runBlocking()​ 的调用者线程唤醒，这通常发生在 runBlocking()​调用线程和协程运行线程不相同的情况下，例如我们调用 runBlocking()​ 的时候，指定了 Dispatcher​:\nrunBlocking(Dispatchers.IO, &#123;\t……&#125;)\n\n这会导致 24 行的 eventLoop​ 为 null​，从而让调用者线程走到 27 行进行无限时长的休眠，以达到阻塞调用者线程的目的。这种情况下就需要协程在 Dispatcher 线程中结束后，唤醒 runBlocking() 调用者线程，从而继续执行后面的代码。\n否则，如果没有指定 Dispatcher​，eventLoop 便会充当 Dispatcher， eventLoop 不为 null，协程会运行在 runBlocking() 调用者线程驱动的 eventLoop 中。调用者线程自身会因为在 while 循环中持续运行 eventLoop​ 自行阻塞。等协程结束后，eventLoop​ 会在 26 行退出，因此协程结束的回调​afterCompletion 中用 if 语句做了一个判断：当协程运行在调用者线程中时，并不需要唤醒调用者线程。\n总结\n每一个 suspend​ 方法都和一个 Continuation​ 对象关联着；（fun2()​ 这种并没有真正 suspend​ 的方法除外）\n当一个方法返回 COROUTINE_SUSPENDED​ 时，其实就是就是告诉调用者自己将会挂起（暂停），这个返回值会导致 suspend 调用栈中止，调用栈上游的所有方法也都被挂起；\n下游 suspend 方法恢复时，会通过调用上游 suspend 方法所关联的 Continuation​ 对象的 resumeWith()​ 方法，触发上游方法的恢复。\n\n最后画一张图帮助理解：\n\n Kotlin 协程中的所谓状态机，其实就是 Kotlin 为 suspend​ 方法生成的 Continuation​ 对象，Continuation​ 负责存储状态，suspned 方法恢复时从哪开始执行以及方法当前局部变量值由 Continuation​ 中的状态决定。\n​Contiuation​ 在无栈协程中充当了栈帧（上下文）的作用：\n\n保存了局部变量，即 Continuation​ 中的 I$0​ 字段；\n保存了方法中断后的返回地址，即 label​；\n每一个 Continuation​ 通过 completion​ 字段引用上游方法的 Continuation​，构成了一条Continuation​ 链，这就是 suspend​ 方法专属的 “调用栈”。\n\n","tags":["Kotlin","协程"]},{"title":"对 Rust 所有权的理解","url":"/2025/12/07/2025-12-07-Rust-ownership-understanding/","content":"Rust 所有权规则简述对于低级语言而言，对象的回收往往是一个难题。一个对象创建后，往往会在各个地方传递，由于对象的引用者们生命周期不尽相同，也就不知道何时、由谁来负责对象的回收。\nRust 所有权规则是如何解决这个问题的呢？它把对象分为可变对象和不可变对象，对象的引用者分为所有者和借用者。下面是我根据自己的理解做的总结：\n\n一个对象有且只能有一个所有者，对象的回收由其所有者负责，对象的所有权可以转移。\n\n借用分为可变借用和不可变借用：\n\n多个不可变借用可共存；\n可变借用不可和其他借用共存，无论借用是可变还是不可变；\n对象所有者不能在不可变借用前写对象，不能在可变借用前读写对象；\n可变对象可以有可变和不可变借用，不可变对象只能有不可变借用；\n\n\n对象的所有权转移时，对象的可变性可以发生更改。\n\n\n不能共存指的是它们的作用域不能有交集\n\n\n\n我们知道，编译器是知道栈上每一个变量的生命周期的。对于栈上的每一个变量，如果它是对象的借用者，那么它会在生命周期结束后释放借用，如果是对象的所有者，Rust 会在该变量生命周期结束时，将该对象回收，具体做法是：\n\n如果对象实现了 Drop trait 方法，调用它的 drop 方法以释放其持有的资源；\n如果对象包含其他对象（包含对象本身，而非包含对象的借用），对这些对象递归执行这两件事。\n\n结合代码直观体会上述概念：\nfn main() &#123;    let a = String::from(&quot;value&quot;);  // a 为这个 String 对象的所有者    &#123;        let b = &amp;a; // b 通过 &amp; 操作符获取对象的借用    &#125; // b 生命周期结束，释放借用&#125; // a 生命周期结束，释放对象\n\nRust 中的赋值操作默认使用的是 move 语义，move 语义就是用来实现资源所有权的转移。除了赋值，传参、return 这些操作使用的也都是 move 语义，除非类型实现了 Copy trait，那就使用 copy 语义，copy 语义不会转移原变量的所有权，原变量依然持有原对象的所有权，新变量拥有的是拷贝后的对象的所有权，例如：\nfn main() &#123;    let a = String::from(&quot;value&quot;);  // a 为这个 String 对象的所有者    &#123;        let b = &amp;a; // b 通过 &amp; 操作符获取对象的借用    &#125; // b 生命周期结束，释放借用    let c = a;  // a 所有权转移，不可再用        let i = 12; // i 成为这个 i32 对象的所有者    let j = i; // 对象不发生移动，而是拷贝，因为 i32 实现了 Copy trait    i; // i 依然可用&#125; // c 生命周期结束，释放对象\n\n我们看下在借用前后读写原对象的情形：\nstruct Person &#123;    age: i32,    name: &amp;&#x27;static str&#125;fn main() &#123;    let mut p = Person &#123;        age: 25,        name: &quot;John&quot;    &#125;;    let p1 = &amp;p; // 不可变借用    p.age; // 在不可变借用前读原对象 ✅    // p.age = 12; // 在不可变借用前写原对象 ❌    p1.age;    p.age; // 在不可变借用后读原对象 ✅    p.age = 12; // 在不可变借用后写原对象 ✅&#125; fn test2() &#123;    let mut p = Person &#123;        age: 25,        name: &quot;John&quot;    &#125;;    let p1 = &amp;mut p; // 可变借用    // p.age; // 在可变借用前读原对象 ❌    // p.age = 12; // 在可变借用前写原对象 ❌    p1.age;    p.age; // 在可变借用后读原对象 ✅    p.age = 12; // 在可变借用后写原对象 ✅&#125; \n\n转移所有权时可改写对象可变性：\nfn main() &#123;    let p = Person &#123;        age: 12,        name: &quot;John&quot;    &#125;;    change_mutability(p); // 所有权转移，对象由不可变转为可变。    &#125;fn change_mutability(mut p: Person) &#123;    p.age = 13;    let q = p; // 所有权转移，对象由可变转为不可变。&#125;\n\n相关语义的实现copy 语义按位复制对象，即浅拷贝。因其浅拷贝的特性，Rust 有一条规则：实现了 Copy trait 的对象，不允许再实现 Drop trait，且内部对象也必须实现 Copy trait，也就意味着内部对象也不允许实现 Drop trait，如此递归下去……\n如何理解这条规则？我们反过来想，一个对象如果实现了 Drop trait，它一定有独立于对象之外的资源需要释放，而 Copy trait 属于浅拷贝，只会按位复制对象本身，包括资源句柄（例如文件描述符，堆内存指针，socket 描述符等）。相同的资源句柄往往指向同一资源，因此 Copy 后两个对象共享外部资源。我们知道，编译器会在所有权变量作用域失效的位置插入 drop调用释放其持有的外部资源，如果 copy 后的两个所有权变量都执行了 drop，就会触发共享资源的双重释放。通常来说，资源重复释放是不允许的，比如堆内存就是这样，因此禁止实现了 Copy trait 同时实现 Drop trait 是一个很合理的做法。那是否存在这样一种情况：对象有需要释放的资源，它必须实现 Drop trait，但又想实现拷贝？有的，但这种情况往往隐含了一个前提，就是资源是非共享的，此时开发者应实现 Clone trait 而不是 Copy trait 来实现资源的拷贝，即深拷贝。\n以下对象默认实现了 Copy trait：\n\n基本标量类型\n元组（当所有元素都实现 Copy 时）\n数组（当元素类型实现 Copy 时）\n不可变引用 (&amp;T)\n函数指针 (fn)\n裸指针 (*const T, *mut T)\nNever 类型 (!)\n单元类型 (())\n标记类型（如 PhantomData）\n\n一般来说，类型的使用者通常不需要关心其是否实现 Copy trait，否则写代码时的心智负担就太重了。\nmove 语义实际上是编译时检查 + 运行时浅拷贝实现的，原有对象其实还在内存中躺着，只是编译器不会让你继续使用所有权被转移的变量（除非对象实现了Copy trait）。\n感觉 move 语义完全可以只在编译器层面实现，只要编译器确保原有变量不可用，运行时就可以复用它持有的对象，而不是拷贝一份。难道是为了模仿 C ++ 的移动语义，确保兼容性？\n\n可以用以下代码来验证：\nfn main() &#123;    let s = String::from(&quot;value&quot;);    // 将 &amp;s 作为 raw pointer 使用，需要经历两次转换，先将引用转成 String 指针，再将指针类型转为 u64 指针;    // Rust 中的借用本质就是一个指针，只不过编译器赋予了它 “借用” 的语义，从而将其纳入 Rust 的所有权模型中进行管理。    let s_ref = &amp;s as *const String as *const u64;    println!(&quot; ---------- 所有权转移前 ---------&quot;);    println!(&quot;s 对象地址：&#123;:p&#125;&quot;, s_ref);    println!(&quot;s 字符串缓冲区地址：&#123;:p&#125;&quot;, s.as_ptr());    unsafe &#123;        println!(&quot;s 对象内容：&#123;:#x&#125;, &#123;:#x&#125;, &#123;:#x&#125;&quot;, *s_ref, *s_ref.add(1), *s_ref.add(2));    &#125;    let s2 = s;    let s2_ref = &amp;s2 as *const String as *const u64;    println!(&quot; ---------- 所有权转移后 ---------&quot;);    println!(&quot;s2 对象地址：&#123;:p&#125;&quot;, s2_ref);    println!(&quot;s2 字符串缓冲区地址：&#123;:p&#125;&quot;, s2.as_ptr());    unsafe &#123;        println!(&quot;s2 对象内容：&#123;:#x&#125;, &#123;:#x&#125;, &#123;:#x&#125;&quot;, *s2_ref, *s2_ref.add(1),*s2_ref.add(2));        println!(&quot;s 对象 “尸体”：&#123;:#x&#125;, &#123;:#x&#125;, &#123;:#x&#125;&quot;, *s_ref, *s_ref.add(1), *s_ref.add(2));    &#125;&#125;\n\n运行结果：\n ---------- 所有权转移前 ---------s 对象地址：0x7fffd3847200s 字符串缓冲区地址：0x572640b66d00s 对象内容：0x5, 0x572640b66d00, 0x5 ---------- 所有权转移后 ---------s2 对象地址：0x7fffd38473a0s2 字符串缓冲区地址：0x572640b66d00s2 对象内容：0x5, 0x572640b66d00, 0x5s 对象 “尸体”：0x5, 0x572640b66d00, 0x5\n\n可见，move 语义只是将 String 对象在栈上浅拷贝一份，且原有对象不会被清理也没有清理的必要。\n从打印结果可以看出，String 对象在栈上内存布局从低到高依次是：capacity （u64)，ptr（u64），len（u64），这和官方示意图不一样，不知为何 🤨。\n\n但并不是所有情况下，move 语义都会用运行时的浅拷贝来实现。实测发现，在传参的时候，如果对象的大小大于 8 字节，不会触发浅拷贝，move 语义仅停留在语法层面，测试代码如下：\nstruct M(u16, u16, u16, u8, u16);  // 9 字节// struct M(u16, u16, u16, u8, u8);  // 8 字节// 更好的方式：只实现 Clone，或者提供引用接口fn main() &#123;    let a = M(1, 1, 1, 1, 1);    let a_ref = &amp;a as *const M;    println!(&quot;原始地址：&#123;:p&#125;&quot;, a_ref);    let b = a;    let b_ref = &amp;b as *const M;    println!(&quot;赋值后地址：&#123;:p&#125;&quot;, b_ref);    let d = test(b);    let d_ref = &amp;d as *const M;    println!(&quot;函数返回后地址：&#123;:p&#125;&quot;, d_ref);&#125;fn test(c: M) -&gt; M&#123;    let c_ref = &amp;c as *const M;    println!(&quot;函数参数地址：&#123;:p&#125;&quot;, c_ref);    return c;&#125;\n\n输出：\n# M 大于 8 字节时，传参时 move 前后对象地址一致原始地址：0x7ffe50f05f26赋值后地址：0x7ffe50f05f8e函数参数地址：0x7ffe50f05f8e函数返回后地址：0x7ffe50f05ff6# M 小于等于 8 字节时，三种场景下 move 前后对象地址都不同原始地址：0x7fff7ddb8188赋值后地址：0x7fff7ddb81e8函数参数地址：0x7fff7ddb8108函数返回后地址：0x7fff7ddb8248\n\n以上分析是基于原对象在栈上分配的情形，如果原对象是堆上分配的，原理应该也差不多。","tags":["Rust"]}]