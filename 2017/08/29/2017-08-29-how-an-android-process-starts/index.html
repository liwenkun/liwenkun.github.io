<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="150x150" href="/images/favicon-150x150-next.png">
  <link rel="icon" type="image/png" sizes="150x150" href="/images/favicon-150x150-next.png">
  <link rel="icon" type="image/png" sizes="150x150" href="/images/favicon-150x150-next.png">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liwenkun.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":{"disqus":{"order":-2}}},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="Android 进程启动原理前言Android 中的应用是支持多进程的，我们只要在 AndroidManifest 中给四大组件指定 android:process 属性即可让其运行在独立的进程当中。那么应用的主进程又是如何被创建的呢？一般来说，当我们的应用没有任何组件处于运行状态，此时其他应用启动我们应用的组件时，应用的主进程就会被创建，进程相当于是提供了组件运行的空间。最常见的触发应用主进程被">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 进程启动原理">
<meta property="og:url" content="https://liwenkun.github.io/2017/08/29/2017-08-29-how-an-android-process-starts/index.html">
<meta property="og:site_name" content="Chance 的博客">
<meta property="og:description" content="Android 进程启动原理前言Android 中的应用是支持多进程的，我们只要在 AndroidManifest 中给四大组件指定 android:process 属性即可让其运行在独立的进程当中。那么应用的主进程又是如何被创建的呢？一般来说，当我们的应用没有任何组件处于运行状态，此时其他应用启动我们应用的组件时，应用的主进程就会被创建，进程相当于是提供了组件运行的空间。最常见的触发应用主进程被">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-08-29T00:00:00.000Z">
<meta property="article:modified_time" content="2025-12-07T11:28:36.288Z">
<meta property="article:author" content="Chance">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="进程">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://liwenkun.github.io/2017/08/29/2017-08-29-how-an-android-process-starts/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Android 进程启动原理 | Chance 的博客</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-76493784-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-76493784-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4cc1f2d8f3067386cc5cdb626a202900";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chance 的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">吾生也有涯</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">27</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">28</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liwenkun.github.io/2017/08/29/2017-08-29-how-an-android-process-starts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/95a0f14d3e6b40995a92c41673fd09d4?s=640">
      <meta itemprop="name" content="Chance">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chance 的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android 进程启动原理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-29 00:00:00" itemprop="dateCreated datePublished" datetime="2017-08-29T00:00:00+00:00">2017-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-07 11:28:36" itemprop="dateModified" datetime="2025-12-07T11:28:36+00:00">2025-12-07</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Android-进程启动原理"><a href="#Android-进程启动原理" class="headerlink" title="Android 进程启动原理"></a>Android 进程启动原理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Android 中的应用是支持多进程的，我们只要在 AndroidManifest 中给四大组件指定 android:process 属性即可让其运行在独立的进程当中。那么应用的主进程又是如何被创建的呢？一般来说，当我们的应用没有任何组件处于运行状态，此时其他应用启动我们应用的组件时，应用的主进程就会被创建，进程相当于是提供了组件运行的空间。最常见的触发应用主进程被创建的方式是应用 A 通过 startActivity 或者 startActivityForResult 启动应用 B，并且应用 B 此时没有任何组件处于运行状态，那么系统先会通过 AMS 为 B 创建一个进程，等进程创建好了再通知应用 B 创建并运行该 Activity。AMS 是运行在 system_server 进程当中的，这个进程并不会 fork 出应用进程，那么应用进程到底是哪个进程创建的呢？这就得从 Zygote 进程说起。</p>
<span id="more"></span>
<h2 id="Zygote-进程"><a href="#Zygote-进程" class="headerlink" title="Zygote 进程"></a>Zygote 进程</h2><h3 id="zygote-进程的启动"><a href="#zygote-进程的启动" class="headerlink" title="zygote 进程的启动"></a>zygote 进程的启动</h3><p>Zygote 的中文意思是“受精卵”，它的字面意思很形象的概括了 Zygote 进程在 Android 系统中的作用——“分裂”出其他进程。Zygote 进程是所有 Android 应用的父进程，并且还是 system_server 的父进程。由此看来，Zygote 进程在 Android 系统中发挥了举足轻重的作用。但是 Zygote 并不是 Android  系统中的第一个进程，它也是其他进程 fork 来的，这个进程就是 init 进程，它是用户空间的第一个进程。init 进程就是用来解析并执行 init.rc 配置文件的，这个文件位于系统根目录下，这个配置文件中会导入其他的配置文件如 init.zygote32.rc 或者 init.zygote64_32.rc，具体导入哪一个由 ro.zygote 的值决定。这两个配置文件的作用就是启动 Zygote 进程。在 init.zygote32.rc 中，启动 Zygote 的语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">serivce zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">	class main</span><br><span class="line">	socket zygote stream 660 root system</span><br><span class="line">	onrestart write /sys/android_power/request_state wake</span><br><span class="line">	onrestart write /sys/power/state on</span><br><span class="line">	onrestart restart media</span><br><span class="line">	onrestart restart netd</span><br></pre></td></tr></table></figure>

<p>我们主要看 service 块的第一行，这行命令的语义是：启动一个名为 zygote 的服务，这个服务的可执行文件路径是 &#x2F;system&#x2F;bin&#x2F;app_process。后面跟的都是 app_process 这个可执行文件的参数。app_process 对应的源码文件为你 app_main.c，这个源码文件的 main() 方法中有对这些参数的解释：以 - 开头的都是虚拟机参数，这些参数会传入即将要启动的虚拟机中；接下来是运行目录，有点类似终端执行命令时的当前目录，在这里是 &#x2F;system&#x2F;bin；接下来是一些以 – 开头的参数，这些参数表示启动参数，“–zygote” 表示启动的是 zygote 进程，“–application”表示启动的是普通 Java 进程，“–start-system-server” 表示要启动 system_server 进程，“–nice-name”用来指定进程的名字。接下来的参数指明的是要启动的 Java 类，如果前面使用了 “–zygote“参数，那么启动的就是 zygote 进程，这里就可以不指明，因为 zygote 进程默认就是执行 ZygoteInit 类，如果使用了 “–application”，那么启动的就是普通的 Java 进程，这里需要指明要执行的 Java 主类；接下来的参数是都是传入该主类的参数，这些参数只有启动的是普通 Java 进程时才有用。</p>
<p>app_main.c 的 main() 方法的主要逻辑都是在解析相应的参数，它对参数的的解析主要分为以下几个步骤：</p>
<ul>
<li>创建 AppRuntime 并解析虚拟机参数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* <span class="type">const</span> argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    AppRuntime <span class="title function_">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span>;</span><br><span class="line">    <span class="comment">// Process command line arguments</span></span><br><span class="line">    <span class="comment">// ignore argv[0]</span></span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; argv[i][<span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++i; <span class="comment">// Skip --.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        runtime.addOption(strdup(argv[i])); <span class="comment">//将有效参数加入到虚拟机参数表中</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解析启动参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* const argv[])</span> </span><br><span class="line">&#123;	</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        const <span class="type">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (strcmp(arg, <span class="string">&quot;--zygote&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(arg, <span class="string">&quot;--start-system-server&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(arg, <span class="string">&quot;--application&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strncmp(arg, <span class="string">&quot;--nice-name=&quot;</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strncmp(arg, <span class="string">&quot;--&quot;</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg); <span class="comment">// 解析到了主类名，说明启动的是普通 Java 程序</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>准备要执行的主类的参数，这里的主类只有“ZygoteInit” 和 “RuntimeInit”两种</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* const argv[])</span> </span><br><span class="line">&#123;	</span><br><span class="line">	......</span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    <span class="keyword">if</span> (!className.isEmpty()) &#123;</span><br><span class="line">    	 <span class="comment">// 非 zygote 模式，我们需要将后面的参数传入 AppRuntime 中保存，而不是传入 RuntimeInit 中</span></span><br><span class="line">        args.add(application ? String8(<span class="string">&quot;application&quot;</span>) : String8(<span class="string">&quot;tool&quot;</span>));</span><br><span class="line">        runtime.setClassNameAndArgs(className, argc - i, argv + i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// zygote 模式</span></span><br><span class="line">        maybeCreateDalvikCache();</span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(<span class="string">&quot;start-system-server&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> prop[PROP_VALUE_MAX];</span><br><span class="line">        <span class="keyword">if</span> (property_get(ABI_LIST_PROPERTY, prop, NULL) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">&quot;app_process: Unable to determine ABI list from property %s.&quot;</span>,</span><br><span class="line">                ABI_LIST_PROPERTY);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String8 <span class="title function_">abiFlag</span><span class="params">(<span class="string">&quot;--abi-list=&quot;</span>)</span>;</span><br><span class="line">        abiFlag.append(prop);</span><br><span class="line">        args.add(abiFlag);</span><br><span class="line">        <span class="comment">// zygote 模式中，将后面的参数全部传入 ZygoteInit 的 main() 方法中</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改进程名</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* const argv[])</span> </span><br><span class="line">&#123;	</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">        runtime.setArgv0(niceName.string());</span><br><span class="line">        set_process_name(niceName.string());</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>启动 “ZygoteInit” 或者 “RuntimeInit” 类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* const argv[])</span> </span><br><span class="line">&#123;	</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123; <span class="comment">// 如果启动的是 zygote 进程</span></span><br><span class="line">        runtime.start(<span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123; <span class="comment">// 如果启动的是普通 Java 进程</span></span><br><span class="line">        runtime.start(<span class="string">&quot;com.android.internal.os.RuntimeInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则报错</span></span><br><span class="line">        fprintf(stderr, <span class="string">&quot;Error: no class name or --zygote supplied.\n&quot;</span>);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">&quot;app_process: no class name or --zygote supplied.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>start() 方法最终会启动虚拟机并执行上面传入的类。这里可能有点奇怪，说好的启动普通 Java 进程时启动的是指定的 Java 主类，为什么这里却是执行 RuntimeInit 呢？其实逻辑是这样的：先执行 RuntimeInit 做一些必要的设置，再回到 AppRuntime 中执行指定的 Java 主类。这也就为什么在第三步的时候普通 Java 类的类名和参数要通过 AppRuntime#setClassNameAndArgs 的成员变量中，而 ZygoteInit 的参数保存在 args:Vector<String8> 中。因为这样从 RuntimeInit 回到 AppRuntime 中时就可以根据之前保存的类名和参数去执行指定的 Java 主类了。更详细的解析需要通过阅读 AppRuntime 的源码来说明。</p>
<h3 id="AndroidRuntime"><a href="#AndroidRuntime" class="headerlink" title="AndroidRuntime"></a>AndroidRuntime</h3><p>AppRuntime 继承自 AndroidRuntime，它的大部分方法都直接继承自 AndroidRuntime，它仅仅是实现了 AndroidRuntime 定义的一些生命周期回调方法。所以我们重点来看 AndroidRuntime，首先看看它的构造方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AndroidRuntime::<span class="built_in">AndroidRuntime</span>(<span class="type">char</span>* argBlockStart, <span class="type">const</span> <span class="type">size_t</span> BlockLength) :</span><br><span class="line">        <span class="built_in">mExitWithoutCleanup</span>(<span class="literal">false</span>),</span><br><span class="line">        <span class="built_in">mArgBlockStart</span>(argBlockStart),</span><br><span class="line">        <span class="built_in">mArgBlockLength</span>(argBlockLength)</span><br><span class="line">&#123;</span><br><span class="line">    SkGraphics::<span class="built_in">Init</span>();</span><br><span class="line">    <span class="comment">// mOptions 用来存储虚拟机参数</span></span><br><span class="line">    mOptions.<span class="built_in">setCapacity</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(gCurRuntime == <span class="literal">NULL</span>);        <span class="comment">// 确保只有一个实例</span></span><br><span class="line">    gCurRuntime = <span class="keyword">this</span>; <span class="comment">// 将该实例的指针保存在 gCurRuntime 这个全局指针中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 app_main.c 的 main() 方法中我们看到过 AppRuntime 的实例化过程，它是作为一个局部变量创建的，在 C++ 中，局部变量是在栈上分配的，而栈上分配的变量有一个特点，就是在方法执行完后它对应的内存就会被自动释放掉，不管是否有指向该变量的引用，所以一般不让全局的指针指向局部变量，这一点和 Java 有所不同。因此这里会有一个问题：如果 main() 方法执行完了，那么 gCurRuntime 所指向的那块内存已经被释放掉了，那么当我们引用 gCurRuntime 时程序肯定会报错。的确，如果 main() 运行完毕了我们在通过引用 gCurRuntime 去调用 AppRuntime 实例的方法肯定会报错，但关键在于，main() 方法退出了程序也就退出了，程序根本没有再引用 gCurRuntime 的机会了，这样看来，是不用担心 gCurRuntime 指向已释放内存的，在程序中可以放心使用。</p>
<p>现在来看看它的一个重要方法，也是上面用到过的方法——start()，这个方法主要做了以下几件事：</p>
<ul>
<li>启动虚拟机：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JniInvocation jni_invocation;</span><br><span class="line">jni_invocation.<span class="built_in">Init</span>(<span class="literal">NULL</span>);</span><br><span class="line">JNIEnv* env;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">startVm</span>(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建了虚拟机并且导出了 JNIEnv 对象，这个对象可以用来和 Java 层交互。</p>
<ul>
<li>回调 onVmCreated(env) 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="keyword">void</span> <span class="title function_">onVmCreated</span><span class="params">(JNIEnv* env)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mClassName.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// Zygote. Nothing to do here.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将类名中的 . 替换成 /</span></span><br><span class="line">    <span class="type">char</span>* slashClassName = toSlashClassName(mClassName.string());</span><br><span class="line">    mClass = env-&gt;FindClass(slashClassName); <span class="comment">// 查找指定的类</span></span><br><span class="line">    <span class="keyword">if</span> (mClass == NULL) &#123; <span class="comment">// 找不到这个类</span></span><br><span class="line">        ALOGE(<span class="string">&quot;ERROR: could not find class &#x27;%s&#x27;\n&quot;</span>, mClassName.string());</span><br><span class="line">    &#125;</span><br><span class="line">    free(slashClassName);</span><br><span class="line">    mClass = reinterpret_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(mClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前说了，AppRuntime 实现了 AndroidRuntime 中定义的各种生命周期回调方法，onVmCreated() 方法就是其中之一，因此这个方法的实现在 AppRuntime 中。这里对启动的是 zygote 进程还是普通的 Java 进程进行了不同的处理，如果是  zygote 进程，那么什么也不干，如果是普通的 Java 进程，那么就根据之前保存的类名来加载这个类。</p>
<ul>
<li>注册 JNI 函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">&quot;Unable to register all android natives\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步会将很多 Java 层的 native 方法和 C++ 层的方法对应起来。</p>
<ul>
<li>准备 Java 类的参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">jclass stringClass;</span><br><span class="line">jobjectArray strArray;</span><br><span class="line">jstring classNameStr;</span><br><span class="line"></span><br><span class="line">stringClass = env-&gt;FindClass(<span class="string">&quot;java/lang/String&quot;</span>);</span><br><span class="line"><span class="keyword">assert</span>(stringClass != NULL);</span><br><span class="line">strArray = env-&gt;NewObjectArray(options.size() + <span class="number">1</span>, stringClass, NULL);</span><br><span class="line"><span class="keyword">assert</span>(strArray != NULL);</span><br><span class="line">classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line"><span class="keyword">assert</span>(classNameStr != NULL);</span><br><span class="line">env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; options.size(); ++i) &#123;</span><br><span class="line">    <span class="type">jstring</span> <span class="variable">optionsStr</span> <span class="operator">=</span> env-&gt;NewStringUTF(options.itemAt(i).string());</span><br><span class="line">    <span class="keyword">assert</span>(optionsStr != NULL);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建了一个 Java 字符串数组对象，然后把 C++ 字符串转换成 Java 层的字符串对象后放进该数组中。除了原本在 options 中的字符串外，这里还会把要启动的类的完整类名作为第一个元素放进字符串数组中。</p>
<ul>
<li>启动 Java 类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment">  * not return until the VM exits.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="type">char</span>* slashClassName = toSlashClassName(className);</span><br><span class="line"> <span class="type">jclass</span> <span class="variable">startClass</span> <span class="operator">=</span> env-&gt;FindClass(slashClassName);</span><br><span class="line"> <span class="keyword">if</span> (startClass == NULL) &#123;</span><br><span class="line">     ALOGE(<span class="string">&quot;JavaVM unable to locate class &#x27;%s&#x27;\n&quot;</span>, slashClassName);</span><br><span class="line">     <span class="comment">/* keep going */</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 找到 main 方法</span></span><br><span class="line">     <span class="type">jmethodID</span> <span class="variable">startMeth</span> <span class="operator">=</span> env-&gt;GetStaticMethodID(startClass, <span class="string">&quot;main&quot;</span>,</span><br><span class="line">         <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (startMeth == NULL) &#123;</span><br><span class="line">         ALOGE(<span class="string">&quot;JavaVM unable to find main() in &#x27;%s&#x27;\n&quot;</span>, className);</span><br><span class="line">         <span class="comment">/* keep going */</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 执行 main() 方法</span></span><br><span class="line">         env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">......</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> free(slashClassName);</span><br><span class="line"> <span class="comment">// 销毁虚拟机</span></span><br><span class="line"> ALOGD(<span class="string">&quot;Shutting down VM\n&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)</span><br><span class="line">     ALOGW(<span class="string">&quot;Warning: unable to detach main thread\n&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (mJavaVM-&gt;DestroyJavaVM() != <span class="number">0</span>)</span><br><span class="line">     ALOGW(<span class="string">&quot;Warning: VM did not shut down cleanly\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这里就是启动 Java 类的地方了，根据前面的分析我们知道，这里的 Java 类只有 ZygoteInit 和 RuntimeInit 两种情况。我们先考虑启动的是 zygote 进程的情况，因此我们接下来分析一下 ZygoteInit 这个类。</p>
<h3 id="ZygoteInit"><a href="#ZygoteInit" class="headerlink" title="ZygoteInit"></a>ZygoteInit</h3><p>先看它的 main() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String argv[])</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">startSystemServer</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">socketName</span> <span class="operator">=</span> <span class="string">&quot;zygote&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">abiList</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;start-system-server&quot;</span>.equals(argv[i])) &#123;</span><br><span class="line">                startSystemServer = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unknown command line argument: &quot;</span> + argv[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        registerZygoteSocket(socketName);</span><br><span class="line">        ......</span><br><span class="line">        preload(); <span class="comment">// 预加载系统资源</span></span><br><span class="line">        ......        </span><br><span class="line">        <span class="comment">// Zygote process unmounts root storage spaces.</span></span><br><span class="line">        Zygote.nativeUnmountStorageOnInit();</span><br><span class="line">        ZygoteHooks.stopZygoteNoThreadCreation();</span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            startSystemServer(abiList, socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;Accepting command socket connections&quot;</span>);</span><br><span class="line">        runSelectLoop(abiList);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run(); <span class="comment">// 通过抛出异常的方式清理方法调用栈，从此处执行 zygote 子进程中的逻辑</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Zygote died with exception&quot;</span>, ex);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析参数，先是判断是否要启动系统进程，然后获取 abi 列表，最后获取 socket 名称。之后根据 socket 名称注册服务端 socket。接下来就会预加载系统资源，因为应用进程都需要用到系统资源，因此 zygote 提前将这些资源加载好，到时候 fork 出应用进程的时候就可以直接把预加载的系统资源复制过去了，避免每次 fork 后子进程都要重复加载一遍系统资源，提高了效率。之后会决定是否启动 system_server 进程。启动完 system_server 之后的 zygote 进程就会进入一个死循环中，它会一直监听 Socket，看有没有客户端进程向自己发起通信。</p>
<h3 id="Zygote-Fork-子进程"><a href="#Zygote-Fork-子进程" class="headerlink" title="Zygote Fork 子进程"></a>Zygote Fork 子进程</h3><p>我们通过 startActivity() 或者 startActivityForResult() 来启动另一个应用程序时，会通过 Binder 向 AMS 发动请求，AMS 接收到请求后会构造一个 ActivityRecord 对象，这个对象包含要启动的 Activity 的各种信息。之后 AMS 会判断时候 Activity 需要运行的进程是否存在，如果不存在，那么通过 socket 请求 zygote 进程 fork 出一个子进程，再将 ActivityRecord 通过 ApplicationThread 传给那个进程，让它根据这个 ActivityRecord 去启动对应的 Activity。在 AMS 中，请求 zygote fork 进程是通过 Process#start() 方法来完成的，这个方法又会调用 startViaZygote() 方法，这个方法准备好参数后会接着调用 zygoteSendArgsAndGetResult() 方法，这个的名称很好的解释了它的作用：向 zygote 进程发送参数然后获取结果。</p>
<p>zygote 进程接收到消息后就会为本次建立连接，接着会调用 zygote.forkAndSpecialize() fork子进，这个方法是通过 native 层的 ForkAndSpecializeCommon() 方法来进行 fork 的，这里不再深入，直接看看 fork 之后 Java 层的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// in child</span></span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">        serverPipeFd = <span class="literal">null</span>;</span><br><span class="line">        handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line">        <span class="comment">// should never get here, the child is expected to either</span></span><br><span class="line">        <span class="comment">// throw ZygoteInit.MethodAndArgsCaller or exec().</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// in parent...pid of &lt; 0 means failure</span></span><br><span class="line">        IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">        childPipeFd = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">    IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里根据不同的进程做了不同的处理，如果是子进程，就会调用 handleChildProc() 方法来进行子进程的初始化工作，这个方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleChildProc</span><span class="params">(Arguments parsedArgs,</span></span><br><span class="line"><span class="params">        FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span></span><br><span class="line">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    closeSocket();</span><br><span class="line">    ZygoteInit.closeServerSocket();</span><br><span class="line">    <span class="keyword">if</span> (descriptors != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Os.dup2(descriptors[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line">            Os.dup2(descriptors[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">            Os.dup2(descriptors[<span class="number">2</span>], STDERR_FILENO);</span><br><span class="line">            <span class="keyword">for</span> (FileDescriptor fd: descriptors) &#123;</span><br><span class="line">                IoUtils.closeQuietly(fd);</span><br><span class="line">            &#125;</span><br><span class="line">            newStderr = System.err;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Error reopening stdio&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.niceName != <span class="literal">null</span>) &#123;</span><br><span class="line">        Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// End of the postFork event.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="literal">null</span>) &#123;</span><br><span class="line">        WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                VMRuntime.getCurrentInstructionSet(),</span><br><span class="line">                pipeFd, parsedArgs.remainingArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                parsedArgs.remainingArgs, <span class="literal">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里关闭了 socket，因为子进程不再需要这个 socket 了。之后会通过 parseArgs.invokeWith 来判断是启动应用进程还是启动普通 Java 进程，invokeWith 对应的是 AMS 传过来的 –invoke-with 参数，invokeWith 指定的是要执行的 Java 类。由此看来，Zygote 不仅可以启动 Android 应用进程，也可以启动普通 Java 进程。</p>
<p>如果启动的是 Android 应用进程，那么 RuntimeInit.zygoteInit() 方法会得到调用，这个方法会执行一些初始化工作，如设置缺省的异常处理，设置时区以及初始化 Binder 线程池。最后会调用 invokeStaticMain() 方法调用 ActivityThread 类的 main() 方法。invokeStaticMain() 方法不会直接调用 ActivityThread 的 main() 方法，而是抛出了一个 MethodAndArgsCaller 类型的异常，这个异常和普通的异常不同，它的作用是清理栈帧，我们知道，应用程序的入口是 ActivityThread，而到目前为止，程序依旧跑在 runSelectLoop() 的循环中，在 ActivityThread.main() 方法之前已经积累了很多方法栈，应用程序正常情况下是不会退出 ActivityThread.main() 方法的，所以那些积累的方法栈除了占内存没有其他用途，因此通过抛出异常的方式将它们清理掉。invokeStaticMain() 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span></span><br><span class="line">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl = Class.forName(className, <span class="literal">true</span>, classLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Missing class when invoking static main &quot;</span> + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m = cl.getMethod(<span class="string">&quot;main&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String[].class &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Missing static main on &quot;</span> + className, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Problem getting static main on &quot;</span> + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> m.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="string">&quot;Main method is not public and static on &quot;</span> + className);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ZygoteInit</span>.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将 main() 方法对应的 Method 对象和 argv 封装在了 MethodAndArgsCaller 对象中，然后将其抛出。异常抛出了，那么在哪里进行处理呢？在 ZygoteInit 的 main() 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String argv[])</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        runSelectLoop(abiList);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run(); <span class="comment">// 通过抛出异常的方式清理方法调用栈，从此处执行 zygote 子进程中的逻辑</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Zygote died with exception&quot;</span>, ex);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的程序之前一直在 runSelectLoop() 方法内（为什么？因为 zygote 进程就是在这个方法中无限循环，因此 fork 出来的子进程也会处于这个循环中），抛出 MethodAndArgsCaller 异常后就会在这里被 catch 住，之后便会执行 MethodAndArgsCaller#run() 方法，这个方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mMethod.invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; mArgs &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> ex.getCause();</span><br><span class="line">        <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法仅仅是简单的调用了 ActivityThread#main() 方法，至此，子进程才真正意义上地开始了工作。以上便是 Zygote 进程的启动原理和 Android 应用进程的启动方式，接下来会分析一下普通的 Java 进程是如何启动的。</p>
<h2 id="普通-Java-进程的启动"><a href="#普通-Java-进程的启动" class="headerlink" title="普通 Java 进程的启动"></a>普通 Java 进程的启动</h2><p>普通的 Java 进程的启动靠的也是 app_process 这个可执行文件，一般会这样启动一个普通的 Java 程序： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app_process -Djava.class.path=classpath parentDir MainClass MainClassArgs...</span><br></pre></td></tr></table></figure>
<p>其实在分析 Zygote 进程启动过程的时候已经把一部分普通 Java 进程的逻辑也分析了，因为这两种进程有很多相似的逻辑，因此他们的代码都写在一块了。分道扬镳的地方在 AppRuntime#start() 这个方法，如果启动的是普通 Java 进程，那么便会执行 RuntimeInit#main() 方法，这个方法初始化一些东西之后便会调用 AppRuntime#onStarted() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="keyword">void</span> <span class="title function_">onStarted</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    ALOGV(<span class="string">&quot;App process: starting thread pool.\n&quot;</span>);</span><br><span class="line">    proc-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    AndroidRuntime* ar = AndroidRuntime::getRuntime();</span><br><span class="line">    ar-&gt;callMain(mClassName, mClass, mArgs);</span><br><span class="line"></span><br><span class="line">    IPCThreadState::self()-&gt;stopProcess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法作了两件事：初始化 Binder 线程池，调用我们指定 Java 类的 main() 方法。前面讲过，如果执行的是普通的 Java 类，通过 AppRuntime#setClassNameAndArgs() 方法要启动的类的类名和参数分别保存在 mClassName 和 mArgs 字段中，mClass 是在 AppRuntime#onVmCreated() 中创建的，它对应的是该类的 Class 对象。至此，一个 Java 进程就启动了。现在我们通过实践来体会一下让 Android 系统启动我们写好的普通 Java 程序。</p>
<h3 id="在-Android-系统上运行普通的-Android-程序"><a href="#在-Android-系统上运行普通的-Android-程序" class="headerlink" title="在 Android 系统上运行普通的 Android 程序"></a>在 Android 系统上运行普通的 Android 程序</h3><p>因为只是做个试验而已，因此我们就编写个 HelloWord 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">		System.out.println(args[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在编译它，记住要用 JDK1.7 编译，因为 Android 目前还不支持 JDK1.8 编译出来的 class 类。编译好后就是一个 HelloWorld.class 文件了，我们知道 DVM 无法运行 class 文件，因此我们需要通过 dx 工具将该 class 文件转换成 dex 文件。dx 工具在 <code>sdk/build-tools/build-tool版本号</code> 目录下。我们将 Test.class 放置在该目录下，然后打开终端，切换到这个目录并执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dx --dex --output=test.dex HelloWorld.class</span><br></pre></td></tr></table></figure>
<p>运行成功的话在这个目录下就能看到 test.dex 文件了，现在我们把这个文件放置在 &#x2F;sdcard 下，现在通过 adb 执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">app_process -Djava.class.path=/sdcard/test.dex HelloWorld first-parameter</span><br></pre></td></tr></table></figure>
<p>接下来不出意外的话终端会出现这两行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">first-parameter</span><br></pre></td></tr></table></figure>
<p>当然，除了通过终端的方式执行 Java 程序，也可以在 Android 应用的代码里执行。前面的步骤不变，我们编写如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppcompatActivity</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.main);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		  <span class="type">Process</span> <span class="variable">proc</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="string">&quot;app_process -Djava.class.path=/sdcard/test.dex HelloWorld first-parameter&quot;</span>);</span><br><span class="line">          <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> proc.getInputStream();</span><br><span class="line">          <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in);</span><br><span class="line">          <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr)</span><br><span class="line">          Toast.makeText(<span class="built_in">this</span>, br.readLine(), Toast.LENGTH_SHORT).show();</span><br><span class="line">          Toast.makeText(<span class="built_in">this</span>, br.readLine(), Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Android 应用一启动时就会执行启动 Java 进程的命令，接着获取该命令的输入流（可通过 Process 获取三种流，输入流、错误输入流和输出流，这分别对应着 Process 的输出流、错误输出流和输入流），接着通过 Taost 依次显示从输入流获取的两行字符串。不出意外的 Toast 会依次显示 “hello world” 和 “first-parameter”。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是对 《深入理解 Android 5.0 系统》中第八章的总结和理解。</p>
<p>参考链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://m.jb51.net/article/75147.htm">Android中执行java命令的方法及java代码执行并解析shell命令
</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/20932102/execute-shell-command-from-android">execute shell command from android</a></li>
<li><a target="_blank" rel="noopener" href="http://androidxref.com/7.1.1_r6/">AndroidXref - Android Source Code Cross Reference</a></li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>chance
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://liwenkun.github.io/2017/08/29/2017-08-29-how-an-android-process-starts/" title="Android 进程启动原理">https://liwenkun.github.io/2017/08/29/2017-08-29-how-an-android-process-starts/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"><i class="fa fa-tag"></i> Android</a>
              <a href="/tags/%E8%BF%9B%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 进程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/08/29/2017-08-29-java-annotation/" rel="prev" title="Java 注解学习总结">
      <i class="fa fa-chevron-left"></i> Java 注解学习总结
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/08/29/2017-08-29-glide-disk-cache-strategy/" rel="next" title="Glide 之磁盘缓存">
      Glide 之磁盘缓存 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <script src="https://utteranc.es/client.js"                                     repo="liwenkun/liwenkun.github.io"                                     issue-term="pathname"                                     theme="github-dark"                                     crossorigin="anonymous"                                     async>                                 </script>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Android-%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">Android 进程启动原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zygote-%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">Zygote 进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#zygote-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="nav-number">1.2.1.</span> <span class="nav-text">zygote 进程的启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AndroidRuntime"><span class="nav-number">1.2.2.</span> <span class="nav-text">AndroidRuntime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZygoteInit"><span class="nav-number">1.2.3.</span> <span class="nav-text">ZygoteInit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Zygote-Fork-%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.2.4.</span> <span class="nav-text">Zygote Fork 子进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%AE%E9%80%9A-Java-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="nav-number">1.3.</span> <span class="nav-text">普通 Java 进程的启动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-Android-%E7%B3%BB%E7%BB%9F%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%99%AE%E9%80%9A%E7%9A%84-Android-%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">在 Android 系统上运行普通的 Android 程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chance"
      src="https://www.gravatar.com/avatar/95a0f14d3e6b40995a92c41673fd09d4?s=640">
  <p class="site-author-name" itemprop="name">Chance</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liwenkun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liwenkun" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chance@liwenkun.me" title="E-Mail → mailto:chance@liwenkun.me" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://ylqhust.github.io/" title="http:&#x2F;&#x2F;ylqhust.github.io" rel="noopener" target="_blank">ylqhust的博客</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chance</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">263k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:59</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
